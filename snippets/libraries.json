{
	"GWEN.CreateTextureBorder": {
		"body": [
			"GWEN.CreateTextureBorder(${1:x}, ${2:y}, ${3:w}, ${4:h}, ${5:left}, ${6:top}, ${7:right}, ${8:bottom}, ${9:source=nil})$0"
		],
		"description": "Used in derma skins to create a bordered rectangle drawing function from an image. The texture is taken either from last argument or from SKIN.GwenTexture",
		"prefix": "GWEN.CreateTextureBorder"
	},
	"GWEN.CreateTextureCentered": {
		"body": [
			"GWEN.CreateTextureCentered(${1:x}, ${2:y}, ${3:w}, ${4:h})$0"
		],
		"description": "Used in derma skins to create a rectangle drawing function from an image. The rectangle will not be scaled, but instead it will be drawn in the center of the box. The texture is taken from SKIN.GwenTexture",
		"prefix": "GWEN.CreateTextureCentered"
	},
	"GWEN.CreateTextureNormal": {
		"body": [
			"GWEN.CreateTextureNormal(${1:x}, ${2:y}, ${3:w}, ${4:h})$0"
		],
		"description": "Used in derma skins to create a rectangle drawing function from an image. The texture of the rectangle will be scaled. The texture is taken from SKIN.GwenTexture",
		"prefix": "GWEN.CreateTextureNormal"
	},
	"GWEN.TextureColor": {
		"body": [
			"GWEN.TextureColor(${1:x}, ${2:y})$0"
		],
		"description": "When used in a material skin, it returns a color value from a point in the skin image.",
		"prefix": "GWEN.TextureColor"
	},
	"achievements.BalloonPopped": {
		"body": [
			"achievements.BalloonPopped()$0"
		],
		"description": "Adds one to the count of balloons burst. Once this count reaches 1000, the 'Popper' achievement is unlocked.",
		"prefix": "achievements.BalloonPopped"
	},
	"achievements.Count": {
		"body": [
			"achievements.Count()$0"
		],
		"description": "Returns the amount of achievements in Garry's Mod.",
		"prefix": "achievements.Count"
	},
	"achievements.EatBall": {
		"body": [
			"achievements.EatBall()$0"
		],
		"description": "Adds one to the count of balls eaten. Once this count reaches 200, the 'Ball Eater' achievement is unlocked.",
		"prefix": "achievements.EatBall"
	},
	"achievements.GetCount": {
		"body": [
			"achievements.GetCount(${1:achievementID})$0"
		],
		"description": "Retrieves progress of given achievement",
		"prefix": "achievements.GetCount"
	},
	"achievements.GetDesc": {
		"body": [
			"achievements.GetDesc(${1:achievementID})$0"
		],
		"description": "Retrieves description of given achievement",
		"prefix": "achievements.GetDesc"
	},
	"achievements.GetGoal": {
		"body": [
			"achievements.GetGoal(${1:achievementID})$0"
		],
		"description": "Retrieves progress goal of given achievement",
		"prefix": "achievements.GetGoal"
	},
	"achievements.GetName": {
		"body": [
			"achievements.GetName(${1:achievementID})$0"
		],
		"description": "Retrieves name of given achievement",
		"prefix": "achievements.GetName"
	},
	"achievements.IncBaddies": {
		"body": [
			"achievements.IncBaddies()$0"
		],
		"description": "Adds one to the count of baddies killed. Once this count reaches 1000, the 'War Zone' achievement is unlocked.",
		"prefix": "achievements.IncBaddies"
	},
	"achievements.IncBystander": {
		"body": [
			"achievements.IncBystander()$0"
		],
		"description": "Adds one to the count of innocent animals killed. Once this count reaches 1000, the 'Innocent Bystander' achievement is unlocked.",
		"prefix": "achievements.IncBystander"
	},
	"achievements.IncGoodies": {
		"body": [
			"achievements.IncGoodies()$0"
		],
		"description": "Adds one to the count of friendly NPCs killed. Once this count reaches 1000, the 'Bad Friend' achievement is unlocked.",
		"prefix": "achievements.IncGoodies"
	},
	"achievements.IsAchieved": {
		"body": [
			"achievements.IsAchieved(${1:AchievementID})$0"
		],
		"description": "Used in GMod 12 in the achievements menu to show the user if they have unlocked certain achievements.",
		"prefix": "achievements.IsAchieved"
	},
	"achievements.Remover": {
		"body": [
			"achievements.Remover()$0"
		],
		"description": "Adds one to the count of things removed. Once this count reaches 5000, the 'Destroyer' achievement is unlocked.",
		"prefix": "achievements.Remover"
	},
	"achievements.SpawnMenuOpen": {
		"body": [
			"achievements.SpawnMenuOpen()$0"
		],
		"description": "Adds one to the count of how many times the spawnmenu has been opened. Once this count reaches 100,000, the 'Menu User' achievement is unlocked.",
		"prefix": "achievements.SpawnMenuOpen"
	},
	"achievements.SpawnedNPC": {
		"body": [
			"achievements.SpawnedNPC()$0"
		],
		"description": "Adds one to the count of NPCs spawned. Once this count reaches 1000, the 'Procreator' achievement is unlocked.",
		"prefix": "achievements.SpawnedNPC"
	},
	"achievements.SpawnedProp": {
		"body": [
			"achievements.SpawnedProp()$0"
		],
		"description": "Adds one to the count of props spawned. Once this count reaches 5000, the 'Creator' achievement is unlocked.",
		"prefix": "achievements.SpawnedProp"
	},
	"achievements.SpawnedRagdoll": {
		"body": [
			"achievements.SpawnedRagdoll()$0"
		],
		"description": "Adds one to the count of ragdolls spawned. Once this count reaches 2000, the 'Dollhouse' achievement is unlocked.",
		"prefix": "achievements.SpawnedRagdoll"
	},
	"ai.GetScheduleID": {
		"body": [
			"ai.GetScheduleID(${1:sched})$0"
		],
		"description": "Translates a schedule name to its corresponding ID.",
		"prefix": "ai.GetScheduleID"
	},
	"ai.GetTaskID": {
		"body": [
			"ai.GetTaskID(${1:task})$0"
		],
		"description": "Translates a task name to its corresponding ID.",
		"prefix": "ai.GetTaskID"
	},
	"ai_schedule.New": {
		"body": [
			"ai_schedule.New(${1:name})$0"
		],
		"description": "Creates a schedule for scripted NPC.",
		"prefix": "ai_schedule.New"
	},
	"ai_task.New": {
		"body": [
			"ai_task.New()$0"
		],
		"description": "Create a new empty task. Used by Schedule:AddTask and Schedule:EngTask.",
		"prefix": "ai_task.New"
	},
	"baseclass.Get": {
		"body": [
			"baseclass.Get(${1:name})$0"
		],
		"description": "Gets the base class of an an object.\n\nThis is used not just by entities, but also by widgets, panels, drive modes, weapons and gamemodes (with \"gamemode_\" prefix).\n\nThe keyword **DEFINE_BASECLASS** translates into a call to this function. In the engine, it is replaced with:\n\n```\nlocal BaseClass = baseclass.Get\n```",
		"prefix": "baseclass.Get"
	},
	"baseclass.Set": {
		"body": [
			"baseclass.Set(${1:name}, ${2:tab})$0"
		],
		"description": "Add a new base class that can be derived by others. This is done automatically for:\n* widgets\n* panels\n* drive modes\n* entities\n* weapons\n* gamemodes (with prefix \"gamemode_\")",
		"prefix": "baseclass.Set"
	},
	"bit.arshift": {
		"body": [
			"bit.arshift(${1:value}, ${2:shiftCount})$0"
		],
		"description": "Returns the arithmetically shifted value.",
		"prefix": "bit.arshift"
	},
	"bit.band": {
		"body": [
			"bit.band(${1:value}, ${2:otherValues=nil})$0"
		],
		"description": "Performs the bitwise \"and\" for all values specified.",
		"prefix": "bit.band"
	},
	"bit.bnot": {
		"body": [
			"bit.bnot(${1:value})$0"
		],
		"description": "Returns the bitwise not of the value.",
		"prefix": "bit.bnot"
	},
	"bit.bor": {
		"body": [
			"bit.bor(${1:value1}, ${2:...})$0"
		],
		"description": "Returns the bitwise OR of all values specified.",
		"prefix": "bit.bor"
	},
	"bit.bswap": {
		"body": [
			"bit.bswap(${1:value})$0"
		],
		"description": "Swaps the byte order.",
		"prefix": "bit.bswap"
	},
	"bit.bxor": {
		"body": [
			"bit.bxor(${1:value}, ${2:otherValues=nil})$0"
		],
		"description": "Returns the bitwise xor of all values specified.",
		"prefix": "bit.bxor"
	},
	"bit.lshift": {
		"body": [
			"bit.lshift(${1:value}, ${2:shiftCount})$0"
		],
		"description": "Returns the left shifted value.",
		"prefix": "bit.lshift"
	},
	"bit.rol": {
		"body": [
			"bit.rol(${1:value}, ${2:shiftCount})$0"
		],
		"description": "Returns the left rotated value.",
		"prefix": "bit.rol"
	},
	"bit.ror": {
		"body": [
			"bit.ror(${1:value}, ${2:shiftCount})$0"
		],
		"description": "Returns the right rotated value.",
		"prefix": "bit.ror"
	},
	"bit.rshift": {
		"body": [
			"bit.rshift(${1:value}, ${2:shiftCount})$0"
		],
		"description": "Returns the right shifted value.",
		"prefix": "bit.rshift"
	},
	"bit.tobit": {
		"body": [
			"bit.tobit(${1:value})$0"
		],
		"description": "Normalizes the specified value and clamps it in the range of a signed 32bit integer.",
		"prefix": "bit.tobit"
	},
	"bit.tohex": {
		"body": [
			"bit.tohex(${1:value}, ${2:digits=8})$0"
		],
		"description": "Returns the hexadecimal representation of the number with the specified digits.",
		"prefix": "bit.tohex"
	},
	"cam.ApplyShake": {
		"body": [
			"cam.ApplyShake(${1:pos}, ${2:angles}, ${3:factor})$0"
		],
		"description": "Shakes the screen at a certain position.",
		"prefix": "cam.ApplyShake"
	},
	"cam.End": {
		"body": [
			"cam.End()$0"
		],
		"description": "Switches the renderer back to the previous drawing mode from a 3D context.\n\nThis function is an alias of cam.End3D.\n\nThis will crash the game if there is no context to end.",
		"prefix": "cam.End"
	},
	"cam.End2D": {
		"body": [
			"cam.End2D()$0"
		],
		"description": "Switches the renderer back to the previous drawing mode from a 2D context.\n\nThis will crash the game if there is no context to end.",
		"prefix": "cam.End2D"
	},
	"cam.End3D": {
		"body": [
			"cam.End3D()$0"
		],
		"description": "Switches the renderer back to the previous drawing mode from a 3D context.\n\nThis will crash the game if there is no context to end.",
		"prefix": "cam.End3D"
	},
	"cam.End3D2D": {
		"body": [
			"cam.End3D2D()$0"
		],
		"description": "Switches the renderer back to the previous drawing mode from a 3D2D context.\n\nThis will crash the game if there is no context to end.",
		"prefix": "cam.End3D2D"
	},
	"cam.EndOrthoView": {
		"body": [
			"cam.EndOrthoView()$0"
		],
		"description": "Switches the renderer back to the previous drawing mode from a 3D orthographic rendering context.",
		"prefix": "cam.EndOrthoView"
	},
	"cam.GetModelMatrix": {
		"body": [
			"cam.GetModelMatrix()$0"
		],
		"description": "Returns the currently active model matrix.\nDoes this actually mean the matrix on top of the stack? Probably",
		"prefix": "cam.GetModelMatrix"
	},
	"cam.IgnoreZ": {
		"body": [
			"cam.IgnoreZ(${1:ignoreZ})$0"
		],
		"description": "Tells the renderer to ignore the depth buffer and draw any upcoming operation \"ontop\" of everything that was drawn yet.",
		"prefix": "cam.IgnoreZ"
	},
	"cam.PopModelMatrix": {
		"body": [
			"cam.PopModelMatrix()$0"
		],
		"description": "Pops the current active rendering matrix from the stack and reinstates the previous one.",
		"prefix": "cam.PopModelMatrix"
	},
	"cam.PushModelMatrix": {
		"body": [
			"cam.PushModelMatrix(${1:matrix}, ${2:multiply=false})$0"
		],
		"description": "Pushes the specified matrix onto the render matrix stack. Unlike opengl, this will replace the current model matrix.\n\nThis does not work with cam.Start3D2D if `multiply` is false.",
		"prefix": "cam.PushModelMatrix"
	},
	"cam.Start": {
		"body": [
			"cam.Start(${1:dataTbl})$0"
		],
		"description": "Sets up a new rendering context. This is an extended version of cam.Start3D and cam.Start2D. Must be finished by cam.End3D or cam.End2D.\n\nThis will not update current view properties for 3D contexts.",
		"prefix": "cam.Start"
	},
	"cam.Start2D": {
		"body": [
			"cam.Start2D()$0"
		],
		"description": "Sets up a new 2D rendering context. Must be finished by cam.End2D.\n\nThis is almost always used with a render target from the render. To set its position use render.SetViewPort with a target already stored.\n\nThis will put an identity matrix at the top of the model matrix stack. If you are trying to use cam.PushModelMatrix, call it after this function and not before.\n",
		"prefix": "cam.Start2D"
	},
	"cam.Start3D": {
		"body": [
			"cam.Start3D(${1:pos=EyePos()}, ${2:angles=EyeAngles()}, ${3:fov=nil}, ${4:x=0}, ${5:y=0}, ${6:w=ScrW()}, ${7:h=ScrH()}, ${8:zNear=nil}, ${9:zFar=nil})$0"
		],
		"description": "Sets up a new 3D rendering context. Must be finished by cam.End3D.\n\nFor more advanced settings such as an orthographic view, use cam.Start instead.\n\n\nBoth zNear and zFar need a value before any of them work.\n\nzNear also requires a value higher than 0.\n\nNegative x/y values won't work.\n\nThis will not update current view properties.",
		"prefix": "cam.Start3D"
	},
	"cam.Start3D2D": {
		"body": [
			"cam.Start3D2D(${1:pos}, ${2:angles}, ${3:scale})$0"
		],
		"description": "Sets up a new 2D rendering context. Must be finished by cam.End3D2D. This function pushes a new matrix onto the stack. (cam.PushModelMatrix)\n\nMatrix formula:\n```\nlocal m = Matrix()\nm:SetAngles(angles)\nm:SetTranslation(pos)\nm:SetScale(Vector(scale, -scale, 1))\n```\n\n\n\nThis should be closed by cam.End3D2D otherwise the game crashes",
		"prefix": "cam.Start3D2D"
	},
	"cam.StartOrthoView": {
		"body": [
			"cam.StartOrthoView(${1:leftOffset}, ${2:topOffset}, ${3:rightOffset}, ${4:bottomOffset})$0"
		],
		"description": "Sets up a new 3d context using orthographic projection.",
		"prefix": "cam.StartOrthoView"
	},
	"chat.AddText": {
		"body": [
			"chat.AddText(${1:arguments})$0"
		],
		"description": "Adds text to the local player's chat box (which only they can read).",
		"prefix": "chat.AddText"
	},
	"chat.Close": {
		"body": [
			"chat.Close()$0"
		],
		"description": "Closes the chat window.",
		"prefix": "chat.Close"
	},
	"chat.GetChatBoxPos": {
		"body": [
			"chat.GetChatBoxPos()$0"
		],
		"description": "Returns the chatbox position.",
		"prefix": "chat.GetChatBoxPos"
	},
	"chat.GetChatBoxSize": {
		"body": [
			"chat.GetChatBoxSize()$0"
		],
		"description": "Returns the chatbox size.",
		"prefix": "chat.GetChatBoxSize"
	},
	"chat.Open": {
		"body": [
			"chat.Open(${1:mode})$0"
		],
		"description": "Opens the chat window.",
		"prefix": "chat.Open"
	},
	"chat.PlaySound": {
		"body": [
			"chat.PlaySound()$0"
		],
		"description": "Plays the chat \"tick\" sound.",
		"prefix": "chat.PlaySound"
	},
	"cleanup.Add": {
		"body": [
			"cleanup.Add(${1:pl}, ${2:type}, ${3:ent})$0"
		],
		"description": "Adds an entity to a player's cleanup list.",
		"prefix": "cleanup.Add"
	},
	"cleanup.CC_AdminCleanup": {
		"body": [
			"cleanup.CC_AdminCleanup(${1:pl}, ${2:command}, ${3:args})$0"
		],
		"description": " Called by the `gmod_admin_cleanup` console command. Allows admins to clean up the server.",
		"prefix": "cleanup.CC_AdminCleanup"
	},
	"cleanup.CC_Cleanup": {
		"body": [
			"cleanup.CC_Cleanup(${1:pl}, ${2:command}, ${3:args})$0"
		],
		"description": " Called by the `gmod_cleanup` console command. Allows players to cleanup their own props.",
		"prefix": "cleanup.CC_Cleanup"
	},
	"cleanup.GetList": {
		"body": [
			"cleanup.GetList()$0"
		],
		"description": "Gets the cleanup list.",
		"prefix": "cleanup.GetList"
	},
	"cleanup.GetTable": {
		"body": [
			"cleanup.GetTable()$0"
		],
		"description": "Gets the table of cleanup types.",
		"prefix": "cleanup.GetTable"
	},
	"cleanup.Register": {
		"body": [
			"cleanup.Register(${1:type})$0"
		],
		"description": "Registers a new cleanup type.",
		"prefix": "cleanup.Register"
	},
	"cleanup.ReplaceEntity": {
		"body": [
			"cleanup.ReplaceEntity(${1:from}, ${2:to})$0"
		],
		"description": "Replaces one entity in the cleanup module with another",
		"prefix": "cleanup.ReplaceEntity"
	},
	"cleanup.UpdateUI": {
		"body": [
			"cleanup.UpdateUI()$0"
		],
		"description": "Repopulates the clients cleanup menu",
		"prefix": "cleanup.UpdateUI"
	},
	"concommand.Add": {
		"body": [
			"concommand.Add(${1:name}, ${2:callback}, ${3:autoComplete=nil}, ${4:helpText=nil}, ${5:flags=0})$0"
		],
		"description": "Creates a console command that runs a function in lua with optional autocompletion function and help text.\n\nThis will fail if the concommand was previously removed with concommand.Remove in a different realm (creating a command on the client that was removed from the server and vice-versa).",
		"prefix": "concommand.Add"
	},
	"concommand.AutoComplete": {
		"body": [
			"concommand.AutoComplete(${1:command}, ${2:arguments})$0"
		],
		"description": " Used by the engine to call the autocomplete function for a console command, and retrieve returned options.",
		"prefix": "concommand.AutoComplete"
	},
	"concommand.GetTable": {
		"body": [
			"concommand.GetTable()$0"
		],
		"description": "Returns the tables of all console command callbacks, and autocomplete functions, that were added to the game with concommand.Add.",
		"prefix": "concommand.GetTable"
	},
	"concommand.Remove": {
		"body": [
			"concommand.Remove(${1:name})$0"
		],
		"description": "Removes a console command.\n\nThis will not always remove the command from auto-complete.\nconcommand.Add will fail if the concommand was previously removed with this function in a different realm (creating a command on the client that was removed from the server and vice-versa).",
		"prefix": "concommand.Remove"
	},
	"concommand.Run": {
		"body": [
			"concommand.Run(${1:ply}, ${2:cmd}, ${3:args}, ${4:argumentString})$0"
		],
		"description": "You might be looking for Global.RunConsoleCommand or Player:ConCommand.\n\nUsed by the engine to run a console command's callback function. This will only be called for commands that were added with Global.AddConsoleCommand, which concommand.Add calls internally. An error is sent to the player's chat if no callback is found.\n\nThis will still be called for concommands removed with concommand.Remove but will return false.",
		"prefix": "concommand.Run"
	},
	"constraint.AddConstraintTable": {
		"body": [
			"constraint.AddConstraintTable(${1:ent1}, ${2:constrt}, ${3:ent2=nil}, ${4:ent3=nil}, ${5:ent4=nil})$0"
		],
		"description": "Stores information about constraints in an entity's table.",
		"prefix": "constraint.AddConstraintTable"
	},
	"constraint.AddConstraintTableNoDelete": {
		"body": [
			"constraint.AddConstraintTableNoDelete(${1:ent1}, ${2:constrt}, ${3:ent2=nil}, ${4:ent3=nil}, ${5:ent4=nil})$0"
		],
		"description": "Stores info about the constraints on the entity's table. The only difference between this and constraint.AddConstraintTable is that the constraint does not get deleted when the entity is removed.",
		"prefix": "constraint.AddConstraintTableNoDelete"
	},
	"constraint.AdvBallsocket": {
		"body": [
			"constraint.AdvBallsocket(${1:Ent1}, ${2:Ent2}, ${3:Bone1}, ${4:Bone2}, ${5:LPos1}, ${6:LPos2}, ${7:forcelimit}, ${8:torquelimit}, ${9:xmin}, ${10:ymin}, ${11:zmin}, ${12:xmax}, ${13:ymax}, ${14:zmax}, ${15:xfric}, ${16:yfric}, ${17:zfric}, ${18:onlyrotation}, ${19:nocollide})$0"
		],
		"description": "Creates an advanced ballsocket (ragdoll) constraint.\n\nUses a https://developer.valvesoftware.com/wiki/Phys_ragdollconstraint",
		"prefix": "constraint.AdvBallsocket"
	},
	"constraint.Axis": {
		"body": [
			"constraint.Axis(${1:Ent1}, ${2:Ent2}, ${3:Bone1}, ${4:Bone2}, ${5:LPos1}, ${6:LPos2}, ${7:forcelimit}, ${8:torquelimit}, ${9:friction}, ${10:nocollide}, ${11:LocalAxis}, ${12:DontAddTable})$0"
		],
		"description": "Creates an axis constraint.",
		"prefix": "constraint.Axis"
	},
	"constraint.Ballsocket": {
		"body": [
			"constraint.Ballsocket(${1:Ent1}, ${2:Ent2}, ${3:Bone1}, ${4:Bone2}, ${5:LocalPos}, ${6:forcelimit}, ${7:torquelimit}, ${8:nocollide})$0"
		],
		"description": "Creates a ballsocket joint.",
		"prefix": "constraint.Ballsocket"
	},
	"constraint.CanConstrain": {
		"body": [
			"constraint.CanConstrain(${1:ent}, ${2:bone})$0"
		],
		"description": "Basic checks to make sure that the specified entity and bone are valid. Returns false if we should not be constraining the entity.",
		"prefix": "constraint.CanConstrain"
	},
	"constraint.CreateKeyframeRope": {
		"body": [
			"constraint.CreateKeyframeRope(${1:pos}, ${2:width}, ${3:material}, ${4:Constraint}, ${5:Ent1}, ${6:LPos1}, ${7:Bone1}, ${8:Ent2}, ${9:LPos2}, ${10:Bone2}, ${11:kv})$0"
		],
		"description": "Creates a rope without any constraint.",
		"prefix": "constraint.CreateKeyframeRope"
	},
	"constraint.CreateStaticAnchorPoint": {
		"body": [
			"constraint.CreateStaticAnchorPoint(${1:pos})$0"
		],
		"description": "Creates an invisible, non-moveable anchor point in the world to which things can be attached.",
		"prefix": "constraint.CreateStaticAnchorPoint"
	},
	"constraint.Elastic": {
		"body": [
			"constraint.Elastic(${1:Ent1}, ${2:Ent2}, ${3:Bone1}, ${4:Bone2}, ${5:LPos1}, ${6:LPos2}, ${7:constant}, ${8:damping}, ${9:rdamping}, ${10:material}, ${11:width}, ${12:stretchonly})$0"
		],
		"description": "Creates an elastic constraint.",
		"prefix": "constraint.Elastic"
	},
	"constraint.Find": {
		"body": [
			"constraint.Find(${1:ent1}, ${2:ent2}, ${3:type}, ${4:bone1}, ${5:bone2})$0"
		],
		"description": "Returns the constraint of a specified type between two entities, if it exists",
		"prefix": "constraint.Find"
	},
	"constraint.FindConstraint": {
		"body": [
			"constraint.FindConstraint(${1:ent}, ${2:type})$0"
		],
		"description": "Returns the first constraint of a specific type directly connected to the entity found",
		"prefix": "constraint.FindConstraint"
	},
	"constraint.FindConstraintEntity": {
		"body": [
			"constraint.FindConstraintEntity(${1:ent}, ${2:type})$0"
		],
		"description": "Returns the other entity involved in the first constraint of a specific type directly connected to the entity",
		"prefix": "constraint.FindConstraintEntity"
	},
	"constraint.FindConstraints": {
		"body": [
			"constraint.FindConstraints(${1:ent}, ${2:type})$0"
		],
		"description": "Returns a table of all constraints of a specific type directly connected to the entity",
		"prefix": "constraint.FindConstraints"
	},
	"constraint.ForgetConstraints": {
		"body": [
			"constraint.ForgetConstraints(${1:ent})$0"
		],
		"description": "Make this entity forget any constraints it knows about. Note that this will not actually remove the constraints.",
		"prefix": "constraint.ForgetConstraints"
	},
	"constraint.GetAllConstrainedEntities": {
		"body": [
			"constraint.GetAllConstrainedEntities(${1:ent}, ${2:ResultTable=nil})$0"
		],
		"description": "Returns a table of all entities recursively constrained to an entitiy.",
		"prefix": "constraint.GetAllConstrainedEntities"
	},
	"constraint.GetTable": {
		"body": [
			"constraint.GetTable(${1:ent})$0"
		],
		"description": "Returns a table of all constraints directly connected to the entity",
		"prefix": "constraint.GetTable"
	},
	"constraint.HasConstraints": {
		"body": [
			"constraint.HasConstraints(${1:ent})$0"
		],
		"description": "Returns true if the entity has constraints attached to it",
		"prefix": "constraint.HasConstraints"
	},
	"constraint.Hydraulic": {
		"body": [
			"constraint.Hydraulic(${1:pl}, ${2:Ent1}, ${3:Ent2}, ${4:Bone1}, ${5:Bone2}, ${6:LPos1}, ${7:LPos2}, ${8:Length1}, ${9:Length2}, ${10:width}, ${11:key}, ${12:fixed}, ${13:speed}, ${14:material})$0"
		],
		"description": "Creates a Hydraulic constraint.",
		"prefix": "constraint.Hydraulic"
	},
	"constraint.Keepupright": {
		"body": [
			"constraint.Keepupright(${1:ent}, ${2:ang}, ${3:bone}, ${4:angularLimit})$0"
		],
		"description": "Creates a keep upright constraint.\n\nThis function only works on prop_physics or prop_ragdoll.",
		"prefix": "constraint.Keepupright"
	},
	"constraint.Motor": {
		"body": [
			"constraint.Motor(${1:Ent1}, ${2:Ent2}, ${3:Bone1}, ${4:Bone2}, ${5:LPos1}, ${6:LPos2}, ${7:friction}, ${8:torque}, ${9:forcetime}, ${10:nocollide}, ${11:toggle}, ${12:pl}, ${13:forcelimit}, ${14:numpadkey_fwd}, ${15:numpadkey_bwd}, ${16:direction}, ${17:LocalAxis})$0"
		],
		"description": "Creates a motor constraint.",
		"prefix": "constraint.Motor"
	},
	"constraint.Muscle": {
		"body": [
			"constraint.Muscle(${1:pl}, ${2:Ent1}, ${3:Ent2}, ${4:Bone1}, ${5:Bone2}, ${6:LPos1}, ${7:LPos2}, ${8:Length1}, ${9:Length2}, ${10:width}, ${11:key}, ${12:fixed}, ${13:period}, ${14:amplitude}, ${15:starton}, ${16:material})$0"
		],
		"description": "Creates a muscle constraint.",
		"prefix": "constraint.Muscle"
	},
	"constraint.NoCollide": {
		"body": [
			"constraint.NoCollide(${1:Ent1}, ${2:Ent2}, ${3:Bone1}, ${4:Bone2})$0"
		],
		"description": "Creates an no-collide \"constraint\". Disables collision between two entities.\nDoes not work with players.",
		"prefix": "constraint.NoCollide"
	},
	"constraint.Pulley": {
		"body": [
			"constraint.Pulley(${1:Ent1}, ${2:Ent4}, ${3:Bone1}, ${4:Bone4}, ${5:LPos1}, ${6:LPos4}, ${7:WPos2}, ${8:WPos3}, ${9:forcelimit}, ${10:rigid}, ${11:width}, ${12:material})$0"
		],
		"description": "Creates a pulley constraint.",
		"prefix": "constraint.Pulley"
	},
	"constraint.RemoveAll": {
		"body": [
			"constraint.RemoveAll(${1:ent})$0"
		],
		"description": "Attempts to remove all constraints associated with an entity",
		"prefix": "constraint.RemoveAll"
	},
	"constraint.RemoveConstraints": {
		"body": [
			"constraint.RemoveConstraints(${1:ent}, ${2:type})$0"
		],
		"description": "Attempts to remove all constraints of a specified type associated with an entity",
		"prefix": "constraint.RemoveConstraints"
	},
	"constraint.Rope": {
		"body": [
			"constraint.Rope(${1:Ent1}, ${2:Ent2}, ${3:Bone1}, ${4:Bone2}, ${5:LPos1}, ${6:LPos2}, ${7:length}, ${8:addlength}, ${9:forcelimit}, ${10:width}, ${11:material}, ${12:rigid})$0"
		],
		"description": "Creates a rope constraint - with rope!",
		"prefix": "constraint.Rope"
	},
	"constraint.Slider": {
		"body": [
			"constraint.Slider(${1:Ent1}, ${2:Ent2}, ${3:Bone1}, ${4:Bone2}, ${5:LPos1}, ${6:LPos2}, ${7:width}, ${8:material})$0"
		],
		"description": "Creates a slider constraint.",
		"prefix": "constraint.Slider"
	},
	"constraint.Weld": {
		"body": [
			"constraint.Weld(${1:ent1}, ${2:ent2}, ${3:bone1}, ${4:bone2}, ${5:forcelimit}, ${6:nocollide}, ${7:deleteent1onbreak})$0"
		],
		"description": "Creates a weld constraint",
		"prefix": "constraint.Weld"
	},
	"constraint.Winch": {
		"body": [
			"constraint.Winch(${1:pl}, ${2:Ent1}, ${3:Ent2}, ${4:Bone1}, ${5:Bone2}, ${6:LPos1}, ${7:LPos2}, ${8:width}, ${9:fwd_bind}, ${10:bwd_bind}, ${11:fwd_speed}, ${12:bwd_speed}, ${13:material}, ${14:toggle})$0"
		],
		"description": "Creates a Winch constraint.",
		"prefix": "constraint.Winch"
	},
	"construct.Magnet": {
		"body": [
			"construct.Magnet(${1:ply}, ${2:pos}, ${3:ang}, ${4:model}, ${5:material}, ${6:key}, ${7:maxObjects}, ${8:strength}, ${9:nopull=0}, ${10:allowrot=0}, ${11:startOn=0}, ${12:toggle}, ${13:vel=Vector( 0, 0, 0 )}, ${14:aVel=Angle( 0, 0, 0 )}, ${15:frozen=false})$0"
		],
		"description": "Creates a magnet.",
		"prefix": "construct.Magnet"
	},
	"construct.SetPhysProp": {
		"body": [
			"construct.SetPhysProp(${1:ply}, ${2:ent}, ${3:physObjID}, ${4:physObj}, ${5:data})$0"
		],
		"description": "Sets props physical properties.",
		"prefix": "construct.SetPhysProp"
	},
	"controlpanel.Clear": {
		"body": [
			"controlpanel.Clear()$0"
		],
		"description": "Clears ALL the control panels ( for tools )",
		"prefix": "controlpanel.Clear"
	},
	"controlpanel.Get": {
		"body": [
			"controlpanel.Get(${1:name})$0"
		],
		"description": "Returns (or creates if not exists) a controlpanel.",
		"prefix": "controlpanel.Get"
	},
	"cookie.Delete": {
		"body": [
			"cookie.Delete(${1:name})$0"
		],
		"description": "Deletes a cookie on the client.",
		"prefix": "cookie.Delete"
	},
	"cookie.GetNumber": {
		"body": [
			"cookie.GetNumber(${1:name}, ${2:default=nil})$0"
		],
		"description": "Gets the value of a cookie on the client as a number.",
		"prefix": "cookie.GetNumber"
	},
	"cookie.GetString": {
		"body": [
			"cookie.GetString(${1:name}, ${2:default=nil})$0"
		],
		"description": "Gets the value of a cookie on the client as a string.",
		"prefix": "cookie.GetString"
	},
	"cookie.Set": {
		"body": [
			"cookie.Set(${1:key}, ${2:value})$0"
		],
		"description": "Sets the value of a cookie, which is saved automatically by the sql.\n\nThese are stored in the *.db files - cl.db for clients, mn.db for menu state and sv.db for servers.",
		"prefix": "cookie.Set"
	},
	"coroutine.create": {
		"body": [
			"coroutine.create(${1:func})$0"
		],
		"description": "Creates a coroutine of the given function.",
		"prefix": "coroutine.create"
	},
	"coroutine.resume": {
		"body": [
			"coroutine.resume(${1:coroutine}, ${2:args})$0"
		],
		"description": "Resumes the given coroutine and passes the given vararg to either the function arguments or the coroutine.yield that is inside that function and returns whatever yield is called with the next time or by the final return in the function.",
		"prefix": "coroutine.resume"
	},
	"coroutine.running": {
		"body": [
			"coroutine.running()$0"
		],
		"description": "Returns the active coroutine or nil if we are not within a coroutine.",
		"prefix": "coroutine.running"
	},
	"coroutine.status": {
		"body": [
			"coroutine.status(${1:coroutine})$0"
		],
		"description": "Returns the status of the coroutine passed to it, the possible statuses are \"suspended\", \"running\", and \"dead\".",
		"prefix": "coroutine.status"
	},
	"coroutine.wait": {
		"body": [
			"coroutine.wait(${1:duration})$0"
		],
		"description": "Yields the coroutine for the given duration before continuing.\n\nThis only works inside a coroutine.\n\nThis function uses Global.CurTime instead of Global.RealTime.",
		"prefix": "coroutine.wait"
	},
	"coroutine.wrap": {
		"body": [
			"coroutine.wrap(${1:coroutine})$0"
		],
		"description": "Returns a function which calling is equivalent with calling coroutine.resume with the coroutine and all extra parameters.\n\nThe values returned by the returned function only contain the values passed to the inner coroutine.yield call and do not include the *no error* status that coroutine.resume provides. In case of failure, an error is thrown instead.",
		"prefix": "coroutine.wrap"
	},
	"coroutine.yield": {
		"body": [
			"coroutine.yield(${1:returnValue})$0"
		],
		"description": "Pauses the active coroutine and passes all additional variables to the call of coroutine.resume that resumed the coroutine last time, and returns all additional variables that were passed to the previous call of resume.",
		"prefix": "coroutine.yield"
	},
	"cvars.AddChangeCallback": {
		"body": [
			"cvars.AddChangeCallback(${1:name}, ${2:callback}, ${3:identifier=nil})$0"
		],
		"description": "Adds a callback to be called when the named convar changes.\n\nThis does not callback convars in the menu state.\nThis does not callback convars on the client with FCVAR_GAMEDLL and convars on the server without FCVAR_GAMEDLL.\nThis does not callback convars on the client with FCVAR_REPLICATED.",
		"prefix": "cvars.AddChangeCallback"
	},
	"cvars.Bool": {
		"body": [
			"cvars.Bool(${1:cvar}, ${2:default=false})$0"
		],
		"description": "Retrieves console variable as a boolean.",
		"prefix": "cvars.Bool"
	},
	"cvars.GetConVarCallbacks": {
		"body": [
			"cvars.GetConVarCallbacks(${1:name}, ${2:createIfNotFound=false})$0"
		],
		"description": "Returns a table of the given ConVars callbacks.",
		"prefix": "cvars.GetConVarCallbacks"
	},
	"cvars.Number": {
		"body": [
			"cvars.Number(${1:cvar}, ${2:default=nil})$0"
		],
		"description": "Retrieves console variable as a number.",
		"prefix": "cvars.Number"
	},
	"cvars.OnConVarChanged": {
		"body": [
			"cvars.OnConVarChanged(${1:name}, ${2:oldVal}, ${3:newVal})$0"
		],
		"description": "You are probably looking for cvars.AddChangeCallback.\n\nCalled by the engine when a convar value changes.",
		"prefix": "cvars.OnConVarChanged"
	},
	"cvars.RemoveChangeCallback": {
		"body": [
			"cvars.RemoveChangeCallback(${1:name}, ${2:indentifier})$0"
		],
		"description": "Removes a callback for a convar using the the callback's identifier. The identifier should be the third argument specified for cvars.AddChangeCallback.",
		"prefix": "cvars.RemoveChangeCallback"
	},
	"cvars.String": {
		"body": [
			"cvars.String(${1:cvar}, ${2:default=nil})$0"
		],
		"description": "Retrieves console variable as a string.",
		"prefix": "cvars.String"
	},
	"debug.Trace": {
		"body": [
			"debug.Trace()$0"
		],
		"description": "Prints out the lua function call stack to the console.",
		"prefix": "debug.Trace"
	},
	"debug.debug": {
		"body": [
			"debug.debug()$0"
		],
		"description": "Enters an interactive mode with the user, running each string that the user enters. Using simple commands and other debug facilities, the user can inspect global and local variables, change their values, evaluate expressions, and so on. A line containing only the word cont finishes this function, so that the caller continues its execution.\n\n* Commands for debug.debug are not lexically nested within any function, and so have no direct access to local variables.\n* This only works on the source dedicated server.\n* To exit this interactive mode, you can press Ctrl + Z then Enter OR type the word 'cont' on a single line and press enter.",
		"prefix": "debug.debug"
	},
	"debug.getfenv": {
		"body": [
			"debug.getfenv(${1:object})$0"
		],
		"description": "Returns the environment of the passed object. This can be set with debug.setfenv",
		"prefix": "debug.getfenv"
	},
	"debug.gethook": {
		"body": [
			"debug.gethook(${1:thread=nil})$0"
		],
		"description": "Returns the current hook settings of the passed thread. The thread argument can be omitted. This is unrelated to . More information on hooks can be found at http://www.lua.org/pil/23.2.html",
		"prefix": "debug.gethook"
	},
	"debug.getinfo": {
		"body": [
			"debug.getinfo(${1:funcOrStackLevel}, ${2:fields=flnSu})$0"
		],
		"description": "Returns debug information about a function.",
		"prefix": "debug.getinfo"
	},
	"debug.getlocal": {
		"body": [
			"debug.getlocal(${1:thread=Current thread}, ${2:level}, ${3:index})$0"
		],
		"description": "Gets the name and value of a local variable indexed from the level.\nWhen a function has a tailcall return, you cannot access the locals of this function.",
		"prefix": "debug.getlocal"
	},
	"debug.getmetatable": {
		"body": [
			"debug.getmetatable(${1:object})$0"
		],
		"description": "Returns the metatable of an object. This function ignores the metatable's __metatable field.",
		"prefix": "debug.getmetatable"
	},
	"debug.getregistry": {
		"body": [
			"debug.getregistry()$0"
		],
		"description": "Returns the internal Lua registry table.\n\nThe Lua registry is used by the engine and binary modules to create references to Lua values. Avoid creating entries into the registry with a number as the key, as they are reserved for the reference system.\n\nImproper editing of the registry can result in unintended side effects, including crashing of the game.",
		"prefix": "debug.getregistry"
	},
	"debug.getupvalue": {
		"body": [
			"debug.getupvalue(${1:func}, ${2:index})$0"
		],
		"description": "Used for getting variable values in an index from the passed function. This does nothing for C functions.",
		"prefix": "debug.getupvalue"
	},
	"debug.setfenv": {
		"body": [
			"debug.setfenv(${1:object}, ${2:env})$0"
		],
		"description": "Sets the environment of the passed object.",
		"prefix": "debug.setfenv"
	},
	"debug.sethook": {
		"body": [
			"debug.sethook(${1:thread}, ${2:hook}, ${3:mask}, ${4:count})$0"
		],
		"description": "Sets the given function as a Lua hook. This is completely different to gamemode hooks. The thread argument can be completely omitted and calling this function with no arguments will remove the current hook. This is used by default for infinite loop detection. More information on hooks can be found at http://www.lua.org/pil/23.2.html\n\nHooks are not always ran when code that has been compiled by LuaJIT's JIT compiler is being executed. This means that relying on them for infinite loop protection is unwise.",
		"prefix": "debug.sethook"
	},
	"debug.setlocal": {
		"body": [
			"debug.setlocal(${1:thread=Current Thread}, ${2:level}, ${3:index}, ${4:value=nil})$0"
		],
		"description": "This function was removed due to security concerns.\n\nSets a local variable's value.",
		"prefix": "debug.setlocal"
	},
	"debug.setmetatable": {
		"body": [
			"debug.setmetatable(${1:object}, ${2:metatable})$0"
		],
		"description": "Sets the object's metatable. Unlike Global.setmetatable, this function works regardless of whether the first object passed is a valid table or not; this function even works on primitive datatypes such as numbers, functions, and even nil.",
		"prefix": "debug.setmetatable"
	},
	"debug.setupvalue": {
		"body": [
			"debug.setupvalue(${1:func}, ${2:index}, ${3:val=nil})$0"
		],
		"description": "This function was removed due to security concerns.\n\nSets the variable indexed from func",
		"prefix": "debug.setupvalue"
	},
	"debug.traceback": {
		"body": [
			"debug.traceback(${1:thread=current thread}, ${2:level=1}, ${3:message=nil})$0"
		],
		"description": "Returns a full execution stack trace.",
		"prefix": "debug.traceback"
	},
	"debug.upvalueid": {
		"body": [
			"debug.upvalueid(${1:func}, ${2:index})$0"
		],
		"description": "This function was removed due to security concerns.\n\nReturns an unique identifier for the upvalue indexed from func",
		"prefix": "debug.upvalueid"
	},
	"debug.upvaluejoin": {
		"body": [
			"debug.upvaluejoin(${1:f1}, ${2:n1}, ${3:f2}, ${4:n2})$0"
		],
		"description": "This function was removed due to security concerns.\n\nMake the n1-th upvalue of the Lua closure f1 refer to the n2-th upvalue of the Lua closure f2.",
		"prefix": "debug.upvaluejoin"
	},
	"debugoverlay.Axis": {
		"body": [
			"debugoverlay.Axis(${1:origin}, ${2:ang}, ${3:size}, ${4:lifetime=1}, ${5:ignoreZ=false})$0"
		],
		"description": "Displays an axis indicator at the specified position.\n\nThis function will silently fail if the **developer** ConVar is set to 0",
		"prefix": "debugoverlay.Axis"
	},
	"debugoverlay.Box": {
		"body": [
			"debugoverlay.Box(${1:origin}, ${2:mins}, ${3:maxs}, ${4:lifetime=1}, ${5:color=Color( 255, 255, 255 )})$0"
		],
		"description": "Displays a solid coloured box at the specified position.\n\nThis function will silently fail if the **developer** ConVar is set to 0.",
		"prefix": "debugoverlay.Box"
	},
	"debugoverlay.BoxAngles": {
		"body": [
			"debugoverlay.BoxAngles(${1:pos}, ${2:mins}, ${3:maxs}, ${4:ang}, ${5:lifetime=1}, ${6:color=Color( 255, 255, 255 )})$0"
		],
		"description": "Displays a solid colored rotated box at the specified position.\n\nThis function will silently fail if the **developer** ConVar is set to 0.",
		"prefix": "debugoverlay.BoxAngles"
	},
	"debugoverlay.Cross": {
		"body": [
			"debugoverlay.Cross(${1:position}, ${2:size}, ${3:lifetime=1}, ${4:color=Color( 255, 255, 255 )}, ${5:ignoreZ=false})$0"
		],
		"description": "Creates a coloured cross at the specified position for the specified time.\n\nThis function will silently fail if the **developer** ConVar is set to 0.",
		"prefix": "debugoverlay.Cross"
	},
	"debugoverlay.EntityTextAtPosition": {
		"body": [
			"debugoverlay.EntityTextAtPosition(${1:pos}, ${2:line}, ${3:text}, ${4:lifetime=1}, ${5:color=Color( 255, 255, 255 )})$0"
		],
		"description": "Displays 2D text at the specified coordinates.\n\nThis function will silently fail if the **developer** ConVar is set to 0.",
		"prefix": "debugoverlay.EntityTextAtPosition"
	},
	"debugoverlay.Grid": {
		"body": [
			"debugoverlay.Grid(${1:position})$0"
		],
		"description": "Draws a 3D grid of limited size in given position.\n\nThis function will silently fail if the **developer** ConVar is set to 0.",
		"prefix": "debugoverlay.Grid"
	},
	"debugoverlay.Line": {
		"body": [
			"debugoverlay.Line(${1:pos1}, ${2:pos2}, ${3:lifetime=1}, ${4:color=Color( 255, 255, 255 )}, ${5:ignoreZ=false})$0"
		],
		"description": "Displays a coloured line at the specified position.\n\nThis function will silently fail if the **developer** ConVar is set to 0.",
		"prefix": "debugoverlay.Line"
	},
	"debugoverlay.ScreenText": {
		"body": [
			"debugoverlay.ScreenText(${1:x}, ${2:y}, ${3:text}, ${4:lifetime=1}, ${5:color=Color( 255, 255, 255 )})$0"
		],
		"description": "Displays text triangle at the specified coordinates.\n\nThis function will silently fail if the **developer** ConVar is set to 0.",
		"prefix": "debugoverlay.ScreenText"
	},
	"debugoverlay.Sphere": {
		"body": [
			"debugoverlay.Sphere(${1:origin}, ${2:size}, ${3:lifetime=1}, ${4:color=Color( 255, 255, 255 )}, ${5:ignoreZ=false})$0"
		],
		"description": "Displays a coloured sphere at the specified position.\n\nThis function will silently fail if the **developer** ConVar is set to 0.",
		"prefix": "debugoverlay.Sphere"
	},
	"debugoverlay.SweptBox": {
		"body": [
			"debugoverlay.SweptBox(${1:vStart}, ${2:vEnd}, ${3:vMins}, ${4:vMaxs}, ${5:ang}, ${6:lifetime=1}, ${7:color=Color( 255, 255, 255 )})$0"
		],
		"description": "Displays \"swept\" box, two boxes connected with lines by their verices.\n\nThis function will silently fail if the **developer** ConVar is set to 0.",
		"prefix": "debugoverlay.SweptBox"
	},
	"debugoverlay.Text": {
		"body": [
			"debugoverlay.Text(${1:origin}, ${2:text}, ${3:lifetime=1}, ${4:viewCheck=false})$0"
		],
		"description": "Displays text at the specified position.\n\nThis function will silently fail if the **developer** ConVar is set to 0.",
		"prefix": "debugoverlay.Text"
	},
	"debugoverlay.Triangle": {
		"body": [
			"debugoverlay.Triangle(${1:pos1}, ${2:pos2}, ${3:pos3}, ${4:lifetime=1}, ${5:color=Color( 255, 255, 255 )}, ${6:ignoreZ=false})$0"
		],
		"description": "Displays a colored triangle at the specified coordinates.\n\nThis function will silently fail if the **developer** ConVar is set to 0.",
		"prefix": "debugoverlay.Triangle"
	},
	"derma.Color": {
		"body": [
			"derma.Color(${1:name}, ${2:pnl}, ${3:default})$0"
		],
		"description": "Gets the color from a Derma skin of a panel and returns default color if not found",
		"prefix": "derma.Color"
	},
	"derma.DefineControl": {
		"body": [
			"derma.DefineControl(${1:name}, ${2:description}, ${3:tab}, ${4:base})$0"
		],
		"description": "Defines a new Derma control with an optional base.\n\nThis calls vgui.Register internally, but also does the following:\n* Adds the control to derma.GetControlList\n* Adds a key \"Derma\" - This is returned by derma.GetControlList\n* Makes a global table with the name of the control (This is technically deprecated and should not be relied upon)\n* If reloading (i.e. called this function with name of an existing panel), updates all existing instances of panels with this name. (Updates functions, calls PANEL:PreAutoRefresh and PANEL:PostAutoRefresh, etc.)",
		"prefix": "derma.DefineControl"
	},
	"derma.DefineSkin": {
		"body": [
			"derma.DefineSkin(${1:name}, ${2:descriptions}, ${3:skin})$0"
		],
		"description": "Defines a new skin so that it is usable by Derma. The default skin can be found in `garrysmod/lua/skins/default.lua`",
		"prefix": "derma.DefineSkin"
	},
	"derma.GetControlList": {
		"body": [
			"derma.GetControlList()$0"
		],
		"description": "Returns the derma.Controls table, a list of all derma controls registered with derma.DefineControl.",
		"prefix": "derma.GetControlList"
	},
	"derma.GetDefaultSkin": {
		"body": [
			"derma.GetDefaultSkin()$0"
		],
		"description": "Returns the default skin table, which can be changed with the hook GM:ForceDermaSkin",
		"prefix": "derma.GetDefaultSkin"
	},
	"derma.GetNamedSkin": {
		"body": [
			"derma.GetNamedSkin(${1:name})$0"
		],
		"description": "Returns the skin table of the skin with the supplied name",
		"prefix": "derma.GetNamedSkin"
	},
	"derma.GetSkinTable": {
		"body": [
			"derma.GetSkinTable()$0"
		],
		"description": "Returns a copy of the table containing every Derma skin",
		"prefix": "derma.GetSkinTable"
	},
	"derma.RefreshSkins": {
		"body": [
			"derma.RefreshSkins()$0"
		],
		"description": "Clears all cached panels so that they reassess which skin they should be using.",
		"prefix": "derma.RefreshSkins"
	},
	"derma.SkinChangeIndex": {
		"body": [
			"derma.SkinChangeIndex()$0"
		],
		"description": "Returns how many times derma.RefreshSkins has been called.",
		"prefix": "derma.SkinChangeIndex"
	},
	"derma.SkinHook": {
		"body": [
			"derma.SkinHook(${1:type}, ${2:name}, ${3:panel}, ${4:w}, ${5:h})$0"
		],
		"description": "Calls the specified hook for the given panel",
		"prefix": "derma.SkinHook"
	},
	"derma.SkinTexture": {
		"body": [
			"derma.SkinTexture(${1:name}, ${2:pnl}, ${3:fallback=nil})$0"
		],
		"description": "Returns a function to draw a specified texture of panels skin.",
		"prefix": "derma.SkinTexture"
	},
	"dragndrop.CallReceiverFunction": {
		"body": [
			"dragndrop.CallReceiverFunction(${1:bDoDrop}, ${2:command}, ${3:mx}, ${4:my})$0"
		],
		"description": "\nCalls the receiver function of hovered panel.",
		"prefix": "dragndrop.CallReceiverFunction"
	},
	"dragndrop.Clear": {
		"body": [
			"dragndrop.Clear()$0"
		],
		"description": "Clears all the internal drag'n'drop variables.",
		"prefix": "dragndrop.Clear"
	},
	"dragndrop.Drop": {
		"body": [
			"dragndrop.Drop()$0"
		],
		"description": "Handles the drop action of drag'n'drop library.",
		"prefix": "dragndrop.Drop"
	},
	"dragndrop.GetDroppable": {
		"body": [
			"dragndrop.GetDroppable(${1:name=nil})$0"
		],
		"description": "Returns a table of currently dragged panels.",
		"prefix": "dragndrop.GetDroppable"
	},
	"dragndrop.HandleDroppedInGame": {
		"body": [
			"dragndrop.HandleDroppedInGame()$0"
		],
		"description": "If returns true, calls dragndrop.StopDragging in dragndrop.Drop. Seems to be broken and does nothing. Is it for override?",
		"prefix": "dragndrop.HandleDroppedInGame"
	},
	"dragndrop.HoverThink": {
		"body": [
			"dragndrop.HoverThink()$0"
		],
		"description": "\nHandles the hover think. Called from dragndrop.Think.",
		"prefix": "dragndrop.HoverThink"
	},
	"dragndrop.IsDragging": {
		"body": [
			"dragndrop.IsDragging()$0"
		],
		"description": "Returns whether the user is dragging something with the drag'n'drop system.",
		"prefix": "dragndrop.IsDragging"
	},
	"dragndrop.StartDragging": {
		"body": [
			"dragndrop.StartDragging()$0"
		],
		"description": "\nStarts the drag'n'drop.",
		"prefix": "dragndrop.StartDragging"
	},
	"dragndrop.StopDragging": {
		"body": [
			"dragndrop.StopDragging()$0"
		],
		"description": "Stops the drag'n'drop and calls dragndrop.Clear.",
		"prefix": "dragndrop.StopDragging"
	},
	"dragndrop.Think": {
		"body": [
			"dragndrop.Think()$0"
		],
		"description": "\nHandles all the drag'n'drop processes. Calls dragndrop.UpdateReceiver and dragndrop.HoverThink.",
		"prefix": "dragndrop.Think"
	},
	"dragndrop.UpdateReceiver": {
		"body": [
			"dragndrop.UpdateReceiver()$0"
		],
		"description": "\nUpdates the receiver to drop the panels onto. Called from dragndrop.Think.",
		"prefix": "dragndrop.UpdateReceiver"
	},
	"draw.DrawText": {
		"body": [
			"draw.DrawText(${1:text}, ${2:font=DermaDefault}, ${3:x=0}, ${4:y=0}, ${5:color=Color( 255, 255, 255, 255 )}, ${6:xAlign=TEXT_ALIGN_LEFT})$0"
		],
		"description": "Simple draw text at position, but this will expand newlines and tabs.\n\n\n\nSee also MarkupObject for limited width and markup support.",
		"prefix": "draw.DrawText"
	},
	"draw.GetFontHeight": {
		"body": [
			"draw.GetFontHeight(${1:font})$0"
		],
		"description": "Returns the height of the specified font in pixels. This is equivalent to the height of the character `W`. See surface.GetTextSize.\n\n",
		"prefix": "draw.GetFontHeight"
	},
	"draw.NoTexture": {
		"body": [
			"draw.NoTexture()$0"
		],
		"description": "Sets drawing texture to a default white texture (vgui/white) via surface.SetMaterial. Useful for resetting the drawing texture.\n\n",
		"prefix": "draw.NoTexture"
	},
	"draw.RoundedBox": {
		"body": [
			"draw.RoundedBox(${1:cornerRadius}, ${2:x}, ${3:y}, ${4:width}, ${5:height}, ${6:color})$0"
		],
		"description": "Draws a rounded rectangle.\nIf you intend to draw a non-rounded rectangle, then it's more efficient to use surface.DrawRect.\n\n",
		"prefix": "draw.RoundedBox"
	},
	"draw.RoundedBoxEx": {
		"body": [
			"draw.RoundedBoxEx(${1:cornerRadius}, ${2:x}, ${3:y}, ${4:width}, ${5:height}, ${6:color}, ${7:roundTopLeft=false}, ${8:roundTopRight=false}, ${9:roundBottomLeft=false}, ${10:roundBottomRight=false})$0"
		],
		"description": "Draws a rounded rectangle. This function also lets you specify which corners are drawn rounded.\n\n",
		"prefix": "draw.RoundedBoxEx"
	},
	"draw.SimpleText": {
		"body": [
			"draw.SimpleText(${1:text}, ${2:font=DermaDefault}, ${3:x=0}, ${4:y=0}, ${5:color=Color( 255, 255, 255, 255 )}, ${6:xAlign=TEXT_ALIGN_LEFT}, ${7:yAlign=TEXT_ALIGN_TOP})$0"
		],
		"description": "Draws text on the screen.\nThis function does not handle newlines properly. See draw.DrawText for a function that does.\n",
		"prefix": "draw.SimpleText"
	},
	"draw.SimpleTextOutlined": {
		"body": [
			"draw.SimpleTextOutlined(${1:Text}, ${2:font=DermaDefault}, ${3:x=0}, ${4:y=0}, ${5:color=Color( 255, 255, 255, 255 )}, ${6:xAlign=TEXT_ALIGN_LEFT}, ${7:yAlign=TEXT_ALIGN_TOP}, ${8:outlinewidth}, ${9:outlinecolor=Color( 255, 255, 255, 255 )})$0"
		],
		"description": "Creates a simple line of text that is outlined.\n\n",
		"prefix": "draw.SimpleTextOutlined"
	},
	"draw.Text": {
		"body": [
			"draw.Text(${1:textdata})$0"
		],
		"description": "Works like draw.SimpleText but uses a table structure instead.\n\n",
		"prefix": "draw.Text"
	},
	"draw.TextShadow": {
		"body": [
			"draw.TextShadow(${1:textdata}, ${2:distance}, ${3:alpha=200})$0"
		],
		"description": "Works like draw.Text, but draws the text as a shadow.\n\n",
		"prefix": "draw.TextShadow"
	},
	"draw.TexturedQuad": {
		"body": [
			"draw.TexturedQuad(${1:texturedata})$0"
		],
		"description": "Draws a texture with a table structure.\n\n",
		"prefix": "draw.TexturedQuad"
	},
	"draw.WordBox": {
		"body": [
			"draw.WordBox(${1:bordersize}, ${2:x}, ${3:y}, ${4:text}, ${5:font}, ${6:boxcolor}, ${7:textcolor})$0"
		],
		"description": "Draws a rounded box with text in it.\n\n",
		"prefix": "draw.WordBox"
	},
	"drive.CalcView": {
		"body": [
			"drive.CalcView(${1:ply}, ${2:view})$0"
		],
		"description": "\nOptionally alter the view.",
		"prefix": "drive.CalcView"
	},
	"drive.CreateMove": {
		"body": [
			"drive.CreateMove(${1:cmd})$0"
		],
		"description": "\nClientside, the client creates the cmd (usercommand) from their input device (mouse, keyboard) and then it's sent to the server. Restrict view angles here.",
		"prefix": "drive.CreateMove"
	},
	"drive.DestroyMethod": {
		"body": [
			"drive.DestroyMethod(${1:ply})$0"
		],
		"description": "\nDestroys players current driving method.",
		"prefix": "drive.DestroyMethod"
	},
	"drive.End": {
		"body": [
			"drive.End(${1:ply}, ${2:ent})$0"
		],
		"description": "Player has stopped driving the entity.",
		"prefix": "drive.End"
	},
	"drive.FinishMove": {
		"body": [
			"drive.FinishMove(${1:ply}, ${2:mv})$0"
		],
		"description": "\nThe move is finished. Copy mv back into the target.",
		"prefix": "drive.FinishMove"
	},
	"drive.GetMethod": {
		"body": [
			"drive.GetMethod(${1:ply})$0"
		],
		"description": "\nReturns ( or creates if inexistent ) a driving method.",
		"prefix": "drive.GetMethod"
	},
	"drive.Move": {
		"body": [
			"drive.Move(${1:ply}, ${2:mv})$0"
		],
		"description": "\nThe move is executed here.",
		"prefix": "drive.Move"
	},
	"drive.PlayerStartDriving": {
		"body": [
			"drive.PlayerStartDriving(${1:ply}, ${2:ent}, ${3:mode})$0"
		],
		"description": "Starts driving for the player.",
		"prefix": "drive.PlayerStartDriving"
	},
	"drive.PlayerStopDriving": {
		"body": [
			"drive.PlayerStopDriving(${1:ply})$0"
		],
		"description": "Stops the player from driving anything. ( For example a prop in sandbox )",
		"prefix": "drive.PlayerStopDriving"
	},
	"drive.Register": {
		"body": [
			"drive.Register(${1:name}, ${2:data}, ${3:base})$0"
		],
		"description": "Registers a new entity drive.",
		"prefix": "drive.Register"
	},
	"drive.Start": {
		"body": [
			"drive.Start(${1:ply}, ${2:ent})$0"
		],
		"description": "Called when the player first starts driving this entity",
		"prefix": "drive.Start"
	},
	"drive.StartMove": {
		"body": [
			"drive.StartMove(${1:ply}, ${2:mv}, ${3:cmd})$0"
		],
		"description": "\nThe user command is received by the server and then converted into a move. This is also run clientside when in multiplayer, for prediction to work.",
		"prefix": "drive.StartMove"
	},
	"duplicator.Allow": {
		"body": [
			"duplicator.Allow(${1:classname})$0"
		],
		"description": "Allow this entity to be duplicated",
		"prefix": "duplicator.Allow"
	},
	"duplicator.ApplyBoneModifiers": {
		"body": [
			"duplicator.ApplyBoneModifiers(${1:ply}, ${2:ent})$0"
		],
		"description": "Calls every function registered with duplicator.RegisterBoneModifier on each bone the ent has.",
		"prefix": "duplicator.ApplyBoneModifiers"
	},
	"duplicator.ApplyEntityModifiers": {
		"body": [
			"duplicator.ApplyEntityModifiers(${1:ply}, ${2:ent})$0"
		],
		"description": "Calls every function registered with duplicator.RegisterEntityModifier on the entity.",
		"prefix": "duplicator.ApplyEntityModifiers"
	},
	"duplicator.ClearEntityModifier": {
		"body": [
			"duplicator.ClearEntityModifier(${1:ent}, ${2:key})$0"
		],
		"description": "Clears/removes the chosen entity modifier from the entity.",
		"prefix": "duplicator.ClearEntityModifier"
	},
	"duplicator.Copy": {
		"body": [
			"duplicator.Copy(${1:ent}, ${2:tableToAdd={}})$0"
		],
		"description": "Copies the entity, and all of its constraints and entities, then returns them in a table.",
		"prefix": "duplicator.Copy"
	},
	"duplicator.CopyEntTable": {
		"body": [
			"duplicator.CopyEntTable(${1:ent})$0"
		],
		"description": "Returns a table with some entity data that can be used to create a new entity with duplicator.CreateEntityFromTable",
		"prefix": "duplicator.CopyEntTable"
	},
	"duplicator.CopyEnts": {
		"body": [
			"duplicator.CopyEnts(${1:ents})$0"
		],
		"description": "Copies the passed table of entities to save for later.",
		"prefix": "duplicator.CopyEnts"
	},
	"duplicator.CreateConstraintFromTable": {
		"body": [
			"duplicator.CreateConstraintFromTable(${1:constraint}, ${2:entityList})$0"
		],
		"description": " Creates a constraint from a saved/copied constraint table.",
		"prefix": "duplicator.CreateConstraintFromTable"
	},
	"duplicator.CreateEntityFromTable": {
		"body": [
			"duplicator.CreateEntityFromTable(${1:ply}, ${2:entTable})$0"
		],
		"description": "\"Create an entity from a table.\"\n\n\nThis creates an entity using the data in EntTable.\n\n\nIf an entity factory has been registered for the entity's Class, it will be called.\n\n\nOtherwise, duplicator.GenericDuplicatorFunction will be called instead.",
		"prefix": "duplicator.CreateEntityFromTable"
	},
	"duplicator.DoBoneManipulator": {
		"body": [
			"duplicator.DoBoneManipulator(${1:ent}, ${2:bones})$0"
		],
		"description": "\"Restores the bone's data.\"\n\n\nLoops through Bones and calls Entity:ManipulateBoneScale, Entity:ManipulateBoneAngles and Entity:ManipulateBonePosition on ent with the table keys and the subtable values s, a and p respectively.",
		"prefix": "duplicator.DoBoneManipulator"
	},
	"duplicator.DoFlex": {
		"body": [
			"duplicator.DoFlex(${1:ent}, ${2:flex}, ${3:scale=nil})$0"
		],
		"description": "Restores the flex data using Entity:SetFlexWeight and Entity:SetFlexScale",
		"prefix": "duplicator.DoFlex"
	},
	"duplicator.DoGeneric": {
		"body": [
			"duplicator.DoGeneric(${1:ent}, ${2:data})$0"
		],
		"description": "\"Applies generic every-day entity stuff for ent from table data.\"\n\n\nDepending on the values of Model, Angle, Pos, Skin, Flex, Bonemanip, ModelScale, ColGroup, Name, and BodyG (table of multiple values) in the data table, this calls Entity:SetModel, Entity:SetAngles, Entity:SetPos, Entity:SetSkin, duplicator.DoFlex, duplicator.DoBoneManipulator, Entity:SetModelScale, Entity:SetCollisionGroup, Entity:SetName, Entity:SetBodygroup on ent.\n\n\nIf ent has a RestoreNetworkVars function, it is called with data.DT.",
		"prefix": "duplicator.DoGeneric"
	},
	"duplicator.DoGenericPhysics": {
		"body": [
			"duplicator.DoGenericPhysics(${1:ent}, ${2:ply=nil}, ${3:data})$0"
		],
		"description": "\"Applies bone data, generically.\"\n\n\nIf data contains a PhysicsObjects table, it moves, re-angles and if relevent freezes all specified bones, first converting from local coordinates to world coordinates.",
		"prefix": "duplicator.DoGenericPhysics"
	},
	"duplicator.FindEntityClass": {
		"body": [
			"duplicator.FindEntityClass(${1:name})$0"
		],
		"description": "Returns the entity class factory registered with duplicator.RegisterEntityClass.",
		"prefix": "duplicator.FindEntityClass"
	},
	"duplicator.GenericDuplicatorFunction": {
		"body": [
			"duplicator.GenericDuplicatorFunction(${1:ply}, ${2:data})$0"
		],
		"description": "\"Generic function for duplicating stuff\"\n\n\nThis is called when duplicator.CreateEntityFromTable can't find an entity factory to build with. It calls duplicator.DoGeneric and duplicator.DoGenericPhysics to apply standard duplicator stored things such as the model and position.",
		"prefix": "duplicator.GenericDuplicatorFunction"
	},
	"duplicator.GetAllConstrainedEntitiesAndConstraints": {
		"body": [
			"duplicator.GetAllConstrainedEntitiesAndConstraints(${1:ent}, ${2:entStorageTable}, ${3:constraintStorageTable})$0"
		],
		"description": " Fills entStorageTable with all of the entities in a group connected with constraints. Fills constraintStorageTable with all of the constrains constraining the group.",
		"prefix": "duplicator.GetAllConstrainedEntitiesAndConstraints"
	},
	"duplicator.IsAllowed": {
		"body": [
			"duplicator.IsAllowed(${1:classname})$0"
		],
		"description": "Returns whether the entity can be duplicated or not",
		"prefix": "duplicator.IsAllowed"
	},
	"duplicator.Paste": {
		"body": [
			"duplicator.Paste(${1:Player}, ${2:EntityList}, ${3:ConstraintList})$0"
		],
		"description": "\"Given entity list and constraint list, create all entities and return their tables\"\n\nCalls duplicator.CreateEntityFromTable on each sub-table of EntityList. If an entity is actually created, it calls ENTITY:OnDuplicated with the entity's duplicator data, then duplicator.ApplyEntityModifiers, duplicator.ApplyBoneModifiers and finally  ENTITY:PostEntityPaste is called.\n\nThe constraints are then created with duplicator.CreateConstraintFromTable.",
		"prefix": "duplicator.Paste"
	},
	"duplicator.RegisterBoneModifier": {
		"body": [
			"duplicator.RegisterBoneModifier(${1:key}, ${2:boneModifier})$0"
		],
		"description": "Registers a function to be called on each of an entity's bones when duplicator.ApplyBoneModifiers is called.\n\nThis function is available to call on the client, but registered functions aren't used anywhere!",
		"prefix": "duplicator.RegisterBoneModifier"
	},
	"duplicator.RegisterConstraint": {
		"body": [
			"duplicator.RegisterConstraint(${1:name}, ${2:callback}, ${3:...})$0"
		],
		"description": "Register a function used for creating a duplicated constraint.",
		"prefix": "duplicator.RegisterConstraint"
	},
	"duplicator.RegisterEntityClass": {
		"body": [
			"duplicator.RegisterEntityClass(${1:name}, ${2:function}, ${3:args})$0"
		],
		"description": "This allows you to specify a specific function to be run when your SENT is pasted with the duplicator, instead of relying on the generic automatic functions.\n\nAutomatically calls duplicator.Allow for the entity class.",
		"prefix": "duplicator.RegisterEntityClass"
	},
	"duplicator.RegisterEntityModifier": {
		"body": [
			"duplicator.RegisterEntityModifier(${1:name}, ${2:func})$0"
		],
		"description": "This allows you to register tweaks to entities. For instance, if you were making an \"unbreakable\" addon, you would use this to enable saving the \"unbreakable\" state of entities between duplications.\n\nThis function registers a piece of generic code that is run on all entities with this modifier. In order to have it actually run, use duplicator.StoreEntityModifier.\n\nThis function does nothing when run clientside.",
		"prefix": "duplicator.RegisterEntityModifier"
	},
	"duplicator.RemoveMapCreatedEntities": {
		"body": [
			"duplicator.RemoveMapCreatedEntities()$0"
		],
		"description": "Help to remove certain map created entities before creating the saved entities\nThis is obviously so we don't get duplicate props everywhere.\nIt should be called before calling Paste.",
		"prefix": "duplicator.RemoveMapCreatedEntities"
	},
	"duplicator.SetLocalAng": {
		"body": [
			"duplicator.SetLocalAng(${1:v})$0"
		],
		"description": "\"When a copy is copied it will be translated according to these.\nIf you set them - make sure to set them back to 0 0 0!\"",
		"prefix": "duplicator.SetLocalAng"
	},
	"duplicator.SetLocalPos": {
		"body": [
			"duplicator.SetLocalPos(${1:v})$0"
		],
		"description": "\"When a copy is copied it will be translated according to these.\nIf you set them - make sure to set them back to 0 0 0!\"",
		"prefix": "duplicator.SetLocalPos"
	},
	"duplicator.StoreBoneModifier": {
		"body": [
			"duplicator.StoreBoneModifier(${1:ent}, ${2:boneID}, ${3:key}, ${4:data})$0"
		],
		"description": "Stores bone mod data for a registered bone modification function",
		"prefix": "duplicator.StoreBoneModifier"
	},
	"duplicator.StoreEntityModifier": {
		"body": [
			"duplicator.StoreEntityModifier(${1:entity}, ${2:name}, ${3:data})$0"
		],
		"description": "Stores an entity modifier into an entity for saving",
		"prefix": "duplicator.StoreEntityModifier"
	},
	"duplicator.WorkoutSize": {
		"body": [
			"duplicator.WorkoutSize(${1:Ents})$0"
		],
		"description": "\"Work out the AABB size\"",
		"prefix": "duplicator.WorkoutSize"
	},
	"effects.BeamRingPoint": {
		"body": [
			"effects.BeamRingPoint(${1:pos}, ${2:lifetime}, ${3:startRad}, ${4:endRad}, ${5:width}, ${6:amplitude}, ${7:color}, ${8:extra})$0"
		],
		"description": "Creates a \"beam ring point\" effect.",
		"prefix": "effects.BeamRingPoint"
	},
	"effects.BubbleTrail": {
		"body": [
			"effects.BubbleTrail(${1:startPos}, ${2:endPos}, ${3:count}, ${4:height}, ${5:speed=0}, ${6:delay=0})$0"
		],
		"description": "Creates a bubble trail effect, the very same you get when shooting underwater.",
		"prefix": "effects.BubbleTrail"
	},
	"effects.Bubbles": {
		"body": [
			"effects.Bubbles(${1:mins}, ${2:maxs}, ${3:count}, ${4:height}, ${5:speed=0}, ${6:delay=0})$0"
		],
		"description": "Creates a bunch of bubbles inside a defined box.",
		"prefix": "effects.Bubbles"
	},
	"effects.Create": {
		"body": [
			"effects.Create(${1:name})$0"
		],
		"description": "You are looking for util.Effect.Returns the table of the effect specified.",
		"prefix": "effects.Create"
	},
	"effects.GetList": {
		"body": [
			"effects.GetList()$0"
		],
		"description": "Returns a list of all Lua-defined effects.",
		"prefix": "effects.GetList"
	},
	"effects.Register": {
		"body": [
			"effects.Register(${1:effect_table}, ${2:name})$0"
		],
		"description": "Registers a new effect.",
		"prefix": "effects.Register"
	},
	"engine.ActiveGamemode": {
		"body": [
			"engine.ActiveGamemode()$0"
		],
		"description": "Returns the name of the currently running gamemode.",
		"prefix": "engine.ActiveGamemode"
	},
	"engine.CloseServer": {
		"body": [
			"engine.CloseServer()$0"
		],
		"description": "Closes the server and completely exits.\n\nThis is only functional when running in server test mode (launch option -systemtest). Server test mode is used internally at Facepunch as part of the build process to make sure that the dedicated servers aren't crashing on startup.",
		"prefix": "engine.CloseServer"
	},
	"engine.GetAddons": {
		"body": [
			"engine.GetAddons()$0"
		],
		"description": "Returns a list of addons the player have subscribed to on the workshop.\n\nThis list will also include \"Floating\" .gma addons that are mounted by the game, but not the folder addons.",
		"prefix": "engine.GetAddons"
	},
	"engine.GetDemoPlaybackStartTick": {
		"body": [
			"engine.GetDemoPlaybackStartTick()$0"
		],
		"description": "When starting playing a demo, engine.GetDemoPlaybackTick will be reset and its old value will be added to this functions return value.",
		"prefix": "engine.GetDemoPlaybackStartTick"
	},
	"engine.GetDemoPlaybackTick": {
		"body": [
			"engine.GetDemoPlaybackTick()$0"
		],
		"description": "Current tick of currently loaded demo.\n\nIf not playing a demo, it will return amount of ticks since last demo playback.",
		"prefix": "engine.GetDemoPlaybackTick"
	},
	"engine.GetDemoPlaybackTimeScale": {
		"body": [
			"engine.GetDemoPlaybackTimeScale()$0"
		],
		"description": "Returns time scale of demo playback.\n\nIf not during demo playback, returns 1.",
		"prefix": "engine.GetDemoPlaybackTimeScale"
	},
	"engine.GetDemoPlaybackTotalTicks": {
		"body": [
			"engine.GetDemoPlaybackTotalTicks()$0"
		],
		"description": "Returns total amount of ticks of currently loaded demo.\n\nIf not playing a demo, returns 0 or the value of last played demo.",
		"prefix": "engine.GetDemoPlaybackTotalTicks"
	},
	"engine.GetGamemodes": {
		"body": [
			"engine.GetGamemodes()$0"
		],
		"description": "Returns a table containing info for all installed gamemodes",
		"prefix": "engine.GetGamemodes"
	},
	"engine.GetGames": {
		"body": [
			"engine.GetGames()$0"
		],
		"description": "Returns an array of tables corresponding to all games from which Garry's Mod supports mounting content.",
		"prefix": "engine.GetGames"
	},
	"engine.GetUserContent": {
		"body": [
			"engine.GetUserContent()$0"
		],
		"description": "Used internally for in-game menus, may be merged in the future into engine.GetAddons.\n\nReturns the UGC (demos, saves and dupes) the player have subscribed to on the workshop.",
		"prefix": "engine.GetUserContent"
	},
	"engine.IsPlayingDemo": {
		"body": [
			"engine.IsPlayingDemo()$0"
		],
		"description": "Returns true if we're currently playing a demo.\n\nYou will notice that there's no server-side version of this. That's because there is no server when playing a demo. Demos are both recorded and played back purely clientside.",
		"prefix": "engine.IsPlayingDemo"
	},
	"engine.IsRecordingDemo": {
		"body": [
			"engine.IsRecordingDemo()$0"
		],
		"description": "Returns true if the game is currently recording a demo file (.dem) using gm_demo",
		"prefix": "engine.IsRecordingDemo"
	},
	"engine.LightStyle": {
		"body": [
			"engine.LightStyle(${1:lightstyle}, ${2:pattern})$0"
		],
		"description": "This is a direct binding to the function `engine->LightStyle`. This function allows you to change the default light style of the map - so you can make lighting lighter or darker. You\u00e2\u20ac\u2122ll need to call render.RedownloadAllLightmaps clientside to refresh the lightmaps to this new color.\n\nCalling this function with arguments 0 and \"a\" will cause dynamic lights such as those produced by the Light tool to stop working.",
		"prefix": "engine.LightStyle"
	},
	"engine.OpenDupe": {
		"body": [
			"engine.OpenDupe(${1:dupeName})$0"
		],
		"description": "Loads a duplication from the local filesystem.",
		"prefix": "engine.OpenDupe"
	},
	"engine.ServerFrameTime": {
		"body": [
			"engine.ServerFrameTime()$0"
		],
		"description": "Returns an estimate of the server's performance. Equivalent to calling Global.FrameTime from the server, according to source code.",
		"prefix": "engine.ServerFrameTime"
	},
	"engine.SetMounted": {
		"body": [
			"engine.SetMounted(${1:depotID}, ${2:doMount})$0"
		],
		"description": "Sets the mounting options for mountable content.",
		"prefix": "engine.SetMounted"
	},
	"engine.TickCount": {
		"body": [
			"engine.TickCount()$0"
		],
		"description": "Returns the number of ticks since the game server started.",
		"prefix": "engine.TickCount"
	},
	"engine.TickInterval": {
		"body": [
			"engine.TickInterval()$0"
		],
		"description": "Returns the number of seconds between each gametick.",
		"prefix": "engine.TickInterval"
	},
	"engine.VideoSettings": {
		"body": [
			"engine.VideoSettings()$0"
		],
		"description": "Returns video recording settings set by video.Record. Used by Demo-To-Video feature.",
		"prefix": "engine.VideoSettings"
	},
	"engine.WriteDupe": {
		"body": [
			"engine.WriteDupe(${1:dupe}, ${2:jpeg})$0"
		],
		"description": "Saves a duplication as a file.",
		"prefix": "engine.WriteDupe"
	},
	"engine.WriteSave": {
		"body": [
			"engine.WriteSave(${1:saveData}, ${2:name}, ${3:time}, ${4:map})$0"
		],
		"description": "Stores savedata into the game (can be loaded using the LoadGame menu)",
		"prefix": "engine.WriteSave"
	},
	"ents.Create": {
		"body": [
			"ents.Create(${1:class})$0"
		],
		"description": "Creates an entity. This function will fail and return `NULL` if the networked-edict limit is hit (around **8176**), or the provided entity class doesn't exist.\n\nDo not use before GM:InitPostEntity has been called, otherwise the server will crash!\nIf you need to perform entity creation when the game starts, create a hook for GM:InitPostEntity and do it there.",
		"prefix": "ents.Create"
	},
	"ents.CreateClientProp": {
		"body": [
			"ents.CreateClientProp(${1:model=models/error.mdl})$0"
		],
		"description": "Creates a clientside only prop. See also Global.ClientsideModel.\n\nFor physics to work you **must** use the _model_ argument, a simple `SetModel` call will not be enough.",
		"prefix": "ents.CreateClientProp"
	},
	"ents.CreateClientside": {
		"body": [
			"ents.CreateClientside(${1:class})$0"
		],
		"description": "Creates a clientside only scripted entity. The scripted entity must be of \"anim\" type.",
		"prefix": "ents.CreateClientside"
	},
	"ents.FindAlongRay": {
		"body": [
			"ents.FindAlongRay(${1:start}, ${2:end}, ${3:mins=nil}, ${4:maxs=nil})$0"
		],
		"description": "Returns a table of all entities along the ray. The ray does not stop on collisions, meaning it will go through walls/entities.",
		"prefix": "ents.FindAlongRay"
	},
	"ents.FindByClass": {
		"body": [
			"ents.FindByClass(${1:class})$0"
		],
		"description": "Gets all entities with the given class, supports wildcards. This works internally by iterating over ents.GetAll. Even if internally ents.GetAll is used, It is faster to use ents.FindByClass than ents.GetAll with a single class comparison.\n\nAsterisks (*) are the only wildcard supported.",
		"prefix": "ents.FindByClass"
	},
	"ents.FindByClassAndParent": {
		"body": [
			"ents.FindByClassAndParent(${1:class}, ${2:parent})$0"
		],
		"description": "Finds all entities that are of given class and are children of given entity. This works internally by iterating over ents.GetAll.",
		"prefix": "ents.FindByClassAndParent"
	},
	"ents.FindByModel": {
		"body": [
			"ents.FindByModel(${1:model})$0"
		],
		"description": "Gets all entities with the given model, supports wildcards. This works internally by iterating over ents.GetAll.\n\nThis currently only supports trailing asterisks (*) for wildcards.",
		"prefix": "ents.FindByModel"
	},
	"ents.FindByName": {
		"body": [
			"ents.FindByName(${1:name})$0"
		],
		"description": "Gets all entities with the given hammer targetname. This works internally by iterating over ents.GetAll.\n\nA player's Name is his nickname, see Player:GetName\n\nDoesn't do anything on client.",
		"prefix": "ents.FindByName"
	},
	"ents.FindInBox": {
		"body": [
			"ents.FindInBox(${1:boxMins}, ${2:boxMaxs})$0"
		],
		"description": "Returns all entities within the specified box.\n\nClientside entities will not be returned by this function.\n\nThere is a limit of 512 entities for the output!",
		"prefix": "ents.FindInBox"
	},
	"ents.FindInCone": {
		"body": [
			"ents.FindInCone(${1:origin}, ${2:normal}, ${3:range}, ${4:angle_cos})$0"
		],
		"description": "\nFinds and returns all entities within the specified cone. Only entities whose Entity:WorldSpaceCenter is within the cone are considered to be in it.\n\nThe \"cone\" is actually a conical \"slice\" of an axis-aligned box (see: ents.FindInBox). The image to the right shows approximately how this function would look in 2D. Due to this, the entity may be farther than the specified range!\n\nClientside entities will not be returned by this function.\n\nIf there are more than 512 entities in the axis-aligned box around the origin, then the result may be incomplete!",
		"prefix": "ents.FindInCone"
	},
	"ents.FindInPVS": {
		"body": [
			"ents.FindInPVS(${1:viewPoint})$0"
		],
		"description": "Finds all entities that lie within a [PVS](https://developer.valvesoftware.com/wiki/PVS).\n\nThe function won't take in to account Global.AddOriginToPVS and the like.",
		"prefix": "ents.FindInPVS"
	},
	"ents.FindInSphere": {
		"body": [
			"ents.FindInSphere(${1:origin}, ${2:radius})$0"
		],
		"description": "Gets all entities within the specified sphere.\n\nClientside entities will not be returned by this function.",
		"prefix": "ents.FindInSphere"
	},
	"ents.FireTargets": {
		"body": [
			"ents.FireTargets(${1:target}, ${2:activator}, ${3:caller}, ${4:usetype}, ${5:value})$0"
		],
		"description": "Fires a use event.",
		"prefix": "ents.FireTargets"
	},
	"ents.GetAll": {
		"body": [
			"ents.GetAll()$0"
		],
		"description": "Returns a table of all existing entities. The table is sequential",
		"prefix": "ents.GetAll"
	},
	"ents.GetByIndex": {
		"body": [
			"ents.GetByIndex(${1:entIdx})$0"
		],
		"description": "Returns an entity by its index. Same as Global.Entity.",
		"prefix": "ents.GetByIndex"
	},
	"ents.GetCount": {
		"body": [
			"ents.GetCount(${1:IncludeKillMe=false})$0"
		],
		"description": "Gives you the amount of currently existing entities.\n\nSimilar to **#**ents.GetAll() but with better performance since the entity table doesn't have to be generated. If ents.GetAll is already being called for iteration, than using the **#** operator on the table will be faster than calling this function since it is JITted.",
		"prefix": "ents.GetCount"
	},
	"ents.GetEdictCount": {
		"body": [
			"ents.GetEdictCount()$0"
		],
		"description": "Returns the amount of networked entities, which is limited to 8192. ents.Create will fail somewhere between 8064 and 8176 - this can vary based on the amount of existing temp ents.",
		"prefix": "ents.GetEdictCount"
	},
	"ents.GetMapCreatedEntity": {
		"body": [
			"ents.GetMapCreatedEntity(${1:id})$0"
		],
		"description": "Returns entity that has given Entity:MapCreationID.",
		"prefix": "ents.GetMapCreatedEntity"
	},
	"file.Append": {
		"body": [
			"file.Append(${1:name}, ${2:content})$0"
		],
		"description": "Appends a file relative to the `data` folder.",
		"prefix": "file.Append"
	},
	"file.CreateDir": {
		"body": [
			"file.CreateDir(${1:name})$0"
		],
		"description": "Creates a directory that is relative to the `data` folder.",
		"prefix": "file.CreateDir"
	},
	"file.Delete": {
		"body": [
			"file.Delete(${1:name})$0"
		],
		"description": "Deletes a file or `empty` folder that is relative to the **data** folder. You can't remove any files outside of **data** folder.",
		"prefix": "file.Delete"
	},
	"file.Exists": {
		"body": [
			"file.Exists(${1:name}, ${2:gamePath})$0"
		],
		"description": "Returns a boolean of whether the file or directory exists or not.\n This will sometimes return false clientside for directories received from the server via a clientside lua file. You can work around this by using file.Find with the path to the directory followed by a wildcard (no trailing forward slash) and see if the directory is inside the returned directories table (**see second example)**.",
		"prefix": "file.Exists"
	},
	"file.Find": {
		"body": [
			"file.Find(${1:name}, ${2:path}, ${3:sorting=nameasc})$0"
		],
		"description": "Returns a list of files and directories inside a single folder.",
		"prefix": "file.Find"
	},
	"file.IsDir": {
		"body": [
			"file.IsDir(${1:fileName}, ${2:gamePath})$0"
		],
		"description": "Returns whether the given file is a directory or not.\n This will sometimes return false clientside for directories received from the server via a clientside lua file. You can work around this by using file.Find with the path to the directory followed by a wildcard (no trailing forward slash) and see if the directory is inside the returned directories table (**see second example)**.",
		"prefix": "file.IsDir"
	},
	"file.Open": {
		"body": [
			"file.Open(${1:fileName}, ${2:fileMode}, ${3:gamePath})$0"
		],
		"description": "Attempts to open a file with the given mode.",
		"prefix": "file.Open"
	},
	"file.Read": {
		"body": [
			"file.Read(${1:fileName}, ${2:gamePath})$0"
		],
		"description": "Returns the content of a file.\n\nBeware of casing -- some filesystems are case-sensitive. SRCDS on Linux seems to force file/directory creation to lowercase, but will not modify read operations.",
		"prefix": "file.Read"
	},
	"file.Rename": {
		"body": [
			"file.Rename(${1:orignalFileName}, ${2:targetFileName})$0"
		],
		"description": "Attempts to rename a file with the given name to another given name.\n\nThis function is constrained to the `data/` folder.",
		"prefix": "file.Rename"
	},
	"file.Size": {
		"body": [
			"file.Size(${1:fileName}, ${2:gamePath})$0"
		],
		"description": "Returns the file's size in bytes. If the file is not found, returns `-1`.",
		"prefix": "file.Size"
	},
	"file.Time": {
		"body": [
			"file.Time(${1:path}, ${2:gamePath})$0"
		],
		"description": "Returns when the file or folder was lasted modified in Unix time.",
		"prefix": "file.Time"
	},
	"file.Write": {
		"body": [
			"file.Write(${1:fileName}, ${2:content})$0"
		],
		"description": "Writes the given string to a file. Erases all previous data in the file. To add data without deleting previous data, use file.Append.",
		"prefix": "file.Write"
	},
	"frame_blend.AddFrame": {
		"body": [
			"frame_blend.AddFrame()$0"
		],
		"description": "\n\nAdds a frame to the blend. Calls frame_blend.CompleteFrame once enough frames have passed since last frame_blend.CompleteFrame call.",
		"prefix": "frame_blend.AddFrame"
	},
	"frame_blend.BlendFrame": {
		"body": [
			"frame_blend.BlendFrame()$0"
		],
		"description": "\n\nBlends the frame(s).",
		"prefix": "frame_blend.BlendFrame"
	},
	"frame_blend.CompleteFrame": {
		"body": [
			"frame_blend.CompleteFrame()$0"
		],
		"description": "\n\nRenders the frame onto internal render target.",
		"prefix": "frame_blend.CompleteFrame"
	},
	"frame_blend.DrawPreview": {
		"body": [
			"frame_blend.DrawPreview()$0"
		],
		"description": "\n\nActually draws the frame blend effect.",
		"prefix": "frame_blend.DrawPreview"
	},
	"frame_blend.IsActive": {
		"body": [
			"frame_blend.IsActive()$0"
		],
		"description": "Returns whether frame blend post processing effect is enabled or not.",
		"prefix": "frame_blend.IsActive"
	},
	"frame_blend.IsLastFrame": {
		"body": [
			"frame_blend.IsLastFrame()$0"
		],
		"description": "\n\n\nReturns whether the current frame is the last frame?",
		"prefix": "frame_blend.IsLastFrame"
	},
	"frame_blend.RenderableFrames": {
		"body": [
			"frame_blend.RenderableFrames()$0"
		],
		"description": "\n\nReturns amount of frames needed to render?",
		"prefix": "frame_blend.RenderableFrames"
	},
	"frame_blend.ShouldSkipFrame": {
		"body": [
			"frame_blend.ShouldSkipFrame()$0"
		],
		"description": "Returns whether we should skip frame or not",
		"prefix": "frame_blend.ShouldSkipFrame"
	},
	"game.AddAmmoType": {
		"body": [
			"game.AddAmmoType(${1:ammoData})$0"
		],
		"description": "Adds a new ammo type to the game.\n\nYou can find a list of default ammo types [here](https://wiki.facepunch.com/gmod/Default_Ammo_Types).\n\nThis function **must** be called on both the client and server in GM:Initialize or you will have unexpected problems.\nThere is a limit of 256 ammo types, including the default ones.",
		"prefix": "game.AddAmmoType"
	},
	"game.AddDecal": {
		"body": [
			"game.AddDecal(${1:decalName}, ${2:materialName})$0"
		],
		"description": "Registers a new decal.\n\nThere's a rather low limit of around 256 for decal materials that may be registered and they are not cleared on map load.",
		"prefix": "game.AddDecal"
	},
	"game.AddParticles": {
		"body": [
			"game.AddParticles(${1:particleFileName})$0"
		],
		"description": "Loads a particle file.\n\nYou will still need to call this function clientside regardless if you create the particle effects serverside.",
		"prefix": "game.AddParticles"
	},
	"game.BuildAmmoTypes": {
		"body": [
			"game.BuildAmmoTypes()$0"
		],
		"description": "Consider using game.GetAmmoTypes and game.GetAmmoData instead.\nCalled by the engine to retrieve the ammo types.",
		"prefix": "game.BuildAmmoTypes"
	},
	"game.CleanUpMap": {
		"body": [
			"game.CleanUpMap(${1:dontSendToClients=false}, ${2:extraFilters={}})$0"
		],
		"description": "If called serverside it will remove **ALL** entities which were not created by the map (not players or weapons held by players).\n\nOn the client it will remove decals, sounds, gibs, dead NPCs, and entities created via ents.CreateClientProp.\n\nThis function calls GM:PreCleanupMap before cleaning up the map and GM:PostCleanupMap after cleaning up the map.\n\nCalling this in a ENTITY:StartTouch or ENTITY:Touch hook will crash the game.\n\nCalling this destroys all BASS streams.\n\nThis can crash when removing _firesmoke entities. **You can use the example below to workaround this issue.**",
		"prefix": "game.CleanUpMap"
	},
	"game.ConsoleCommand": {
		"body": [
			"game.ConsoleCommand(${1:stringCommand})$0"
		],
		"description": "Runs a console command.\nMake sure to add a newline (\"\\n\") at the end of the command.\n\nIf you use data that were received from a client, you should avoid using this function because newline and semicolon (at least) allow the client to run arbitrary commands!\n\nFor safety, you are urged to prefer using Global.RunConsoleCommand in this case.",
		"prefix": "game.ConsoleCommand"
	},
	"game.GetAmmoDamageType": {
		"body": [
			"game.GetAmmoDamageType(${1:id})$0"
		],
		"description": "Returns the damage type of given ammo type.",
		"prefix": "game.GetAmmoDamageType"
	},
	"game.GetAmmoData": {
		"body": [
			"game.GetAmmoData(${1:id})$0"
		],
		"description": "Returns the Structures/AmmoData for given ID.",
		"prefix": "game.GetAmmoData"
	},
	"game.GetAmmoForce": {
		"body": [
			"game.GetAmmoForce(${1:id})$0"
		],
		"description": "Returns the ammo bullet force that is applied when an entity is hit by a bullet of given ammo type.",
		"prefix": "game.GetAmmoForce"
	},
	"game.GetAmmoID": {
		"body": [
			"game.GetAmmoID(${1:name})$0"
		],
		"description": "Returns the ammo type ID for given ammo type name.\n\nSee game.GetAmmoName for reverse.",
		"prefix": "game.GetAmmoID"
	},
	"game.GetAmmoMax": {
		"body": [
			"game.GetAmmoMax(${1:id})$0"
		],
		"description": "Returns the real maximum amount of ammo of given ammo ID, regardless of the setting of `gmod_maxammo` convar.",
		"prefix": "game.GetAmmoMax"
	},
	"game.GetAmmoNPCDamage": {
		"body": [
			"game.GetAmmoNPCDamage(${1:id})$0"
		],
		"description": "Returns the damage given ammo type should do to NPCs.",
		"prefix": "game.GetAmmoNPCDamage"
	},
	"game.GetAmmoName": {
		"body": [
			"game.GetAmmoName(${1:id})$0"
		],
		"description": "Returns the ammo name for given ammo type ID.\n\nSee game.GetAmmoID for reverse.",
		"prefix": "game.GetAmmoName"
	},
	"game.GetAmmoPlayerDamage": {
		"body": [
			"game.GetAmmoPlayerDamage(${1:id})$0"
		],
		"description": "Returns the damage given ammo type should do to players.",
		"prefix": "game.GetAmmoPlayerDamage"
	},
	"game.GetAmmoTypes": {
		"body": [
			"game.GetAmmoTypes()$0"
		],
		"description": "Returns a list of all ammo types currently registered.",
		"prefix": "game.GetAmmoTypes"
	},
	"game.GetGlobalCounter": {
		"body": [
			"game.GetGlobalCounter(${1:name})$0"
		],
		"description": "Returns the counter of a Global State.\n\nSee Global States for more information.",
		"prefix": "game.GetGlobalCounter"
	},
	"game.GetGlobalState": {
		"body": [
			"game.GetGlobalState(${1:name})$0"
		],
		"description": "Returns whether a Global State is off, active or dead ( inactive )\n\nSee Global States for more information.",
		"prefix": "game.GetGlobalState"
	},
	"game.GetIPAddress": {
		"body": [
			"game.GetIPAddress()$0"
		],
		"description": "Returns the public IP address and port of the current server. This will return the IP/port that you are connecting through when ran clientside.\nReturns \"0.0.0.0:0\" in singleplayer.\n\nReturns \"0.0.0.0:`port`\" on the server when called too early, including in GM:Initialize and GM:InitPostEntity. This bug seems to only happen the first time a server is launched, and will return the correct value after switching maps.",
		"prefix": "game.GetIPAddress"
	},
	"game.GetMap": {
		"body": [
			"game.GetMap()$0"
		],
		"description": "Returns the name of the current map, without a file extension.\nOn the menu state, returns \"menu\".\nIn Multiplayer this does not return the current map in the CLIENT realm before GM:Initialize.",
		"prefix": "game.GetMap"
	},
	"game.GetMapNext": {
		"body": [
			"game.GetMapNext()$0"
		],
		"description": "Returns the next map that would be loaded according to the file that is set by the mapcyclefile convar.",
		"prefix": "game.GetMapNext"
	},
	"game.GetMapVersion": {
		"body": [
			"game.GetMapVersion()$0"
		],
		"description": "Returns the VBSP version of the current map.",
		"prefix": "game.GetMapVersion"
	},
	"game.GetSkillLevel": {
		"body": [
			"game.GetSkillLevel()$0"
		],
		"description": "Returns the difficulty level of the game.\n\n**TIP:** You can use this function in your scripted NPCs or Nextbots to make them harder, however, it is a good idea to lock powerful attacks behind the highest difficulty instead of just increasing the health.\n\nInternally this is tied to the gamerules entity, so you'll have to wait to wait until GM:InitPostEntity is called to return the skill level",
		"prefix": "game.GetSkillLevel"
	},
	"game.GetTimeScale": {
		"body": [
			"game.GetTimeScale()$0"
		],
		"description": "Returns the time scale of the game",
		"prefix": "game.GetTimeScale"
	},
	"game.GetWorld": {
		"body": [
			"game.GetWorld()$0"
		],
		"description": "Returns the worldspawn entity.",
		"prefix": "game.GetWorld"
	},
	"game.IsDedicated": {
		"body": [
			"game.IsDedicated()$0"
		],
		"description": "Returns true if the server is a dedicated server, false if it is a listen server or a singleplayer game.\n\nThis always returns false on the client.",
		"prefix": "game.IsDedicated"
	},
	"game.KickID": {
		"body": [
			"game.KickID(${1:id}, ${2:reason=No reason given})$0"
		],
		"description": "Kicks a player from the server. This can be ran before the player has spawned.",
		"prefix": "game.KickID"
	},
	"game.LoadNextMap": {
		"body": [
			"game.LoadNextMap()$0"
		],
		"description": "Loads the next map according to the nextlevel convar, or from the current mapcycle file set by the respective convar.",
		"prefix": "game.LoadNextMap"
	},
	"game.MapLoadType": {
		"body": [
			"game.MapLoadType()$0"
		],
		"description": "Returns the map load type of the current map.\n\nAfter changing the map with the console command `changelevel`, \"newgame\" is returned. With `changelevel2` (single player only), \"transition\" is returned.",
		"prefix": "game.MapLoadType"
	},
	"game.MaxPlayers": {
		"body": [
			"game.MaxPlayers()$0"
		],
		"description": "Returns the maximum amount of players (including bots) that the server can have.",
		"prefix": "game.MaxPlayers"
	},
	"game.MountGMA": {
		"body": [
			"game.MountGMA(${1:path})$0"
		],
		"description": "Mounts a GMA addon from the disk.\nCan be used with steamworks.DownloadUGC\n\nAny error models currently loaded that the mounted addon provides will be reloaded.\n\n\nAny error materials currently loaded that the mounted addon provides will NOT be reloaded. That means that this cannot be used to fix missing map materials, as the map materials are loaded before you are able to call this.",
		"prefix": "game.MountGMA"
	},
	"game.RemoveRagdolls": {
		"body": [
			"game.RemoveRagdolls()$0"
		],
		"description": "Removes all the clientside ragdolls.",
		"prefix": "game.RemoveRagdolls"
	},
	"game.SetGlobalCounter": {
		"body": [
			"game.SetGlobalCounter(${1:name}, ${2:count})$0"
		],
		"description": "Sets the counter of a Global State.\n\nSee Global States for more information.",
		"prefix": "game.SetGlobalCounter"
	},
	"game.SetGlobalState": {
		"body": [
			"game.SetGlobalState(${1:name}, ${2:state})$0"
		],
		"description": "Sets whether a Global State is off, active or dead ( inactive )\n\nSee Global States for more information.",
		"prefix": "game.SetGlobalState"
	},
	"game.SetSkillLevel": {
		"body": [
			"game.SetSkillLevel(${1:level})$0"
		],
		"description": "Sets the difficulty level of the game, can be retrieved with game.GetSkillLevel.\n\nThis will automatically change whenever the \"skill\" convar is modified serverside.\n\nThis function will not work if the skill convar doesn't match the targeted value. To work around this, you must use RunConsoleCommand(\"skill\", num) alongside this function.",
		"prefix": "game.SetSkillLevel"
	},
	"game.SetTimeScale": {
		"body": [
			"game.SetTimeScale(${1:timeScale})$0"
		],
		"description": "Sets the time scale of the game.\n\nThis function is supposed to remove the need of using the host_timescale convar, which is cheat protected.\n\nTo slow down or speed up the movement of a specific player, use Player:SetLaggedMovementValue instead.\n\nLike host_timescale, this method does not affect sounds, if you wish to change that, look into GM:EntityEmitSound.",
		"prefix": "game.SetTimeScale"
	},
	"game.SinglePlayer": {
		"body": [
			"game.SinglePlayer()$0"
		],
		"description": "Returns whenever the current session is a single player game.",
		"prefix": "game.SinglePlayer"
	},
	"game.StartSpot": {
		"body": [
			"game.StartSpot()$0"
		],
		"description": "Returns position the player should start from, this is not the same thing as spawn points, it is used to properly transit the player between maps.",
		"prefix": "game.StartSpot"
	},
	"gameevent.Listen": {
		"body": [
			"gameevent.Listen(${1:eventName})$0"
		],
		"description": "Add a game event listener.",
		"prefix": "gameevent.Listen"
	},
	"gamemode.Call": {
		"body": [
			"gamemode.Call(${1:name}, ${2:args})$0"
		],
		"description": "Called by the engine to call a hook within the loaded gamemode.\n\nThe supplied event 'name' must be defined in the active gamemode. Otherwise, nothing will happen - not even hooks added with hook.Add will be called.\n\nThis is similar to hook.Run and hook.Call, except the hook library will call hooks created with hook.Add even if there is no corresponding gamemode function.",
		"prefix": "gamemode.Call"
	},
	"gamemode.Get": {
		"body": [
			"gamemode.Get(${1:name})$0"
		],
		"description": " This returns the internally stored gamemode table.",
		"prefix": "gamemode.Get"
	},
	"gamemode.Register": {
		"body": [
			"gamemode.Register(${1:gm}, ${2:name}, ${3:derived})$0"
		],
		"description": "Called by the engine when a gamemode is being loaded.",
		"prefix": "gamemode.Register"
	},
	"gmod.GetGamemode": {
		"body": [
			"gmod.GetGamemode()$0"
		],
		"description": "Returns GAMEMODE.",
		"prefix": "gmod.GetGamemode"
	},
	"gmsave.LoadMap": {
		"body": [
			"gmsave.LoadMap(${1:mapData}, ${2:ply})$0"
		],
		"description": "Loads a saved map.",
		"prefix": "gmsave.LoadMap"
	},
	"gmsave.PlayerLoad": {
		"body": [
			"gmsave.PlayerLoad(${1:ply}, ${2:data})$0"
		],
		"description": "Sets player position and angles from supplied table",
		"prefix": "gmsave.PlayerLoad"
	},
	"gmsave.PlayerSave": {
		"body": [
			"gmsave.PlayerSave(${1:ply})$0"
		],
		"description": "Returns a table containing player position and angles. Used by gmsave.SaveMap.",
		"prefix": "gmsave.PlayerSave"
	},
	"gmsave.SaveMap": {
		"body": [
			"gmsave.SaveMap(${1:ply})$0"
		],
		"description": "Saves the map",
		"prefix": "gmsave.SaveMap"
	},
	"gmsave.ShouldSaveEntity": {
		"body": [
			"gmsave.ShouldSaveEntity(${1:ent}, ${2:t})$0"
		],
		"description": "Returns if we should save this entity in a duplication or a map save or not.",
		"prefix": "gmsave.ShouldSaveEntity"
	},
	"gui.ActivateGameUI": {
		"body": [
			"gui.ActivateGameUI()$0"
		],
		"description": "Opens the game menu overlay.",
		"prefix": "gui.ActivateGameUI"
	},
	"gui.EnableScreenClicker": {
		"body": [
			"gui.EnableScreenClicker(${1:enabled})$0"
		],
		"description": "Enables the mouse cursor without restricting player movement, like using Sandbox's context menu.\n\nSome CUserCmd functions will return incorrect values when this function is active.",
		"prefix": "gui.EnableScreenClicker"
	},
	"gui.HideGameUI": {
		"body": [
			"gui.HideGameUI()$0"
		],
		"description": "Hides the game menu overlay.",
		"prefix": "gui.HideGameUI"
	},
	"gui.InternalCursorMoved": {
		"body": [
			"gui.InternalCursorMoved(${1:deltaX}, ${2:deltaY})$0"
		],
		"description": "Simulates a mouse move with the given deltas.",
		"prefix": "gui.InternalCursorMoved"
	},
	"gui.InternalKeyCodePressed": {
		"body": [
			"gui.InternalKeyCodePressed(${1:key})$0"
		],
		"description": "Simulates a key press for the given key.",
		"prefix": "gui.InternalKeyCodePressed"
	},
	"gui.InternalKeyCodeReleased": {
		"body": [
			"gui.InternalKeyCodeReleased(${1:key})$0"
		],
		"description": "Simulates a key release for the given key.",
		"prefix": "gui.InternalKeyCodeReleased"
	},
	"gui.InternalKeyCodeTyped": {
		"body": [
			"gui.InternalKeyCodeTyped(${1:key})$0"
		],
		"description": "Simulates a key type typing to the specified key.",
		"prefix": "gui.InternalKeyCodeTyped"
	},
	"gui.InternalKeyTyped": {
		"body": [
			"gui.InternalKeyTyped(${1:code})$0"
		],
		"description": "Simulates an ASCII symbol writing.\nUse to write text in the chat or in VGUI.\nDoesn't work while the main menu is open!",
		"prefix": "gui.InternalKeyTyped"
	},
	"gui.InternalMouseDoublePressed": {
		"body": [
			"gui.InternalMouseDoublePressed(${1:key})$0"
		],
		"description": "Simulates a double mouse key press for the given mouse key.",
		"prefix": "gui.InternalMouseDoublePressed"
	},
	"gui.InternalMousePressed": {
		"body": [
			"gui.InternalMousePressed(${1:key})$0"
		],
		"description": "Simulates a mouse key press for the given mouse key.",
		"prefix": "gui.InternalMousePressed"
	},
	"gui.InternalMouseReleased": {
		"body": [
			"gui.InternalMouseReleased(${1:key})$0"
		],
		"description": "Simulates a mouse key release for the given mouse key.",
		"prefix": "gui.InternalMouseReleased"
	},
	"gui.InternalMouseWheeled": {
		"body": [
			"gui.InternalMouseWheeled(${1:delta})$0"
		],
		"description": "Simulates a mouse wheel scroll with the given delta.",
		"prefix": "gui.InternalMouseWheeled"
	},
	"gui.IsConsoleVisible": {
		"body": [
			"gui.IsConsoleVisible()$0"
		],
		"description": "Returns whether the console is visible or not.",
		"prefix": "gui.IsConsoleVisible"
	},
	"gui.IsGameUIVisible": {
		"body": [
			"gui.IsGameUIVisible()$0"
		],
		"description": "Returns whenever the game menu overlay ( main menu ) is open or not.",
		"prefix": "gui.IsGameUIVisible"
	},
	"gui.MousePos": {
		"body": [
			"gui.MousePos()$0"
		],
		"description": "Use input.GetCursorPos instead.\n\nReturns the cursor's position on the screen, or 0, 0 if cursor is not visible.",
		"prefix": "gui.MousePos"
	},
	"gui.MouseX": {
		"body": [
			"gui.MouseX()$0"
		],
		"description": "Returns x component of the mouse position.",
		"prefix": "gui.MouseX"
	},
	"gui.MouseY": {
		"body": [
			"gui.MouseY()$0"
		],
		"description": "Returns y component of the mouse position.",
		"prefix": "gui.MouseY"
	},
	"gui.OpenURL": {
		"body": [
			"gui.OpenURL(${1:url})$0"
		],
		"description": "Opens specified URL in the steam overlay browser. The URL has to start with either http:// or https://\n\nWhen called clientside, user will be asked for confirmation before the website will open.\nYou can't click the confirmation if a model panel has focus.\nWill silently fail if the URL is more than 512 characters long.",
		"prefix": "gui.OpenURL"
	},
	"gui.ScreenToVector": {
		"body": [
			"gui.ScreenToVector(${1:x}, ${2:y})$0"
		],
		"description": "Converts the specified screen position to a **direction** vector local to the player's view. A related function is Vector:ToScreen, which translates a 3D position to a screen coordinate.\n\nutil.AimVector is a more generic version of this, using a custom view instead of the player's current view.",
		"prefix": "gui.ScreenToVector"
	},
	"gui.SetMousePos": {
		"body": [
			"gui.SetMousePos(${1:mouseX}, ${2:mouseY})$0"
		],
		"description": "Use input.SetCursorPos instead.\nSets the cursor's position on the screen, relative to the topleft corner of the window",
		"prefix": "gui.SetMousePos"
	},
	"gui.ShowConsole": {
		"body": [
			"gui.ShowConsole()$0"
		],
		"description": "Shows console in the game UI.",
		"prefix": "gui.ShowConsole"
	},
	"halo.Add": {
		"body": [
			"halo.Add(${1:entities}, ${2:color}, ${3:blurX=2}, ${4:blurY=2}, ${5:passes=1}, ${6:additive=true}, ${7:ignoreZ=false})$0"
		],
		"description": "Applies a halo glow effect to one or multiple entities.\nUsing this function outside of the GM:PreDrawHalos hook can cause instability or crashes.\nThe ignoreZ parameter will cause the halos to draw over the player's viewmodel. You can work around this using render.DepthRange in the GM:PreDrawViewModel, GM:PostDrawViewModel, GM:PreDrawPlayerHands and GM:PostDrawPlayerHands hooks.",
		"prefix": "halo.Add"
	},
	"halo.Render": {
		"body": [
			"halo.Render(${1:entry})$0"
		],
		"description": "Renders a halo according to the specified table, only used internally, called from a GM:PostDrawEffects hook added by the halo library.",
		"prefix": "halo.Render"
	},
	"halo.RenderedEntity": {
		"body": [
			"halo.RenderedEntity()$0"
		],
		"description": "Returns the entity the halo library is currently rendering the halo for.\n\nThe main purpose of this function is to be used in ENTITY:Draw in order not to draw certain parts of the entity when the halo is being rendered, so there's no halo around unwanted entity parts, such as lasers, 3D2D displays, etc.",
		"prefix": "halo.RenderedEntity"
	},
	"hammer.SendCommand": {
		"body": [
			"hammer.SendCommand(${1:cmd})$0"
		],
		"description": "Sends command to Hammer, if Hammer is running with the current map loaded.",
		"prefix": "hammer.SendCommand"
	},
	"hook.Add": {
		"body": [
			"hook.Add(${1:eventName}, ${2:identifier}, ${3:func})$0"
		],
		"description": "Add a hook to be called upon the given event occurring.",
		"prefix": "hook.Add"
	},
	"hook.Call": {
		"body": [
			"hook.Call(${1:eventName}, ${2:gamemodeTable}, ${3:args})$0"
		],
		"description": "Calls all hooks associated with the given event until one returns something other than nil, and then returns that data.\n\nIn almost all cases, you should use hook.Run instead - it calls hook.Call internally but supplies the gamemode table by itself, making your code neater.",
		"prefix": "hook.Call"
	},
	"hook.GetTable": {
		"body": [
			"hook.GetTable()$0"
		],
		"description": "Returns a list of all the hooks registered with hook.Add.",
		"prefix": "hook.GetTable"
	},
	"hook.Remove": {
		"body": [
			"hook.Remove(${1:eventName}, ${2:identifier})$0"
		],
		"description": "Removes the hook with the supplied identifier from the given event.",
		"prefix": "hook.Remove"
	},
	"hook.Run": {
		"body": [
			"hook.Run(${1:eventName}, ${2:args})$0"
		],
		"description": "Calls hooks associated with the given event.\n\nCalls all hooks until one returns something other than nil and then returns that data.\n\n\nIf no hook returns any data, it will try to call the GAMEMODE: alternative, if one exists.\n\nThis function internally calls hook.Call.\n\nSee also: gamemode.Call - same as this, but does not call hooks if the gamemode hasn't defined the function.",
		"prefix": "hook.Run"
	},
	"http.Fetch": {
		"body": [
			"http.Fetch(${1:url}, ${2:onSuccess=nil}, ${3:onFailure=nil}, ${4:headers={}})$0"
		],
		"description": "Launches an asynchronous **GET** request to a HTTP server.\n\nHTTP requests returning a status code >= `400` are still considered a success and will call the Structures/HTTPRequest callback.\n\nThe Structures/HTTPRequest callback is usually only called on DNS or TCP errors (e.g. the website is unavailable or the domain does not exist).\nHTTP-requests to destinations on private networks (such as `192.168.0.1`) won't work. To enable HTTP-requests to destinations on private networks use Command Line Parameters `-allowlocalhttp`.",
		"prefix": "http.Fetch"
	},
	"http.Post": {
		"body": [
			"http.Post(${1:url}, ${2:parameters}, ${3:onSuccess=nil}, ${4:onFailure=nil}, ${5:headers={}})$0"
		],
		"description": "Sends an asynchronous **POST** request to a HTTP server.\n\nHTTP requests returning a status code >= `400` are still considered a success and will call the Structures/HTTPRequest callback.\n\nThe Structures/HTTPRequest callback is usually only called on DNS or TCP errors (e.g. the website is unavailable or the domain does not exist).\nHTTP-requests to destinations on private networks (such as `192.168.0.1`) won't work. To enable HTTP-requests to destinations on private networks use Command Line Parameters `-allowlocalhttp`.",
		"prefix": "http.Post"
	},
	"input.CheckKeyTrapping": {
		"body": [
			"input.CheckKeyTrapping()$0"
		],
		"description": "Returns the last key captured by key trapping.",
		"prefix": "input.CheckKeyTrapping"
	},
	"input.GetCursorPos": {
		"body": [
			"input.GetCursorPos()$0"
		],
		"description": "Returns the cursor's position on the screen",
		"prefix": "input.GetCursorPos"
	},
	"input.GetKeyCode": {
		"body": [
			"input.GetKeyCode(${1:button})$0"
		],
		"description": "Gets the button code from a button name. This is opposite of input.GetKeyName.",
		"prefix": "input.GetKeyCode"
	},
	"input.GetKeyName": {
		"body": [
			"input.GetKeyName(${1:button})$0"
		],
		"description": "Gets the button name from a numeric button code. The name needs to be translated with language.GetPhrase before being displayed.\n\nDespite the name of the function, this also works for the full range of keys in Enums/BUTTON_CODE.",
		"prefix": "input.GetKeyName"
	},
	"input.IsButtonDown": {
		"body": [
			"input.IsButtonDown(${1:button})$0"
		],
		"description": "Gets whether the specified button code is down.\n\nUnlike input.IsKeyDown this can also detect joystick presses from Enums/JOYSTICK",
		"prefix": "input.IsButtonDown"
	},
	"input.IsControlDown": {
		"body": [
			"input.IsControlDown()$0"
		],
		"description": "Returns whether a control key is being pressed",
		"prefix": "input.IsControlDown"
	},
	"input.IsKeyDown": {
		"body": [
			"input.IsKeyDown(${1:key})$0"
		],
		"description": "Gets whether a key is down.",
		"prefix": "input.IsKeyDown"
	},
	"input.IsKeyTrapping": {
		"body": [
			"input.IsKeyTrapping()$0"
		],
		"description": "Returns whether key trapping is activate and the next key press will be captured.",
		"prefix": "input.IsKeyTrapping"
	},
	"input.IsMouseDown": {
		"body": [
			"input.IsMouseDown(${1:mouseKey})$0"
		],
		"description": "Gets whether a mouse button is down",
		"prefix": "input.IsMouseDown"
	},
	"input.IsShiftDown": {
		"body": [
			"input.IsShiftDown()$0"
		],
		"description": "Gets whether a shift key is being pressed",
		"prefix": "input.IsShiftDown"
	},
	"input.LookupBinding": {
		"body": [
			"input.LookupBinding(${1:binding}, ${2:exact=false})$0"
		],
		"description": "Gets the match uppercase key for the specified binding.",
		"prefix": "input.LookupBinding"
	},
	"input.LookupKeyBinding": {
		"body": [
			"input.LookupKeyBinding(${1:key})$0"
		],
		"description": "Returns the bind string that the given key is bound to.",
		"prefix": "input.LookupKeyBinding"
	},
	"input.SelectWeapon": {
		"body": [
			"input.SelectWeapon(${1:weapon})$0"
		],
		"description": "Switches to the provided weapon on the next CUserCmd generation/CreateMove call. Direct binding to [CInput::MakeWeaponSelection](https://github.com/LestaD/SourceEngine2007/blob/43a5c90a5ada1e69ca044595383be67f40b33c61/se2007/game/client/in_main.cpp#L929-L932).",
		"prefix": "input.SelectWeapon"
	},
	"input.SetCursorPos": {
		"body": [
			"input.SetCursorPos(${1:mouseX}, ${2:mouseY})$0"
		],
		"description": "Sets the cursor's position on the screen, relative to the topleft corner of the window",
		"prefix": "input.SetCursorPos"
	},
	"input.StartKeyTrapping": {
		"body": [
			"input.StartKeyTrapping()$0"
		],
		"description": "Begins waiting for a key to be pressed so we can save it for input.CheckKeyTrapping. Used by the DBinder.",
		"prefix": "input.StartKeyTrapping"
	},
	"input.TranslateAlias": {
		"body": [
			"input.TranslateAlias(${1:command})$0"
		],
		"description": "Translates a console command alias, basically reverse of the `alias` console command.",
		"prefix": "input.TranslateAlias"
	},
	"input.WasKeyPressed": {
		"body": [
			"input.WasKeyPressed(${1:key})$0"
		],
		"description": "Returns whether a key was initially pressed in the same frame this function was called.\n\nThis function only works in Move hooks, and will detect key presses even in main menu or when a typing in a text field.",
		"prefix": "input.WasKeyPressed"
	},
	"input.WasKeyReleased": {
		"body": [
			"input.WasKeyReleased(${1:key})$0"
		],
		"description": "Returns whether a key was released in the same frame this function was called.\n\nThis function only works in Move hooks, and will detect key releases even in main menu or when a typing in a text field.",
		"prefix": "input.WasKeyReleased"
	},
	"input.WasKeyTyped": {
		"body": [
			"input.WasKeyTyped(${1:key})$0"
		],
		"description": "Returns whether the key is being held down or not.\n\nThis function only works in Move hooks, and will detect key events even in main menu or when a typing in a text field.",
		"prefix": "input.WasKeyTyped"
	},
	"input.WasMouseDoublePressed": {
		"body": [
			"input.WasMouseDoublePressed(${1:button})$0"
		],
		"description": "Returns whether a mouse key was double pressed in the same frame this function was called.\n\n\nIf this function returns true, input.WasMousePressed will return false.\n\nThis function only works in Move hooks, and will detect mouse events even in main menu or when a typing in a text field.",
		"prefix": "input.WasMouseDoublePressed"
	},
	"input.WasMousePressed": {
		"body": [
			"input.WasMousePressed(${1:key})$0"
		],
		"description": "Returns whether a mouse key was initially pressed in the same frame this function was called.\n\n\nIf input.WasMouseDoublePressed returns true, this function will return false.\n\nThis function only works in Move hooks, and will detect mouse events even in main menu or when a typing in a text field.",
		"prefix": "input.WasMousePressed"
	},
	"input.WasMouseReleased": {
		"body": [
			"input.WasMouseReleased(${1:key})$0"
		],
		"description": "Returns whether a mouse key was released in the same frame this function was called.\n\nThis function only works in Move hooks, and will detect mouse events even in main menu or when a typing in a text field.",
		"prefix": "input.WasMouseReleased"
	},
	"jit.attach": {
		"body": [
			"jit.attach(${1:callback}, ${2:event})$0"
		],
		"description": "You can attach callbacks to a number of compiler events with jit.attach. The callback can be called:\n\n* when a function has been compiled to bytecode (\"bc\");\n* when trace recording starts or stops (\"trace\");\n* as a trace is being recorded (\"record\");\n* or when a trace exits through a side exit (\"texit\").\n\nSet a callback with jit.attach(callback, \"event\") and clear the same callback with jit.attach(callback)\n\nThis function isn't officially documented on LuJIT wiki, use it at your own risk.",
		"prefix": "jit.attach"
	},
	"jit.flush": {
		"body": [
			"jit.flush()$0"
		],
		"description": "Flushes the whole cache of compiled code.",
		"prefix": "jit.flush"
	},
	"jit.off": {
		"body": [
			"jit.off()$0"
		],
		"description": "Disables LuaJIT Lua compilation.",
		"prefix": "jit.off"
	},
	"jit.on": {
		"body": [
			"jit.on()$0"
		],
		"description": "Enables LuaJIT Lua compilation.",
		"prefix": "jit.on"
	},
	"jit.opt.start": {
		"body": [
			"jit.opt.start(${1:args})$0"
		],
		"description": "JIT compiler optimization control. The opt sub-module provides the backend for the -O command line LuaJIT option.\nYou can also use it programmatically, e.g.:\n\n```\njit.opt.start(2) -- same as -O2\njit.opt.start(\"-dce\")\njit.opt.start(\"hotloop=10\", \"hotexit=2\")\n```\n\nA list of LuaJIT -O command line options can be found here(a table of various optimization levels are displayed towards the bottom of the page along with exactly which optimization options are enabled for each level): http://luajit.org/running.html",
		"prefix": "jit.opt.start"
	},
	"jit.status": {
		"body": [
			"jit.status()$0"
		],
		"description": "Returns the status of the JIT compiler and the current optimizations enabled.",
		"prefix": "jit.status"
	},
	"jit.util.funcbc": {
		"body": [
			"jit.util.funcbc(${1:func}, ${2:pos})$0"
		],
		"description": "Returns bytecode of a function at a position.",
		"prefix": "jit.util.funcbc"
	},
	"jit.util.funcinfo": {
		"body": [
			"jit.util.funcinfo(${1:func}, ${2:pos=0})$0"
		],
		"description": "Retrieves LuaJIT information about a given function, similarly to debug.getinfo. Possible table fields:\n* linedefined: as for debug.getinfo\n* lastlinedefined: as for debug.getinfo\n* params: the number of parameters the function takes\n* stackslots: the number of stack slots the function's local variable use\n* upvalues: the number of upvalues the function uses\n* bytecodes: the number of bytecodes it the compiled function\n* gcconsts: the number of garbage collectable constants\n* nconsts: the number of lua_Number (double) constants\n* children: Boolean representing whether the function creates closures\n* currentline: as for debug.getinfo\n* isvararg: if the function is a vararg function\n* source: as for debug.getinfo\n* loc: a string describing the source and currentline, like \":\"\n* ffid: the fast function id of the function (if it is one). In this case only upvalues above and addr below are valid\n* addr: the address of the function (if it is not a Lua function). If it's a C function rather than a fast function, only upvalues above is valid*",
		"prefix": "jit.util.funcinfo"
	},
	"jit.util.funck": {
		"body": [
			"jit.util.funck(${1:func}, ${2:index})$0"
		],
		"description": "Gets a constant at a certain index in a function.\nThis function isn't officially documented on LuJIT wiki, use it at your own risk.\nNumbers constants goes from 0 (included) to n-1, n being the value of nconsts in jit.util.funcinfo in other words, the consts goes from (nconsts-1) to -n\nThis function only works for Lua defined functions.",
		"prefix": "jit.util.funck"
	},
	"jit.util.funcuvname": {
		"body": [
			"jit.util.funcuvname(${1:func}, ${2:index})$0"
		],
		"description": "Does the exact same thing as debug.getupvalue except it only returns the name, not the name and the object. The upvalue indexes also start at 0 rather than 1, so doing jit.util.funcuvname(func, 0) will get you the same name as debug.getupvalue(func, 1)\nThis function isn't officially documented on LuJIT wiki, use it at your own risk.",
		"prefix": "jit.util.funcuvname"
	},
	"jit.util.ircalladdr": {
		"body": [
			"jit.util.ircalladdr(${1:index})$0"
		],
		"description": "Gets the address of a function from a list of 20 functions, for the list see Ircalladdr Functions\nThis function isn't officially documented on LuJIT wiki, use it at your own risk.",
		"prefix": "jit.util.ircalladdr"
	},
	"jit.util.traceexitstub": {
		"body": [
			"jit.util.traceexitstub(${1:exitno})$0"
		],
		"description": "",
		"prefix": "jit.util.traceexitstub"
	},
	"jit.util.traceinfo": {
		"body": [
			"jit.util.traceinfo(${1:trace})$0"
		],
		"description": "Return table fields:\n* link (number): the linked trace (0 for link types: none, return, interpreter)\n* nk (number): the lowest IR constant (???)\n* nins (number): the next IR instruction (???)\n* linktype (string): the link type (none, root, loop, tail-recursion, up-recursion, down-recursion, interpreter, return)\n* nexit (number): number of snapshots (for use with jit.util.tracesnap)",
		"prefix": "jit.util.traceinfo"
	},
	"jit.util.traceir": {
		"body": [
			"jit.util.traceir(${1:tr}, ${2:index})$0"
		],
		"description": "",
		"prefix": "jit.util.traceir"
	},
	"jit.util.tracek": {
		"body": [
			"jit.util.tracek(${1:tr}, ${2:index})$0"
		],
		"description": "",
		"prefix": "jit.util.tracek"
	},
	"jit.util.tracemc": {
		"body": [
			"jit.util.tracemc(${1:tr})$0"
		],
		"description": "",
		"prefix": "jit.util.tracemc"
	},
	"jit.util.tracesnap": {
		"body": [
			"jit.util.tracesnap(${1:tr}, ${2:sn})$0"
		],
		"description": "Return table fields:\n* 0 (ref) (number): first IR ref for the snapshot\n* 1 (nslots) (number): the number of valid slots\n* all indexes except first 2 and last (there might not be any of these): the snapshot map\n* last index in table (number): -16777216 (255 << 24)",
		"prefix": "jit.util.tracesnap"
	},
	"killicon.Add": {
		"body": [
			"killicon.Add(${1:class}, ${2:texture}, ${3:color})$0"
		],
		"description": "Creates new kill icon using a texture.",
		"prefix": "killicon.Add"
	},
	"killicon.AddAlias": {
		"body": [
			"killicon.AddAlias(${1:new_class}, ${2:existing_class})$0"
		],
		"description": "Creates kill icon from existing one.",
		"prefix": "killicon.AddAlias"
	},
	"killicon.AddFont": {
		"body": [
			"killicon.AddFont(${1:class}, ${2:font}, ${3:symbol}, ${4:color})$0"
		],
		"description": "Adds kill icon for given weapon/entity class using special font.",
		"prefix": "killicon.AddFont"
	},
	"killicon.Draw": {
		"body": [
			"killicon.Draw(${1:x}, ${2:y}, ${3:name}, ${4:alpha})$0"
		],
		"description": "Draws a kill icon.",
		"prefix": "killicon.Draw"
	},
	"killicon.Exists": {
		"body": [
			"killicon.Exists(${1:class})$0"
		],
		"description": "Checks if kill icon exists for given class.",
		"prefix": "killicon.Exists"
	},
	"killicon.GetSize": {
		"body": [
			"killicon.GetSize(${1:name})$0"
		],
		"description": "Returns the size of a kill icon.",
		"prefix": "killicon.GetSize"
	},
	"language.Add": {
		"body": [
			"language.Add(${1:placeholder}, ${2:fulltext})$0"
		],
		"description": "Adds a language item. Language placeholders preceded with \"#\" are replaced with full text in Garry's Mod once registered with this function.",
		"prefix": "language.Add"
	},
	"language.GetPhrase": {
		"body": [
			"language.GetPhrase(${1:phrase})$0"
		],
		"description": "Retrieves the translated version of inputted string. Useful for concentrating multiple translated strings.",
		"prefix": "language.GetPhrase"
	},
	"list.Add": {
		"body": [
			"list.Add(${1:identifier}, ${2:item})$0"
		],
		"description": "Adds an item to a named list",
		"prefix": "list.Add"
	},
	"list.Contains": {
		"body": [
			"list.Contains(${1:list}, ${2:value})$0"
		],
		"description": "Returns true if the list contains the value. (as a value - not a key)\n\nFor a function that looks for a key and not a value see list.HasEntry.",
		"prefix": "list.Contains"
	},
	"list.Get": {
		"body": [
			"list.Get(${1:identifier})$0"
		],
		"description": "Returns a copy of the list stored at identifier",
		"prefix": "list.Get"
	},
	"list.GetForEdit": {
		"body": [
			"list.GetForEdit(${1:identifier})$0"
		],
		"description": "Returns the actual table of the list stored at identifier. Modifying this will affect the stored list",
		"prefix": "list.GetForEdit"
	},
	"list.GetTable": {
		"body": [
			"list.GetTable()$0"
		],
		"description": "Returns a a list of all lists currently in use.",
		"prefix": "list.GetTable"
	},
	"list.HasEntry": {
		"body": [
			"list.HasEntry(${1:list}, ${2:key})$0"
		],
		"description": "Returns true if the list contains the given key.\n\nFor a function that looks for values and not keys see list.Contains.",
		"prefix": "list.HasEntry"
	},
	"list.Set": {
		"body": [
			"list.Set(${1:identifier}, ${2:key}, ${3:item})$0"
		],
		"description": "Sets a specific position in the named list to a value.",
		"prefix": "list.Set"
	},
	"markup.Parse": {
		"body": [
			"markup.Parse(${1:markup}, ${2:maxWidth=nil})$0"
		],
		"description": "Parses markup into a MarkupObject. Currently, this only supports fonts and colors as demonstrated in the example.",
		"prefix": "markup.Parse"
	},
	"math.AngleDifference": {
		"body": [
			"math.AngleDifference(${1:a}, ${2:b})$0"
		],
		"description": "Calculates the difference between two angles.",
		"prefix": "math.AngleDifference"
	},
	"math.Approach": {
		"body": [
			"math.Approach(${1:current}, ${2:target}, ${3:change})$0"
		],
		"description": "Gradually approaches the target value by the specified amount.",
		"prefix": "math.Approach"
	},
	"math.ApproachAngle": {
		"body": [
			"math.ApproachAngle(${1:currentAngle}, ${2:targetAngle}, ${3:rate})$0"
		],
		"description": "Increments an angle towards another by specified rate.\n\nThis function is for numbers representing angles (0-360), NOT Angle objects!",
		"prefix": "math.ApproachAngle"
	},
	"math.BSplinePoint": {
		"body": [
			"math.BSplinePoint(${1:tDiff}, ${2:tPoints}, ${3:tMax})$0"
		],
		"description": "Basic code for  algorithm.",
		"prefix": "math.BSplinePoint"
	},
	"math.BinToInt": {
		"body": [
			"math.BinToInt(${1:string})$0"
		],
		"description": "Converts a binary string into a number.",
		"prefix": "math.BinToInt"
	},
	"math.Clamp": {
		"body": [
			"math.Clamp(${1:input}, ${2:min}, ${3:max})$0"
		],
		"description": "Clamps a number between a minimum and maximum value.",
		"prefix": "math.Clamp"
	},
	"math.Dist": {
		"body": [
			"math.Dist(${1:x1}, ${2:y1}, ${3:x2}, ${4:y2})$0"
		],
		"description": "You should use math.Distance instead\n\nReturns the difference between two points in 2D space. Alias of math.Distance.",
		"prefix": "math.Dist"
	},
	"math.Distance": {
		"body": [
			"math.Distance(${1:x1}, ${2:y1}, ${3:x2}, ${4:y2})$0"
		],
		"description": "Returns the difference between two points in 2D space.",
		"prefix": "math.Distance"
	},
	"math.EaseInOut": {
		"body": [
			"math.EaseInOut(${1:progress}, ${2:easeIn}, ${3:easeOut})$0"
		],
		"description": "Calculates the progress of a value fraction, taking in to account given easing fractions",
		"prefix": "math.EaseInOut"
	},
	"math.IntToBin": {
		"body": [
			"math.IntToBin(${1:int})$0"
		],
		"description": "Converts an integer to a binary (base-2) string.",
		"prefix": "math.IntToBin"
	},
	"math.NormalizeAngle": {
		"body": [
			"math.NormalizeAngle(${1:angle})$0"
		],
		"description": "Normalizes angle, so it returns value between -180 and 180.",
		"prefix": "math.NormalizeAngle"
	},
	"math.Rand": {
		"body": [
			"math.Rand(${1:min}, ${2:max})$0"
		],
		"description": "Returns a random float between min and max.\n\nSee also math.random",
		"prefix": "math.Rand"
	},
	"math.Remap": {
		"body": [
			"math.Remap(${1:value}, ${2:inMin}, ${3:inMax}, ${4:outMin}, ${5:outMax})$0"
		],
		"description": "Remaps the value from one range to another",
		"prefix": "math.Remap"
	},
	"math.Round": {
		"body": [
			"math.Round(${1:value}, ${2:decimals=0})$0"
		],
		"description": "Rounds the given value to the nearest whole number or to the given decimal places.",
		"prefix": "math.Round"
	},
	"math.TimeFraction": {
		"body": [
			"math.TimeFraction(${1:start}, ${2:end}, ${3:current})$0"
		],
		"description": "Returns the fraction of where the current time is relative to the start and end times",
		"prefix": "math.TimeFraction"
	},
	"math.Truncate": {
		"body": [
			"math.Truncate(${1:num}, ${2:digits=0})$0"
		],
		"description": "Rounds towards zero.",
		"prefix": "math.Truncate"
	},
	"math.abs": {
		"body": [
			"math.abs(${1:x})$0"
		],
		"description": "Calculates the absolute value of a number (effectively removes any negative sign).",
		"prefix": "math.abs"
	},
	"math.acos": {
		"body": [
			"math.acos(${1:cos})$0"
		],
		"description": "Returns the  of the given number.",
		"prefix": "math.acos"
	},
	"math.asin": {
		"body": [
			"math.asin(${1:normal})$0"
		],
		"description": "Returns the [arcsine](https://en.wikipedia.org/wiki/Inverse_trigonometric_functions) of the given number.",
		"prefix": "math.asin"
	},
	"math.atan": {
		"body": [
			"math.atan(${1:normal})$0"
		],
		"description": "Returns the [arctangent](https://en.wikipedia.org/wiki/Inverse_trigonometric_functions) of the given number.",
		"prefix": "math.atan"
	},
	"math.atan2": {
		"body": [
			"math.atan2(${1:y}, ${2:x})$0"
		],
		"description": "functions like math.atan(y / x), except it also takes into account the quadrant of the angle and so doesn't have a limited range of output.\n\nThe Y argument comes first!",
		"prefix": "math.atan2"
	},
	"math.calcBSplineN": {
		"body": [
			"math.calcBSplineN(${1:i}, ${2:k}, ${3:t}, ${4:tinc})$0"
		],
		"description": "Use math.BSplinePoint instead.\n\nBasic code for Bezier-Spline algorithm, helper function for math.BSplinePoint.",
		"prefix": "math.calcBSplineN"
	},
	"math.ceil": {
		"body": [
			"math.ceil(${1:number})$0"
		],
		"description": "Ceils or rounds a number up.",
		"prefix": "math.ceil"
	},
	"math.cos": {
		"body": [
			"math.cos(${1:number})$0"
		],
		"description": "Returns the [cosine](https://en.wikipedia.org/wiki/Trigonometric_functions#cos) of given angle.",
		"prefix": "math.cos"
	},
	"math.cosh": {
		"body": [
			"math.cosh(${1:number})$0"
		],
		"description": "Returns the [hyperbolic cosine](https://en.wikipedia.org/wiki/Cosh_(mathematical_function)) of the given angle.",
		"prefix": "math.cosh"
	},
	"math.deg": {
		"body": [
			"math.deg(${1:radians})$0"
		],
		"description": "Converts radians to degrees.",
		"prefix": "math.deg"
	},
	"math.exp": {
		"body": [
			"math.exp(${1:exponent})$0"
		],
		"description": "Returns the x power of the Euler constant.",
		"prefix": "math.exp"
	},
	"math.floor": {
		"body": [
			"math.floor(${1:number})$0"
		],
		"description": "Floors or rounds a number down.",
		"prefix": "math.floor"
	},
	"math.fmod": {
		"body": [
			"math.fmod(${1:base}, ${2:modulator})$0"
		],
		"description": "Returns the modulus of the specified values.\n\nWhile this is similar to the % operator, **it will return a negative value if the first argument is negative**, whereas the % operator will return a `positive` value **even if the first operand is negative**.",
		"prefix": "math.fmod"
	},
	"math.frexp": {
		"body": [
			"math.frexp(${1:x})$0"
		],
		"description": "\nUsed to split the number value into a normalized fraction and an exponent. Two values are returned: the first is a multiplier in the range 1/2 (inclusive) to 1 (exclusive) and the second is an integer exponent.\n\nThe result is such that x = m*2^e.",
		"prefix": "math.frexp"
	},
	"math.ldexp": {
		"body": [
			"math.ldexp(${1:normalizedFraction}, ${2:exponent})$0"
		],
		"description": "Takes a normalised number and returns the floating point representation.",
		"prefix": "math.ldexp"
	},
	"math.log": {
		"body": [
			"math.log(${1:x}, ${2:base=e})$0"
		],
		"description": "With one argument, return the natural logarithm of x (to base e).\n\nWith two arguments, return the logarithm of x to the given base, calculated as log(x)/log(base).",
		"prefix": "math.log"
	},
	"math.log10": {
		"body": [
			"math.log10(${1:x})$0"
		],
		"description": "Returns the base-10 logarithm of x. This is usually more accurate than math.log(x, 10).",
		"prefix": "math.log10"
	},
	"math.max": {
		"body": [
			"math.max(${1:numbers})$0"
		],
		"description": "Returns the largest value of all arguments.",
		"prefix": "math.max"
	},
	"math.min": {
		"body": [
			"math.min(${1:numbers})$0"
		],
		"description": "Returns the smallest value of all arguments.",
		"prefix": "math.min"
	},
	"math.mod": {
		"body": [
			"math.mod(${1:base}, ${2:modulator})$0"
		],
		"description": "This is removed in Lua versions later than what GMod is currently using. You should use the % operator or math.fmod instead.\n\nReturns the modulus of the specified values. Same as math.fmod.",
		"prefix": "math.mod"
	},
	"math.modf": {
		"body": [
			"math.modf(${1:base})$0"
		],
		"description": "Returns the integral and fractional component of the modulo operation.",
		"prefix": "math.modf"
	},
	"math.pow": {
		"body": [
			"math.pow(${1:x}, ${2:y})$0"
		],
		"description": "Returns x raised to the power y.\nIn particular, math.pow(1.0, x) and math.pow(x, 0.0) always return 1.0, even when x is a zero or a nan. If both x and y are finite, x is negative, and y is not an integer then math.pow(x, y) is undefined.",
		"prefix": "math.pow"
	},
	"math.rad": {
		"body": [
			"math.rad(${1:degrees})$0"
		],
		"description": "Converts an angle in degrees to it's equivalent in radians.",
		"prefix": "math.rad"
	},
	"math.random": {
		"body": [
			"math.random(${1:m=nil}, ${2:n=nil})$0"
		],
		"description": "When called without arguments, returns a uniform pseudo-random real number in the range 0 to 1 which includes 0 but excludes 1.\n\nWhen called with an integer number m, returns a uniform pseudo-random integer in the range 1 to m inclusive.\n\nWhen called with two integer numbers m and n, returns a uniform pseudo-random integer in the range m to n inclusive.\n\nSee also math.Rand",
		"prefix": "math.random"
	},
	"math.randomseed": {
		"body": [
			"math.randomseed(${1:seed})$0"
		],
		"description": "Seeds the random number generator. The same seed will guarantee the same sequence of numbers each time with math.random.\n\nFor shared random values across predicted realms, use util.SharedRandom.\n\nIncorrect usage of this function will affect `all` random numbers in the game.",
		"prefix": "math.randomseed"
	},
	"math.sin": {
		"body": [
			"math.sin(${1:number})$0"
		],
		"description": "Returns the [sine](https://en.wikipedia.org/wiki/Trigonometric_functions) of given angle.",
		"prefix": "math.sin"
	},
	"math.sinh": {
		"body": [
			"math.sinh(${1:number})$0"
		],
		"description": "Returns the [hyperbolic sine](https://en.wikipedia.org/wiki/Hyperbolic_functions) of the given angle.",
		"prefix": "math.sinh"
	},
	"math.sqrt": {
		"body": [
			"math.sqrt(${1:value})$0"
		],
		"description": "Returns the square root of the number.",
		"prefix": "math.sqrt"
	},
	"math.tan": {
		"body": [
			"math.tan(${1:value})$0"
		],
		"description": "Returns the tangent of the given angle.",
		"prefix": "math.tan"
	},
	"math.tanh": {
		"body": [
			"math.tanh(${1:number})$0"
		],
		"description": "Returns the [hyperbolic tangent](https://en.wikipedia.org/wiki/Hyperbolic_functions) of the given number.",
		"prefix": "math.tanh"
	},
	"matproxy.Add": {
		"body": [
			"matproxy.Add(${1:MatProxyData})$0"
		],
		"description": "Adds a material proxy.",
		"prefix": "matproxy.Add"
	},
	"matproxy.Call": {
		"body": [
			"matproxy.Call(${1:uname}, ${2:mat}, ${3:ent})$0"
		],
		"description": "Called by the engine from OnBind",
		"prefix": "matproxy.Call"
	},
	"matproxy.Init": {
		"body": [
			"matproxy.Init(${1:name}, ${2:uname}, ${3:mat}, ${4:values})$0"
		],
		"description": "Called by the engine from OnBind",
		"prefix": "matproxy.Init"
	},
	"matproxy.ShouldOverrideProxy": {
		"body": [
			"matproxy.ShouldOverrideProxy(${1:name})$0"
		],
		"description": "Called by engine, returns true if we're overriding a proxy",
		"prefix": "matproxy.ShouldOverrideProxy"
	},
	"menu.RecordFrame": {
		"body": [
			"menu.RecordFrame()$0"
		],
		"description": "Used by \"Demo to Video\" to record the frame.",
		"prefix": "menu.RecordFrame"
	},
	"menubar.Init": {
		"body": [
			"menubar.Init()$0"
		],
		"description": "Creates the menu bar ( The bar at the top of the screen when holding C or Q in sandbox ) and docks it to the top of the screen. It will not appear.\n\n\nCalling this multiple times will **NOT** remove previous panel.",
		"prefix": "menubar.Init"
	},
	"menubar.IsParent": {
		"body": [
			"menubar.IsParent(${1:pnl})$0"
		],
		"description": "Checks if the supplied panel is parent to the menubar",
		"prefix": "menubar.IsParent"
	},
	"menubar.ParentTo": {
		"body": [
			"menubar.ParentTo(${1:pnl})$0"
		],
		"description": "Parents the menubar to the panel and displays the menubar.",
		"prefix": "menubar.ParentTo"
	},
	"mesh.AdvanceVertex": {
		"body": [
			"mesh.AdvanceVertex()$0"
		],
		"description": "Pushes the new vertex data onto the render stack.",
		"prefix": "mesh.AdvanceVertex"
	},
	"mesh.Begin": {
		"body": [
			"mesh.Begin(${1:mesh=nil}, ${2:primitiveType}, ${3:primiteCount})$0"
		],
		"description": "Starts a new dynamic mesh. If an IMesh is passed, it will use that mesh instead.",
		"prefix": "mesh.Begin"
	},
	"mesh.Color": {
		"body": [
			"mesh.Color(${1:r}, ${2:g}, ${3:b}, ${4:a})$0"
		],
		"description": "Sets the color to be used for the next vertex.",
		"prefix": "mesh.Color"
	},
	"mesh.End": {
		"body": [
			"mesh.End()$0"
		],
		"description": "Ends the mesh and renders it.",
		"prefix": "mesh.End"
	},
	"mesh.Normal": {
		"body": [
			"mesh.Normal(${1:normal})$0"
		],
		"description": "Sets the normal to be used for the next vertex.",
		"prefix": "mesh.Normal"
	},
	"mesh.Position": {
		"body": [
			"mesh.Position(${1:position})$0"
		],
		"description": "Sets the position to be used for the next vertex.",
		"prefix": "mesh.Position"
	},
	"mesh.Quad": {
		"body": [
			"mesh.Quad(${1:vertex1}, ${2:vertex2}, ${3:vertex3}, ${4:vertex4})$0"
		],
		"description": "Draws a quad using 4 vertices.",
		"prefix": "mesh.Quad"
	},
	"mesh.QuadEasy": {
		"body": [
			"mesh.QuadEasy(${1:position}, ${2:normal}, ${3:sizeX}, ${4:sizeY})$0"
		],
		"description": "Draws a quad using a position, a normal and the size.",
		"prefix": "mesh.QuadEasy"
	},
	"mesh.Specular": {
		"body": [
			"mesh.Specular(${1:r}, ${2:g}, ${3:b}, ${4:a})$0"
		],
		"description": "Sets the specular map values.\n\nThis function actually does nothing.",
		"prefix": "mesh.Specular"
	},
	"mesh.TangentS": {
		"body": [
			"mesh.TangentS(${1:sTanger})$0"
		],
		"description": "Sets the s tangent to be used.\n\nThis function actually does nothing.",
		"prefix": "mesh.TangentS"
	},
	"mesh.TangentT": {
		"body": [
			"mesh.TangentT(${1:tTanger})$0"
		],
		"description": "Sets the T tangent to be used.\n\nThis function actually does nothing.",
		"prefix": "mesh.TangentT"
	},
	"mesh.TexCoord": {
		"body": [
			"mesh.TexCoord(${1:stage}, ${2:u}, ${3:v})$0"
		],
		"description": "Sets the texture coordinates for the next vertex.\n\nNon-zero values of stage require the currently bound material to support it. For example, any LightmappedGeneric material supports stages 1 and 2 (lightmap texture coordinates).",
		"prefix": "mesh.TexCoord"
	},
	"mesh.UserData": {
		"body": [
			"mesh.UserData(${1:tangentX}, ${2:tangentY}, ${3:tangentZ}, ${4:tangentHandedness})$0"
		],
		"description": "It is recommended to use IMesh:BuildFromTriangles instead of the mesh library.\n\nA table of four numbers. This is used by most shaders in Source to hold tangent information of the vertex ( tangentX, tangentY, tangentZ, tangentHandedness ).",
		"prefix": "mesh.UserData"
	},
	"mesh.VertexCount": {
		"body": [
			"mesh.VertexCount()$0"
		],
		"description": "Returns the amount of vertex that have yet been pushed.",
		"prefix": "mesh.VertexCount"
	},
	"motionsensor.BuildSkeleton": {
		"body": [
			"motionsensor.BuildSkeleton(${1:translator}, ${2:player}, ${3:rotation})$0"
		],
		"description": "",
		"prefix": "motionsensor.BuildSkeleton"
	},
	"motionsensor.ChooseBuilderFromEntity": {
		"body": [
			"motionsensor.ChooseBuilderFromEntity(${1:ent})$0"
		],
		"description": "",
		"prefix": "motionsensor.ChooseBuilderFromEntity"
	},
	"motionsensor.GetColourMaterial": {
		"body": [
			"motionsensor.GetColourMaterial()$0"
		],
		"description": "Returns the depth map material.",
		"prefix": "motionsensor.GetColourMaterial"
	},
	"motionsensor.GetSkeleton": {
		"body": [
			"motionsensor.GetSkeleton()$0"
		],
		"description": "",
		"prefix": "motionsensor.GetSkeleton"
	},
	"motionsensor.IsActive": {
		"body": [
			"motionsensor.IsActive()$0"
		],
		"description": "Return whether a kinect is connected - and active (ie - Start has been called).",
		"prefix": "motionsensor.IsActive"
	},
	"motionsensor.IsAvailable": {
		"body": [
			"motionsensor.IsAvailable()$0"
		],
		"description": "Returns true if we have detected that there's a kinect connected to the PC",
		"prefix": "motionsensor.IsAvailable"
	},
	"motionsensor.ProcessAngle": {
		"body": [
			"motionsensor.ProcessAngle(${1:translator}, ${2:sensor}, ${3:pos}, ${4:ang}, ${5:special_vectors}, ${6:boneid}, ${7:v})$0"
		],
		"description": "",
		"prefix": "motionsensor.ProcessAngle"
	},
	"motionsensor.ProcessAnglesTable": {
		"body": [
			"motionsensor.ProcessAnglesTable(${1:translator}, ${2:sensor}, ${3:pos}, ${4:rotation})$0"
		],
		"description": "",
		"prefix": "motionsensor.ProcessAnglesTable"
	},
	"motionsensor.ProcessPositionTable": {
		"body": [
			"motionsensor.ProcessPositionTable(${1:translator}, ${2:sensor})$0"
		],
		"description": "",
		"prefix": "motionsensor.ProcessPositionTable"
	},
	"motionsensor.Start": {
		"body": [
			"motionsensor.Start()$0"
		],
		"description": "This starts access to the kinect sensor. Note that this usually freezes the game for a couple of seconds.",
		"prefix": "motionsensor.Start"
	},
	"motionsensor.Stop": {
		"body": [
			"motionsensor.Stop()$0"
		],
		"description": "Stops the motion capture.",
		"prefix": "motionsensor.Stop"
	},
	"navmesh.AddWalkableSeed": {
		"body": [
			"navmesh.AddWalkableSeed(${1:pos}, ${2:dir})$0"
		],
		"description": "Add this position and normal to the list of walkable positions, used before map generation with navmesh.BeginGeneration",
		"prefix": "navmesh.AddWalkableSeed"
	},
	"navmesh.BeginGeneration": {
		"body": [
			"navmesh.BeginGeneration()$0"
		],
		"description": "Starts the generation of a new navmesh.\n\nThis process is highly resource intensive and it's not wise to use during normal gameplay",
		"prefix": "navmesh.BeginGeneration"
	},
	"navmesh.ClearWalkableSeeds": {
		"body": [
			"navmesh.ClearWalkableSeeds()$0"
		],
		"description": "Clears all the walkable positions, used before calling navmesh.BeginGeneration.",
		"prefix": "navmesh.ClearWalkableSeeds"
	},
	"navmesh.CreateNavArea": {
		"body": [
			"navmesh.CreateNavArea(${1:corner}, ${2:opposite_corner})$0"
		],
		"description": "Creates a new CNavArea.",
		"prefix": "navmesh.CreateNavArea"
	},
	"navmesh.Find": {
		"body": [
			"navmesh.Find(${1:pos}, ${2:radius}, ${3:stepdown}, ${4:stepup})$0"
		],
		"description": "Returns a bunch of areas within distance, used to find hiding spots by NextBots for example.",
		"prefix": "navmesh.Find"
	},
	"navmesh.GetAllNavAreas": {
		"body": [
			"navmesh.GetAllNavAreas()$0"
		],
		"description": "Returns an integer indexed table of all CNavAreas on the current map. If the map doesn't have a navmesh generated then this will return an empty table.",
		"prefix": "navmesh.GetAllNavAreas"
	},
	"navmesh.GetEditCursorPosition": {
		"body": [
			"navmesh.GetEditCursorPosition()$0"
		],
		"description": "Returns the position of the edit cursor when nav_edit is set to 1.",
		"prefix": "navmesh.GetEditCursorPosition"
	},
	"navmesh.GetGroundHeight": {
		"body": [
			"navmesh.GetGroundHeight(${1:pos})$0"
		],
		"description": "Finds the closest standable ground at, above, or below the provided position.\n\nThe ground must have at least 32 units of empty space above it to be considered by this function, unless 16 layers are tested without finding valid ground.",
		"prefix": "navmesh.GetGroundHeight"
	},
	"navmesh.GetMarkedArea": {
		"body": [
			"navmesh.GetMarkedArea()$0"
		],
		"description": "Returns the currently marked CNavArea, for use with editing console commands.",
		"prefix": "navmesh.GetMarkedArea"
	},
	"navmesh.GetMarkedLadder": {
		"body": [
			"navmesh.GetMarkedLadder()$0"
		],
		"description": "Returns the currently marked CNavLadder, for use with editing console commands.",
		"prefix": "navmesh.GetMarkedLadder"
	},
	"navmesh.GetNavArea": {
		"body": [
			"navmesh.GetNavArea(${1:pos}, ${2:beneathLimit})$0"
		],
		"description": "Returns the Nav Area contained in this position that also satisfies the elevation limit.\n\nThis function will properly see blocked CNavAreas. See navmesh.GetNearestNavArea.",
		"prefix": "navmesh.GetNavArea"
	},
	"navmesh.GetNavAreaByID": {
		"body": [
			"navmesh.GetNavAreaByID(${1:id})$0"
		],
		"description": "Returns a CNavArea by the given ID.\n\nAvoid calling this function every frame, as internally it does a lookup trough all the CNavAreas, call this once and store the result",
		"prefix": "navmesh.GetNavAreaByID"
	},
	"navmesh.GetNavAreaCount": {
		"body": [
			"navmesh.GetNavAreaCount()$0"
		],
		"description": "Returns the highest ID of all nav areas on the map. While this can be used to get all nav areas, this number may not actually be the actual number of nav areas on the map.",
		"prefix": "navmesh.GetNavAreaCount"
	},
	"navmesh.GetNavLadderByID": {
		"body": [
			"navmesh.GetNavLadderByID(${1:id})$0"
		],
		"description": "Returns a CNavLadder by the given ID.",
		"prefix": "navmesh.GetNavLadderByID"
	},
	"navmesh.GetNearestNavArea": {
		"body": [
			"navmesh.GetNearestNavArea(${1:pos}, ${2:anyZ=false}, ${3:maxDist=10000}, ${4:checkLOS=false}, ${5:checkGround=true}, ${6:team=TEAM_ANY=-2})$0"
		],
		"description": "Returns the closest CNavArea to given position at the same height, or beneath it.\n\nThis function will ignore blocked CNavAreas. See navmesh.GetNavArea for a function that does see blocked areas.",
		"prefix": "navmesh.GetNearestNavArea"
	},
	"navmesh.GetPlayerSpawnName": {
		"body": [
			"navmesh.GetPlayerSpawnName()$0"
		],
		"description": "Returns the classname of the player spawn entity.",
		"prefix": "navmesh.GetPlayerSpawnName"
	},
	"navmesh.IsGenerating": {
		"body": [
			"navmesh.IsGenerating()$0"
		],
		"description": "Whether we're currently generating a new navmesh with navmesh.BeginGeneration.",
		"prefix": "navmesh.IsGenerating"
	},
	"navmesh.IsLoaded": {
		"body": [
			"navmesh.IsLoaded()$0"
		],
		"description": "Returns true if a navmesh has been loaded when loading the map.",
		"prefix": "navmesh.IsLoaded"
	},
	"navmesh.Load": {
		"body": [
			"navmesh.Load()$0"
		],
		"description": "Loads a new navmesh from the .nav file for current map discarding any changes made to the navmesh previously.",
		"prefix": "navmesh.Load"
	},
	"navmesh.Reset": {
		"body": [
			"navmesh.Reset()$0"
		],
		"description": "Deletes every CNavArea and CNavLadder on the map **without saving the changes**.",
		"prefix": "navmesh.Reset"
	},
	"navmesh.Save": {
		"body": [
			"navmesh.Save()$0"
		],
		"description": "Saves any changes made to navmesh to the .nav file.",
		"prefix": "navmesh.Save"
	},
	"navmesh.SetMarkedArea": {
		"body": [
			"navmesh.SetMarkedArea(${1:area})$0"
		],
		"description": "Sets the CNavArea as marked, so it can be used with editing console commands.",
		"prefix": "navmesh.SetMarkedArea"
	},
	"navmesh.SetMarkedLadder": {
		"body": [
			"navmesh.SetMarkedLadder(${1:area})$0"
		],
		"description": "Sets the CNavLadder as marked, so it can be used with editing console commands.",
		"prefix": "navmesh.SetMarkedLadder"
	},
	"navmesh.SetPlayerSpawnName": {
		"body": [
			"navmesh.SetPlayerSpawnName(${1:spawnPointClass})$0"
		],
		"description": "Sets the classname of the default spawn point entity, used before generating a new navmesh with navmesh.BeginGeneration.",
		"prefix": "navmesh.SetPlayerSpawnName"
	},
	"net.Broadcast": {
		"body": [
			"net.Broadcast()$0"
		],
		"description": "Sends the currently built net message to all connected players.\nMore information can be found in Net Library Usage.",
		"prefix": "net.Broadcast"
	},
	"net.BytesLeft": {
		"body": [
			"net.BytesLeft()$0"
		],
		"description": "Returns the amount of data left to read in the current message in bytes. Does nothing when sending data.",
		"prefix": "net.BytesLeft"
	},
	"net.BytesWritten": {
		"body": [
			"net.BytesWritten()$0"
		],
		"description": "Returns the size of the current message in bytes.\n\nThis will include 3 extra bytes used by the engine internally to send the data over the network.",
		"prefix": "net.BytesWritten"
	},
	"net.Incoming": {
		"body": [
			"net.Incoming(${1:length}, ${2:client})$0"
		],
		"description": "You may be looking for net.Receive.\nFunction called by the engine to tell the lua state a message arrived.",
		"prefix": "net.Incoming"
	},
	"net.ReadAngle": {
		"body": [
			"net.ReadAngle()$0"
		],
		"description": "Reads an angle from the received net message.\nYou **must** read information in same order as you write it.",
		"prefix": "net.ReadAngle"
	},
	"net.ReadBit": {
		"body": [
			"net.ReadBit()$0"
		],
		"description": "Reads a bit from the received net message.\n\nYou **must** read information in same order as you write it.",
		"prefix": "net.ReadBit"
	},
	"net.ReadBool": {
		"body": [
			"net.ReadBool()$0"
		],
		"description": "Reads a boolean from the received net message.\nYou **must** read information in same order as you write it.",
		"prefix": "net.ReadBool"
	},
	"net.ReadColor": {
		"body": [
			"net.ReadColor()$0"
		],
		"description": "Reads a Color from the current net message.\nYou **must** read information in same order as you write it.",
		"prefix": "net.ReadColor"
	},
	"net.ReadData": {
		"body": [
			"net.ReadData(${1:length})$0"
		],
		"description": "Reads pure binary data from the message.\nYou **must** read information in same order as you write it.",
		"prefix": "net.ReadData"
	},
	"net.ReadDouble": {
		"body": [
			"net.ReadDouble()$0"
		],
		"description": "Reads a double-precision number from the received net message.\nYou **must** read information in same order as you write it.",
		"prefix": "net.ReadDouble"
	},
	"net.ReadEntity": {
		"body": [
			"net.ReadEntity()$0"
		],
		"description": "Reads an entity from the received net message. You should always check if the specified entity exists as it may have been removed and therefor NULL if it is outside of the players PVS or was already removed.\nYou **must** read information in same order as you write it.",
		"prefix": "net.ReadEntity"
	},
	"net.ReadFloat": {
		"body": [
			"net.ReadFloat()$0"
		],
		"description": "Reads a floating point number from the received net message.\n\nYou **must** read information in same order as you write it.",
		"prefix": "net.ReadFloat"
	},
	"net.ReadHeader": {
		"body": [
			"net.ReadHeader()$0"
		],
		"description": "\n\nReads a word, basically unsigned short. This is used internally to read the \"header\" of the message which is an unsigned short which can be converted to the corresponding message name via util.NetworkIDToString.",
		"prefix": "net.ReadHeader"
	},
	"net.ReadInt": {
		"body": [
			"net.ReadInt(${1:bitCount})$0"
		],
		"description": "Reads an integer from the received net message.\nYou **must** read information in same order as you write it.",
		"prefix": "net.ReadInt"
	},
	"net.ReadMatrix": {
		"body": [
			"net.ReadMatrix()$0"
		],
		"description": "Reads a VMatrix from the received net message.\nYou **must** read information in same order as you write it.",
		"prefix": "net.ReadMatrix"
	},
	"net.ReadNormal": {
		"body": [
			"net.ReadNormal()$0"
		],
		"description": "Reads a normal vector from the net message.\nYou **must** read information in same order as you write it.",
		"prefix": "net.ReadNormal"
	},
	"net.ReadString": {
		"body": [
			"net.ReadString()$0"
		],
		"description": "Reads a null terminated string from the net stream. The size of the string is 8 bits plus 8 bits for every ASCII character in the string.\nYou **must** read information in same order as you write it.",
		"prefix": "net.ReadString"
	},
	"net.ReadTable": {
		"body": [
			"net.ReadTable()$0"
		],
		"description": "Reads a table from the received net message.\n\nSometimes when sending a table through the net library, the order of the keys may be switched. So be cautious when comparing (See Example 1).\nYou **must** read information in same order as you write it.\n\nSee net.WriteTable for extra info.\nYou may get `net.ReadType: Couldn't read type X` during the execution of the function, the problem is that you are sending objects that cannot be serialized/sent over the network.",
		"prefix": "net.ReadTable"
	},
	"net.ReadType": {
		"body": [
			"net.ReadType(${1:typeID=net.ReadUInt(8)})$0"
		],
		"description": "Used internally by net.ReadTable.\n\nReads a value from the net message with the specified type, written by net.WriteType.\n\nYou **must** read information in same order as you write it.",
		"prefix": "net.ReadType"
	},
	"net.ReadUInt": {
		"body": [
			"net.ReadUInt(${1:numberOfBits})$0"
		],
		"description": "Reads an unsigned integer with the specified number of bits from the received net message.\nYou **must** read information in same order as you write it.",
		"prefix": "net.ReadUInt"
	},
	"net.ReadVector": {
		"body": [
			"net.ReadVector()$0"
		],
		"description": "Reads a vector from the received net message.  Vectors sent by this function are compressed, which may result in precision loss. See net.WriteVector for more information.\nYou **must** read information in same order as you write it.",
		"prefix": "net.ReadVector"
	},
	"net.Receive": {
		"body": [
			"net.Receive(${1:messageName}, ${2:callback})$0"
		],
		"description": "Adds a net message handler. Only one receiver can be used to receive the net message.\nThe message-name is converted to lower-case so the message-names \"`BigBlue`\" and \"`bigblue`\" would be equal.\nYou **must** put this function **outside** of any other function or hook for it to work properly unless you know what you are doing!\nYou **must** read information in the same order as you write it.\nEach net message has a length limit of 64KB!",
		"prefix": "net.Receive"
	},
	"net.Send": {
		"body": [
			"net.Send(${1:ply})$0"
		],
		"description": "Sends the current message to the specified player, or to all players listed in the table.",
		"prefix": "net.Send"
	},
	"net.SendOmit": {
		"body": [
			"net.SendOmit(${1:ply})$0"
		],
		"description": "Sends the current message to all except the specified, or to all except all players in the table.",
		"prefix": "net.SendOmit"
	},
	"net.SendPAS": {
		"body": [
			"net.SendPAS(${1:position})$0"
		],
		"description": "Sends the message to all players that are in the same potentially audible set(PAS) as the position, or simply said, it adds all players that can potentially hear sounds from this position.",
		"prefix": "net.SendPAS"
	},
	"net.SendPVS": {
		"body": [
			"net.SendPVS(${1:position})$0"
		],
		"description": "Sends the message to all players the position is in the PVS of or, more simply said, sends the message to players that can potentially see this position.",
		"prefix": "net.SendPVS"
	},
	"net.SendToServer": {
		"body": [
			"net.SendToServer()$0"
		],
		"description": "Sends the current message to the server.",
		"prefix": "net.SendToServer"
	},
	"net.Start": {
		"body": [
			"net.Start(${1:messageName}, ${2:unreliable=false})$0"
		],
		"description": "Begins a new net message. If another net message is already started and hasn't been sent yet, it will be discarded.\n\nEach net message has a length limit of 64KB!\n\nThe message name must be pooled with util.AddNetworkString beforehand!\n\nNet messages will not reliably reach the client until the client's GM:InitPostEntity hook is called.",
		"prefix": "net.Start"
	},
	"net.WriteAngle": {
		"body": [
			"net.WriteAngle(${1:angle})$0"
		],
		"description": "Writes an angle to the current net message.",
		"prefix": "net.WriteAngle"
	},
	"net.WriteBit": {
		"body": [
			"net.WriteBit(${1:boolean})$0"
		],
		"description": "Appends a boolean (as 1 or 0) to the current net message.\n\nPlease note that the bit is written here from a boolean (true/false) but net.ReadBit returns a number.",
		"prefix": "net.WriteBit"
	},
	"net.WriteBool": {
		"body": [
			"net.WriteBool(${1:boolean})$0"
		],
		"description": "Appends a boolean to the current net message. Alias of net.WriteBit",
		"prefix": "net.WriteBool"
	},
	"net.WriteColor": {
		"body": [
			"net.WriteColor(${1:Color})$0"
		],
		"description": "Appends a Color to the current net message.",
		"prefix": "net.WriteColor"
	},
	"net.WriteData": {
		"body": [
			"net.WriteData(${1:binaryData}, ${2:length})$0"
		],
		"description": "Writes a chunk of binary data to the message.",
		"prefix": "net.WriteData"
	},
	"net.WriteDouble": {
		"body": [
			"net.WriteDouble(${1:double})$0"
		],
		"description": "Appends a double-precision number to the current net message.",
		"prefix": "net.WriteDouble"
	},
	"net.WriteEntity": {
		"body": [
			"net.WriteEntity(${1:entity})$0"
		],
		"description": "Appends an entity to the current net message.",
		"prefix": "net.WriteEntity"
	},
	"net.WriteFloat": {
		"body": [
			"net.WriteFloat(${1:float})$0"
		],
		"description": "Appends a float (number with decimals) to the current net message.",
		"prefix": "net.WriteFloat"
	},
	"net.WriteInt": {
		"body": [
			"net.WriteInt(${1:integer}, ${2:bitCount})$0"
		],
		"description": "Appends an integer - a whole number - to the current net message. Can be read back with net.ReadInt on the receiving end.\n\nUse net.WriteUInt to send an unsigned number (that you know will never be negative). Use net.WriteFloat for a non-whole number (e.g. 2.25).",
		"prefix": "net.WriteInt"
	},
	"net.WriteMatrix": {
		"body": [
			"net.WriteMatrix(${1:matrix})$0"
		],
		"description": "Writes a VMatrix to the current net message.",
		"prefix": "net.WriteMatrix"
	},
	"net.WriteNormal": {
		"body": [
			"net.WriteNormal(${1:normal})$0"
		],
		"description": "Writes a normalized/direction vector ( Vector with length of 1 ) to the net message.\n\nThis function uses less bandwidth compared to net.WriteVector and will not send vectors with length of > 1 properly.",
		"prefix": "net.WriteNormal"
	},
	"net.WriteString": {
		"body": [
			"net.WriteString(${1:string})$0"
		],
		"description": "Appends a string to the current net message. The size of the string is 8 bits plus 8 bits for every ASCII character in the string. The maximum allowed length of a single written string is 65533 characters.",
		"prefix": "net.WriteString"
	},
	"net.WriteTable": {
		"body": [
			"net.WriteTable(${1:table})$0"
		],
		"description": "Appends a table to the current net message. Adds 16 extra bits per key/value pair so you're better off writing each individual key/value as the exact type if possible.\n\nAll net messages have a 64kb buffer. This function will not check or error when that buffer is overflown. You might want to consider using util.TableToJSON and util.Compress and send the resulting string in 60kb chunks, doing the opposite on the receiving end.",
		"prefix": "net.WriteTable"
	},
	"net.WriteType": {
		"body": [
			"net.WriteType(${1:Data})$0"
		],
		"description": "Used internally by net.WriteTable.\n\nAppends any type of value to the current net message.\n\nAn additional 8-bit unsigned integer indicating the type will automatically be written to the packet before the value, in order to facilitate reading with net.ReadType. If you know the data type you are writing, use a function meant for that specific data type to reduce amount of data sent.",
		"prefix": "net.WriteType"
	},
	"net.WriteUInt": {
		"body": [
			"net.WriteUInt(${1:unsignedInteger}, ${2:numberOfBits})$0"
		],
		"description": "Appends an unsigned integer with the specified number of bits to the current net message.\nUse net.WriteInt if you want to send negative and positive numbers. Use net.WriteFloat for a non-whole number (e.g. 2.25).\nUnsigned numbers do not support negative numbers.",
		"prefix": "net.WriteUInt"
	},
	"net.WriteVector": {
		"body": [
			"net.WriteVector(${1:vector})$0"
		],
		"description": "Appends a vector to the current net message.\nVectors sent by this function are compressed, which may result in precision loss.  XYZ components greater than 16384 or less than -16384 are irrecoverably altered (most significant bits are trimmed) and precision after the decimal point is low.",
		"prefix": "net.WriteVector"
	},
	"notification.AddLegacy": {
		"body": [
			"notification.AddLegacy(${1:text}, ${2:type}, ${3:length})$0"
		],
		"description": "Adds a standard notification to your screen.",
		"prefix": "notification.AddLegacy"
	},
	"notification.AddProgress": {
		"body": [
			"notification.AddProgress(${1:id}, ${2:strText}, ${3:frac=nil})$0"
		],
		"description": "Adds a notification with an animated progress bar.",
		"prefix": "notification.AddProgress"
	},
	"notification.Kill": {
		"body": [
			"notification.Kill(${1:uid})$0"
		],
		"description": "Removes the notification after 0.8 seconds.",
		"prefix": "notification.Kill"
	},
	"numpad.Activate": {
		"body": [
			"numpad.Activate(${1:ply}, ${2:key}, ${3:isButton})$0"
		],
		"description": "Activates numpad key owned by the player",
		"prefix": "numpad.Activate"
	},
	"numpad.Deactivate": {
		"body": [
			"numpad.Deactivate(${1:ply}, ${2:key}, ${3:isButton})$0"
		],
		"description": "Deactivates numpad key owned by the player",
		"prefix": "numpad.Deactivate"
	},
	"numpad.FromButton": {
		"body": [
			"numpad.FromButton()$0"
		],
		"description": "Returns true during a function added with numpad.Register when the third argument to numpad.Activate is true.\n\nThis is caused when a numpad function is triggered by a button SENT being used.",
		"prefix": "numpad.FromButton"
	},
	"numpad.OnDown": {
		"body": [
			"numpad.OnDown(${1:ply}, ${2:key}, ${3:name}, ${4:...})$0"
		],
		"description": "Calls a function registered with numpad.Register when a player presses specified key.\n\nSee for key released action: numpad.OnUp",
		"prefix": "numpad.OnDown"
	},
	"numpad.OnUp": {
		"body": [
			"numpad.OnUp(${1:ply}, ${2:key}, ${3:name}, ${4:...})$0"
		],
		"description": "Calls a function registered with numpad.Register when a player releases specified key.\n\nSee for key pressed action: numpad.OnDown",
		"prefix": "numpad.OnUp"
	},
	"numpad.Register": {
		"body": [
			"numpad.Register(${1:id}, ${2:func})$0"
		],
		"description": "Registers a numpad library action for use with numpad.OnDown and numpad.OnUp",
		"prefix": "numpad.Register"
	},
	"numpad.Remove": {
		"body": [
			"numpad.Remove(${1:ID})$0"
		],
		"description": "Removes a function added by either numpad.OnUp or numpad.OnDown",
		"prefix": "numpad.Remove"
	},
	"numpad.Toggle": {
		"body": [
			"numpad.Toggle(${1:ply}, ${2:key})$0"
		],
		"description": "Either runs numpad.Activate or numpad.Deactivate depending on the key's current state",
		"prefix": "numpad.Toggle"
	},
	"os.clock": {
		"body": [
			"os.clock()$0"
		],
		"description": "Returns the approximate cpu time the application ran.\nSee also Global.SysTime\nThis function has different precision on Linux (1/100).",
		"prefix": "os.clock"
	},
	"os.date": {
		"body": [
			"os.date(${1:format}, ${2:time=os.time()})$0"
		],
		"description": "Returns the date/time as a formatted string or in a table.",
		"prefix": "os.date"
	},
	"os.difftime": {
		"body": [
			"os.difftime(${1:timeA}, ${2:timeB})$0"
		],
		"description": "Subtracts the second from the first value and rounds the result.",
		"prefix": "os.difftime"
	},
	"os.time": {
		"body": [
			"os.time(${1:dateData=nil})$0"
		],
		"description": "Returns the system time in seconds past the unix epoch. If a table is supplied, the function attempts to build a system time with the specified table members.",
		"prefix": "os.time"
	},
	"package.seeall": {
		"body": [
			"package.seeall(${1:module})$0"
		],
		"description": "Sets a metatable for module with its __index field referring to the global environment, so that this module inherits values from the global environment. To be used as an option to Global.module.",
		"prefix": "package.seeall"
	},
	"physenv.AddSurfaceData": {
		"body": [
			"physenv.AddSurfaceData(${1:properties})$0"
		],
		"description": "Adds surface properties to the game's physics environment.\n\nThe game has a limit of 128 surface properties - this includes properties loaded automatically from [surfaceproperties.txt](https://github.com/Facepunch/garrysmod/blob/master/garrysmod/scripts/surfaceproperties.txt). Due to this, there's only a small amount of open slots that can be registered with GMod's provided surfaceproperties.txt.",
		"prefix": "physenv.AddSurfaceData"
	},
	"physenv.GetAirDensity": {
		"body": [
			"physenv.GetAirDensity()$0"
		],
		"description": "Returns the air density.",
		"prefix": "physenv.GetAirDensity"
	},
	"physenv.GetGravity": {
		"body": [
			"physenv.GetGravity()$0"
		],
		"description": "Gets the global gravity.",
		"prefix": "physenv.GetGravity"
	},
	"physenv.GetPerformanceSettings": {
		"body": [
			"physenv.GetPerformanceSettings()$0"
		],
		"description": "Gets the current performance settings in table form.",
		"prefix": "physenv.GetPerformanceSettings"
	},
	"physenv.SetAirDensity": {
		"body": [
			"physenv.SetAirDensity(${1:airDensity})$0"
		],
		"description": "Sets the air density.",
		"prefix": "physenv.SetAirDensity"
	},
	"physenv.SetGravity": {
		"body": [
			"physenv.SetGravity(${1:gravity})$0"
		],
		"description": "Sets the directional gravity, does not work on players.",
		"prefix": "physenv.SetGravity"
	},
	"physenv.SetPerformanceSettings": {
		"body": [
			"physenv.SetPerformanceSettings(${1:performanceSettings})$0"
		],
		"description": "Sets the performance settings.",
		"prefix": "physenv.SetPerformanceSettings"
	},
	"player.CreateNextBot": {
		"body": [
			"player.CreateNextBot(${1:botName})$0"
		],
		"description": "Similar to the serverside command \"bot\", this function creates a new Player bot with the given name. This bot will not obey to the usual \"bot_*\" commands, and it's the same bot base used in TF2 and CS:S.\n\nThe best way to control the behaviour of a Player bot right now is to use the GM:StartCommand hook and modify its input serverside.\n\nDespite this Player being fake, it has to be removed from the server by using Player:Kick and **NOT** Entity:Remove.\nAlso keep in mind that these bots still use player slots, so you won't be able to spawn them in singleplayer!\n\nAny Bot created using this method will be considered UnAuthed by Garry's Mod",
		"prefix": "player.CreateNextBot"
	},
	"player.GetAll": {
		"body": [
			"player.GetAll()$0"
		],
		"description": "Gets all the current players in the server (not including connecting clients).\n\nThis function returns bots as well as human players. See player.GetBots and  player.GetHumans.\nThis function returns a sequential table, meaning it should be looped with Global.ipairs instead of Global.pairs for efficiency reasons.",
		"prefix": "player.GetAll"
	},
	"player.GetBots": {
		"body": [
			"player.GetBots()$0"
		],
		"description": "Returns a table of all bots on the server.",
		"prefix": "player.GetBots"
	},
	"player.GetByAccountID": {
		"body": [
			"player.GetByAccountID(${1:accountID})$0"
		],
		"description": "Gets the player with the specified AccountID.",
		"prefix": "player.GetByAccountID"
	},
	"player.GetByID": {
		"body": [
			"player.GetByID(${1:connectionID})$0"
		],
		"description": "Gets the player with the specified connection ID.\n\nConnection ID can be retrieved via gameevent.Listen events.\n\nFor a function that returns a player based on their Entity:EntIndex, see Global.Entity.\n\n\nFor a function that returns a player based on their Player:UserID, see Global.Player.",
		"prefix": "player.GetByID"
	},
	"player.GetBySteamID": {
		"body": [
			"player.GetBySteamID(${1:steamID})$0"
		],
		"description": "Gets the player with the specified SteamID.",
		"prefix": "player.GetBySteamID"
	},
	"player.GetBySteamID64": {
		"body": [
			"player.GetBySteamID64(${1:steamID64})$0"
		],
		"description": "Gets the player with the specified SteamID64.",
		"prefix": "player.GetBySteamID64"
	},
	"player.GetByUniqueID": {
		"body": [
			"player.GetByUniqueID(${1:uniqueID})$0"
		],
		"description": "Gets the player with the specified uniqueID (not recommended way to identify players).\n\nIt is highly recommended to use player.GetByAccountID, player.GetBySteamID or player.GetBySteamID64 instead as this function can have collisions ( be same for different people ) while SteamID is guaranteed to unique to each player.",
		"prefix": "player.GetByUniqueID"
	},
	"player.GetCount": {
		"body": [
			"player.GetCount()$0"
		],
		"description": "Gives you the player count.\n\nSimilar to **#**player.GetAll() but with better performance since the player table doesn't have to be generated. If player.GetAll is already being called for iteration, then using the **#** operator on the table will be faster than calling this function since it is JITted.",
		"prefix": "player.GetCount"
	},
	"player.GetHumans": {
		"body": [
			"player.GetHumans()$0"
		],
		"description": "Returns a table of all human ( non bot/AI ) players.\n\nUnlike player.GetAll, this does not include bots.",
		"prefix": "player.GetHumans"
	},
	"player_manager.AddValidHands": {
		"body": [
			"player_manager.AddValidHands(${1:name}, ${2:model}, ${3:skin}, ${4:bodygroups})$0"
		],
		"description": "Assigns view model hands to player model.",
		"prefix": "player_manager.AddValidHands"
	},
	"player_manager.AddValidModel": {
		"body": [
			"player_manager.AddValidModel(${1:name}, ${2:model})$0"
		],
		"description": "Associates a simplified name with a path to a valid player model.\n\n\nOnly used internally.",
		"prefix": "player_manager.AddValidModel"
	},
	"player_manager.AllValidModels": {
		"body": [
			"player_manager.AllValidModels()$0"
		],
		"description": "Returns the entire list of valid player models.",
		"prefix": "player_manager.AllValidModels"
	},
	"player_manager.ClearPlayerClass": {
		"body": [
			"player_manager.ClearPlayerClass(${1:ply})$0"
		],
		"description": "Clears a player's class association by setting their ClassID to 0",
		"prefix": "player_manager.ClearPlayerClass"
	},
	"player_manager.GetPlayerClass": {
		"body": [
			"player_manager.GetPlayerClass(${1:ply})$0"
		],
		"description": "Gets a players class",
		"prefix": "player_manager.GetPlayerClass"
	},
	"player_manager.GetPlayerClasses": {
		"body": [
			"player_manager.GetPlayerClasses()$0"
		],
		"description": "Retrieves a copy of all registered player classes.",
		"prefix": "player_manager.GetPlayerClasses"
	},
	"player_manager.OnPlayerSpawn": {
		"body": [
			"player_manager.OnPlayerSpawn(${1:ply})$0"
		],
		"description": "Applies basic class variables when the player spawns.\n\nCalled from GM:PlayerSpawn in the base gamemode.",
		"prefix": "player_manager.OnPlayerSpawn"
	},
	"player_manager.RegisterClass": {
		"body": [
			"player_manager.RegisterClass(${1:name}, ${2:table}, ${3:base})$0"
		],
		"description": "Register a class metatable to be assigned to players later",
		"prefix": "player_manager.RegisterClass"
	},
	"player_manager.RunClass": {
		"body": [
			"player_manager.RunClass(${1:ply}, ${2:funcName}, ${3:arguments})$0"
		],
		"description": "Execute a named function within the player's set class",
		"prefix": "player_manager.RunClass"
	},
	"player_manager.SetPlayerClass": {
		"body": [
			"player_manager.SetPlayerClass(${1:ply}, ${2:classname})$0"
		],
		"description": "Sets a player's class",
		"prefix": "player_manager.SetPlayerClass"
	},
	"player_manager.TranslatePlayerHands": {
		"body": [
			"player_manager.TranslatePlayerHands(${1:name})$0"
		],
		"description": "Retrieves correct hands for given player model. By default returns citizen hands.",
		"prefix": "player_manager.TranslatePlayerHands"
	},
	"player_manager.TranslatePlayerModel": {
		"body": [
			"player_manager.TranslatePlayerModel(${1:shortName})$0"
		],
		"description": "Returns the valid model path for a simplified name.",
		"prefix": "player_manager.TranslatePlayerModel"
	},
	"player_manager.TranslateToPlayerModelName": {
		"body": [
			"player_manager.TranslateToPlayerModelName(${1:model})$0"
		],
		"description": "Returns the simplified name for a valid model path of a player model.\n\nOpposite of player_manager.TranslatePlayerModel.",
		"prefix": "player_manager.TranslateToPlayerModelName"
	},
	"presets.Add": {
		"body": [
			"presets.Add(${1:groupname}, ${2:name}, ${3:values})$0"
		],
		"description": "Adds preset to a preset group.",
		"prefix": "presets.Add"
	},
	"presets.BadNameAlert": {
		"body": [
			"presets.BadNameAlert()$0"
		],
		"description": "\n\nUsed internally to tell the player that the name they tried to use in their preset is not acceptable.",
		"prefix": "presets.BadNameAlert"
	},
	"presets.Exists": {
		"body": [
			"presets.Exists(${1:type}, ${2:name})$0"
		],
		"description": "Returns whether a preset with given name exists or not",
		"prefix": "presets.Exists"
	},
	"presets.GetTable": {
		"body": [
			"presets.GetTable(${1:groupname})$0"
		],
		"description": "Returns a table with preset names and values from a single preset group.",
		"prefix": "presets.GetTable"
	},
	"presets.OverwritePresetPrompt": {
		"body": [
			"presets.OverwritePresetPrompt(${1:callback})$0"
		],
		"description": "\n\nUsed internally to ask the player if they want to override an already existing preset.",
		"prefix": "presets.OverwritePresetPrompt"
	},
	"presets.Remove": {
		"body": [
			"presets.Remove(${1:groupname}, ${2:name})$0"
		],
		"description": "Removes a preset entry from a preset group.",
		"prefix": "presets.Remove"
	},
	"presets.Rename": {
		"body": [
			"presets.Rename(${1:groupname}, ${2:oldname}, ${3:newname})$0"
		],
		"description": "Renames preset.",
		"prefix": "presets.Rename"
	},
	"properties.Add": {
		"body": [
			"properties.Add(${1:name}, ${2:propertyData})$0"
		],
		"description": "Add properties to the properties module",
		"prefix": "properties.Add"
	},
	"properties.CanBeTargeted": {
		"body": [
			"properties.CanBeTargeted(${1:ent}, ${2:ply})$0"
		],
		"description": "Returns true if given entity can be targeted by the player via the properties system.\n\nThis should be used serverside in your properties to prevent abuse by clientside scripting.",
		"prefix": "properties.CanBeTargeted"
	},
	"properties.GetHovered": {
		"body": [
			"properties.GetHovered(${1:pos}, ${2:aimVec})$0"
		],
		"description": "Returns an entity player is hovering over with his cursor.",
		"prefix": "properties.GetHovered"
	},
	"properties.OnScreenClick": {
		"body": [
			"properties.OnScreenClick(${1:eyepos}, ${2:eyevec})$0"
		],
		"description": "Checks if player hovers over any entities and open a properties menu for it.",
		"prefix": "properties.OnScreenClick"
	},
	"properties.OpenEntityMenu": {
		"body": [
			"properties.OpenEntityMenu(${1:ent}, ${2:tr})$0"
		],
		"description": "Opens properties menu for given entity.",
		"prefix": "properties.OpenEntityMenu"
	},
	"render.AddBeam": {
		"body": [
			"render.AddBeam(${1:startPos}, ${2:width}, ${3:textureEnd}, ${4:color})$0"
		],
		"description": "Adds a beam segment to the beam started by render.StartBeam.",
		"prefix": "render.AddBeam"
	},
	"render.BlurRenderTarget": {
		"body": [
			"render.BlurRenderTarget(${1:rendertarget}, ${2:blurx}, ${3:blury}, ${4:passes})$0"
		],
		"description": "Blurs the render target ( or a given texture )",
		"prefix": "render.BlurRenderTarget"
	},
	"render.BrushMaterialOverride": {
		"body": [
			"render.BrushMaterialOverride(${1:mat=nil})$0"
		],
		"description": "This function overrides the brush material for next render operations. It can be used with Entity:DrawModel.",
		"prefix": "render.BrushMaterialOverride"
	},
	"render.Capture": {
		"body": [
			"render.Capture(${1:captureData})$0"
		],
		"description": "Captures a part of the current render target and returns the data as a binary string in the given format.\n\nSince the pixel buffer clears itself every frame, this will return a black screen outside of. To capture the user's final view, use GM:PostRender. This will not capture the Steam overlay or third-party injections (such as the Discord overlay, Overwolf, and advanced cheats) on the user's screen.\n\nThis sets the alpha channel incorrectly in PNG mode, causing the foreground to be rendered almost completely transparent.",
		"prefix": "render.Capture"
	},
	"render.CapturePixels": {
		"body": [
			"render.CapturePixels()$0"
		],
		"description": "Dumps the current render target and allows the pixels to be accessed by render.ReadPixel.",
		"prefix": "render.CapturePixels"
	},
	"render.Clear": {
		"body": [
			"render.Clear(${1:r}, ${2:g}, ${3:b}, ${4:a}, ${5:clearDepth=false}, ${6:clearStencil=false})$0"
		],
		"description": "Clears the current render target and the specified buffers.\n\nThis sets the alpha incorrectly for surface draw calls for render targets.",
		"prefix": "render.Clear"
	},
	"render.ClearBuffersObeyStencil": {
		"body": [
			"render.ClearBuffersObeyStencil(${1:r}, ${2:g}, ${3:b}, ${4:a}, ${5:depth})$0"
		],
		"description": "Clears the current rendertarget for obeying the current stencil buffer conditions.",
		"prefix": "render.ClearBuffersObeyStencil"
	},
	"render.ClearDepth": {
		"body": [
			"render.ClearDepth()$0"
		],
		"description": "Resets the depth buffer.\n\nThis function also clears the stencil buffer. Use render.Clear in the meantime.",
		"prefix": "render.ClearDepth"
	},
	"render.ClearRenderTarget": {
		"body": [
			"render.ClearRenderTarget(${1:texture}, ${2:color})$0"
		],
		"description": "Clears a render target\n\nIt uses render.Clear then render.SetRenderTarget on the modified render target.",
		"prefix": "render.ClearRenderTarget"
	},
	"render.ClearStencil": {
		"body": [
			"render.ClearStencil()$0"
		],
		"description": "Resets all values in the stencil buffer to zero.",
		"prefix": "render.ClearStencil"
	},
	"render.ClearStencilBufferRectangle": {
		"body": [
			"render.ClearStencilBufferRectangle(${1:originX}, ${2:originY}, ${3:endX}, ${4:endY}, ${5:stencilValue})$0"
		],
		"description": "Sets the stencil value in a specified rect.\n\nThis is **not** affected by render.SetStencilWriteMask",
		"prefix": "render.ClearStencilBufferRectangle"
	},
	"render.ComputeDynamicLighting": {
		"body": [
			"render.ComputeDynamicLighting(${1:position}, ${2:normal})$0"
		],
		"description": "Calculates the lighting caused by dynamic lights for the specified surface.",
		"prefix": "render.ComputeDynamicLighting"
	},
	"render.ComputeLighting": {
		"body": [
			"render.ComputeLighting(${1:position}, ${2:normal})$0"
		],
		"description": "Calculates the light color of a certain surface.",
		"prefix": "render.ComputeLighting"
	},
	"render.CopyRenderTargetToTexture": {
		"body": [
			"render.CopyRenderTargetToTexture(${1:Target})$0"
		],
		"description": "Copies the currently active Render Target to the specified texture.",
		"prefix": "render.CopyRenderTargetToTexture"
	},
	"render.CopyTexture": {
		"body": [
			"render.CopyTexture(${1:texture_from}, ${2:texture_to})$0"
		],
		"description": "Copies the contents of one texture to another. Only works with rendertargets.",
		"prefix": "render.CopyTexture"
	},
	"render.CullMode": {
		"body": [
			"render.CullMode(${1:cullMode})$0"
		],
		"description": "Changes the cull mode.",
		"prefix": "render.CullMode"
	},
	"render.DepthRange": {
		"body": [
			"render.DepthRange(${1:depthmin}, ${2:depthmax})$0"
		],
		"description": "Set's the depth range of the upcoming render.",
		"prefix": "render.DepthRange"
	},
	"render.DrawBeam": {
		"body": [
			"render.DrawBeam(${1:startPos}, ${2:endPos}, ${3:width}, ${4:textureStart}, ${5:textureEnd}, ${6:color=Color( 255, 255, 255 )})$0"
		],
		"description": "Draws textured beam.\n\n",
		"prefix": "render.DrawBeam"
	},
	"render.DrawBox": {
		"body": [
			"render.DrawBox(${1:position}, ${2:angles}, ${3:mins}, ${4:maxs}, ${5:color=Color( 255, 255, 255 )})$0"
		],
		"description": "Draws a box in 3D space.\n\n",
		"prefix": "render.DrawBox"
	},
	"render.DrawLine": {
		"body": [
			"render.DrawLine(${1:startPos}, ${2:endPos}, ${3:color=Color( 255, 255, 255 )}, ${4:writeZ=false})$0"
		],
		"description": "Draws a line in 3D space.\n\n",
		"prefix": "render.DrawLine"
	},
	"render.DrawQuad": {
		"body": [
			"render.DrawQuad(${1:vert1}, ${2:vert2}, ${3:vert3}, ${4:vert4}, ${5:color=Color( 255, 255, 255 )})$0"
		],
		"description": "Draws 2 connected triangles. Expects material to be set by render.SetMaterial.\n\n",
		"prefix": "render.DrawQuad"
	},
	"render.DrawQuadEasy": {
		"body": [
			"render.DrawQuadEasy(${1:position}, ${2:normal}, ${3:width}, ${4:height}, ${5:color}, ${6:rotation=0})$0"
		],
		"description": "Draws a quad.\n\n",
		"prefix": "render.DrawQuadEasy"
	},
	"render.DrawScreenQuad": {
		"body": [
			"render.DrawScreenQuad(${1:applyPoster=false})$0"
		],
		"description": "Draws the current material set by render.SetMaterial to the whole screen. The color cannot be customized.\n\nSee also render.DrawScreenQuadEx.\n\n",
		"prefix": "render.DrawScreenQuad"
	},
	"render.DrawScreenQuadEx": {
		"body": [
			"render.DrawScreenQuadEx(${1:startX}, ${2:startY}, ${3:width}, ${4:height})$0"
		],
		"description": "Draws the the current material set by render.SetMaterial to the area specified. Color cannot be customized.\n\nSee also render.DrawScreenQuad.\n\n",
		"prefix": "render.DrawScreenQuadEx"
	},
	"render.DrawSphere": {
		"body": [
			"render.DrawSphere(${1:position}, ${2:radius}, ${3:longitudeSteps}, ${4:latitudeSteps}, ${5:color=Color( 255, 255, 255 )})$0"
		],
		"description": "Draws a sphere in 3D space. The material previously set with render.SetMaterial will be applied the sphere's surface.\n\nSee also render.DrawWireframeSphere for a wireframe equivalent.\n\n",
		"prefix": "render.DrawSphere"
	},
	"render.DrawSprite": {
		"body": [
			"render.DrawSprite(${1:position}, ${2:width}, ${3:height}, ${4:color=Color( 255, 255, 255 )})$0"
		],
		"description": "Draws a sprite in 3D space.\n\n",
		"prefix": "render.DrawSprite"
	},
	"render.DrawTextureToScreen": {
		"body": [
			"render.DrawTextureToScreen(${1:tex})$0"
		],
		"description": "Draws a texture over the whole screen.\n\n",
		"prefix": "render.DrawTextureToScreen"
	},
	"render.DrawTextureToScreenRect": {
		"body": [
			"render.DrawTextureToScreenRect(${1:tex}, ${2:x}, ${3:y}, ${4:width}, ${5:height})$0"
		],
		"description": "Draws a textured rectangle.\n\n",
		"prefix": "render.DrawTextureToScreenRect"
	},
	"render.DrawWireframeBox": {
		"body": [
			"render.DrawWireframeBox(${1:position}, ${2:angle}, ${3:mins}, ${4:maxs}, ${5:color=Color( 255, 255, 255 )}, ${6:writeZ=false})$0"
		],
		"description": "Draws a wireframe box in 3D space.\n\n",
		"prefix": "render.DrawWireframeBox"
	},
	"render.DrawWireframeSphere": {
		"body": [
			"render.DrawWireframeSphere(${1:position}, ${2:radius}, ${3:longitudeSteps}, ${4:latitudeSteps}, ${5:color=Color( 255, 255, 255 )}, ${6:writeZ=false})$0"
		],
		"description": "Draws a wireframe sphere in 3d space.\n\n",
		"prefix": "render.DrawWireframeSphere"
	},
	"render.EnableClipping": {
		"body": [
			"render.EnableClipping(${1:state})$0"
		],
		"description": "Sets the status of the clip renderer, returning previous state.\n\nTo prevent unintended rendering behavior of other mods/the game, you must reset the clipping state to its previous value.\n\nReloading the map does not reset the previous value of this function.",
		"prefix": "render.EnableClipping"
	},
	"render.EndBeam": {
		"body": [
			"render.EndBeam()$0"
		],
		"description": "Ends the beam mesh of a beam started with render.StartBeam.",
		"prefix": "render.EndBeam"
	},
	"render.FogColor": {
		"body": [
			"render.FogColor(${1:red}, ${2:green}, ${3:blue})$0"
		],
		"description": "Sets the color of the fog.",
		"prefix": "render.FogColor"
	},
	"render.FogEnd": {
		"body": [
			"render.FogEnd(${1:distance})$0"
		],
		"description": "Sets the at which the fog reaches its max density.",
		"prefix": "render.FogEnd"
	},
	"render.FogMaxDensity": {
		"body": [
			"render.FogMaxDensity(${1:maxDensity})$0"
		],
		"description": "Sets the maximum density of the fog.",
		"prefix": "render.FogMaxDensity"
	},
	"render.FogMode": {
		"body": [
			"render.FogMode(${1:fogMode})$0"
		],
		"description": "Sets the mode of fog.",
		"prefix": "render.FogMode"
	},
	"render.FogStart": {
		"body": [
			"render.FogStart(${1:fogStart})$0"
		],
		"description": "Sets the distance at which the fog starts showing up.",
		"prefix": "render.FogStart"
	},
	"render.GetAmbientLightColor": {
		"body": [
			"render.GetAmbientLightColor()$0"
		],
		"description": "Returns the ambient color of the map.",
		"prefix": "render.GetAmbientLightColor"
	},
	"render.GetBlend": {
		"body": [
			"render.GetBlend()$0"
		],
		"description": "Returns the current alpha blending.",
		"prefix": "render.GetBlend"
	},
	"render.GetBloomTex0": {
		"body": [
			"render.GetBloomTex0()$0"
		],
		"description": "",
		"prefix": "render.GetBloomTex0"
	},
	"render.GetBloomTex1": {
		"body": [
			"render.GetBloomTex1()$0"
		],
		"description": "",
		"prefix": "render.GetBloomTex1"
	},
	"render.GetColorModulation": {
		"body": [
			"render.GetColorModulation()$0"
		],
		"description": "Returns the current color modulation values as normals.",
		"prefix": "render.GetColorModulation"
	},
	"render.GetDXLevel": {
		"body": [
			"render.GetDXLevel()$0"
		],
		"description": "Returns the maximum available directX version.",
		"prefix": "render.GetDXLevel"
	},
	"render.GetFogColor": {
		"body": [
			"render.GetFogColor()$0"
		],
		"description": "Returns the current fog color.",
		"prefix": "render.GetFogColor"
	},
	"render.GetFogDistances": {
		"body": [
			"render.GetFogDistances()$0"
		],
		"description": "Returns the fog start and end distance.",
		"prefix": "render.GetFogDistances"
	},
	"render.GetFogMode": {
		"body": [
			"render.GetFogMode()$0"
		],
		"description": "Returns the fog mode.",
		"prefix": "render.GetFogMode"
	},
	"render.GetFullScreenDepthTexture": {
		"body": [
			"render.GetFullScreenDepthTexture()$0"
		],
		"description": "Returns the _rt_FullFrameDepth texture. Alias of _rt_PowerOfTwoFB",
		"prefix": "render.GetFullScreenDepthTexture"
	},
	"render.GetHDREnabled": {
		"body": [
			"render.GetHDREnabled()$0"
		],
		"description": "Returns whether HDR is currently enabled or not. This takes into account hardware support, current map and current client settings.",
		"prefix": "render.GetHDREnabled"
	},
	"render.GetLightColor": {
		"body": [
			"render.GetLightColor(${1:position})$0"
		],
		"description": "Gets the light exposure on the specified position.",
		"prefix": "render.GetLightColor"
	},
	"render.GetMoBlurTex0": {
		"body": [
			"render.GetMoBlurTex0()$0"
		],
		"description": "",
		"prefix": "render.GetMoBlurTex0"
	},
	"render.GetMoBlurTex1": {
		"body": [
			"render.GetMoBlurTex1()$0"
		],
		"description": "",
		"prefix": "render.GetMoBlurTex1"
	},
	"render.GetMorphTex0": {
		"body": [
			"render.GetMorphTex0()$0"
		],
		"description": "",
		"prefix": "render.GetMorphTex0"
	},
	"render.GetMorphTex1": {
		"body": [
			"render.GetMorphTex1()$0"
		],
		"description": "",
		"prefix": "render.GetMorphTex1"
	},
	"render.GetPowerOfTwoTexture": {
		"body": [
			"render.GetPowerOfTwoTexture()$0"
		],
		"description": "Returns the render target's power of two texture.",
		"prefix": "render.GetPowerOfTwoTexture"
	},
	"render.GetRefractTexture": {
		"body": [
			"render.GetRefractTexture()$0"
		],
		"description": "Alias of render.GetPowerOfTwoTexture.",
		"prefix": "render.GetRefractTexture"
	},
	"render.GetRenderTarget": {
		"body": [
			"render.GetRenderTarget()$0"
		],
		"description": "Returns the currently active render target.\n\nInstead of saving the current render target using this function and restoring to it later, it is generally better practice to use render.PushRenderTarget and render.PopRenderTarget.",
		"prefix": "render.GetRenderTarget"
	},
	"render.GetResolvedFullFrameDepth": {
		"body": [
			"render.GetResolvedFullFrameDepth()$0"
		],
		"description": "Returns the _rt_ResolvedFullFrameDepth texture for SSAO depth.",
		"prefix": "render.GetResolvedFullFrameDepth"
	},
	"render.GetScreenEffectTexture": {
		"body": [
			"render.GetScreenEffectTexture(${1:textureIndex=0})$0"
		],
		"description": "Obtain an ITexture of the screen. You must call render.UpdateScreenEffectTexture in order to update this texture with the currently rendered scene.\n\nThis texture is mainly used within GM:RenderScreenspaceEffects",
		"prefix": "render.GetScreenEffectTexture"
	},
	"render.GetSmallTex0": {
		"body": [
			"render.GetSmallTex0()$0"
		],
		"description": "",
		"prefix": "render.GetSmallTex0"
	},
	"render.GetSmallTex1": {
		"body": [
			"render.GetSmallTex1()$0"
		],
		"description": "",
		"prefix": "render.GetSmallTex1"
	},
	"render.GetSuperFPTex": {
		"body": [
			"render.GetSuperFPTex()$0"
		],
		"description": "Returns a floating point texture the same resolution as the screen.\n\nThe gmodscreenspace doesn't behave as expected when drawing a floating-point texture to an integer texture (e.g. the default render target). Use an UnlitGeneric material instead",
		"prefix": "render.GetSuperFPTex"
	},
	"render.GetSuperFPTex2": {
		"body": [
			"render.GetSuperFPTex2()$0"
		],
		"description": "See render.GetSuperFPTex",
		"prefix": "render.GetSuperFPTex2"
	},
	"render.GetSurfaceColor": {
		"body": [
			"render.GetSurfaceColor(${1:startPos}, ${2:endPos})$0"
		],
		"description": "Performs a render trace and returns the color of the surface hit, this uses a low res version of the texture.",
		"prefix": "render.GetSurfaceColor"
	},
	"render.GetToneMappingScaleLinear": {
		"body": [
			"render.GetToneMappingScaleLinear()$0"
		],
		"description": "Returns a vector representing linear tone mapping scale.",
		"prefix": "render.GetToneMappingScaleLinear"
	},
	"render.MaterialOverride": {
		"body": [
			"render.MaterialOverride(${1:material})$0"
		],
		"description": "Sets the render material override for all next calls of Entity:DrawModel. Also overrides render.MaterialOverrideByIndex.",
		"prefix": "render.MaterialOverride"
	},
	"render.MaterialOverrideByIndex": {
		"body": [
			"render.MaterialOverrideByIndex(${1:index}, ${2:material})$0"
		],
		"description": "Similar to render.MaterialOverride, but overrides the materials per index.\n\nrender.MaterialOverride overrides effects of this function.",
		"prefix": "render.MaterialOverrideByIndex"
	},
	"render.MaxTextureHeight": {
		"body": [
			"render.MaxTextureHeight()$0"
		],
		"description": "Returns the maximum texture height the renderer can handle.",
		"prefix": "render.MaxTextureHeight"
	},
	"render.MaxTextureWidth": {
		"body": [
			"render.MaxTextureWidth()$0"
		],
		"description": "Returns the maximum texture width the renderer can handle.",
		"prefix": "render.MaxTextureWidth"
	},
	"render.Model": {
		"body": [
			"render.Model(${1:settings}, ${2:ent=nil})$0"
		],
		"description": "Creates a new Global.ClientsideModel, renders it at the specified pos/ang, and removes it. Can also be given an existing CSEnt to reuse instead.\n\nThis function is only meant to be used in a single render pass kind of scenario, if you need to render a model continuously, use a cached Global.ClientsideModel and provide it as a second argument.\n\nUsing this with a map model (game.GetWorld():Entity:GetModel()) crashes the game.",
		"prefix": "render.Model"
	},
	"render.ModelMaterialOverride": {
		"body": [
			"render.ModelMaterialOverride(${1:material})$0"
		],
		"description": "Sets a material to override a model's default material. Similar to Entity:SetMaterial except it uses an IMaterial argument and it can be used to change materials on models which are part of the world geometry.",
		"prefix": "render.ModelMaterialOverride"
	},
	"render.OverrideAlphaWriteEnable": {
		"body": [
			"render.OverrideAlphaWriteEnable(${1:enable}, ${2:shouldWrite})$0"
		],
		"description": "Overrides the write behaviour of all next rendering operations towards the alpha channel of the current render target.\n\nSee also render.OverrideBlend.\n\nDoing surface draw calls with alpha set to 0 is a no-op and will never have any effect.",
		"prefix": "render.OverrideAlphaWriteEnable"
	},
	"render.OverrideBlend": {
		"body": [
			"render.OverrideBlend(${1:enabled}, ${2:srcBlend}, ${3:destBlend}, ${4:blendFunc}, ${5:srcBlendAlpha=none}, ${6:destBlendAlpha=none}, ${7:blendFuncAlpha=none})$0"
		],
		"description": "Overrides the internal graphical functions used to determine the final color and alpha of a rendered texture.\n\nSee also render.OverrideAlphaWriteEnable.\n\nDoing surface draw calls with alpha set to 0 is a no-op and won't have an effect.",
		"prefix": "render.OverrideBlend"
	},
	"render.OverrideBlendFunc": {
		"body": [
			"render.OverrideBlendFunc(${1:enabled}, ${2:srcBlend}, ${3:destBlend}, ${4:srcBlendAlpha=nil}, ${5:destBlendAlpha=nil})$0"
		],
		"description": "Use render.OverrideBlend instead.\n\nOverrides the internal graphical functions used to determine the final color and alpha of a rendered texture.\n\nSee also render.OverrideAlphaWriteEnable.\n\nDoing surface draw calls with alpha set to 0 is a no-op and will never have any effect.",
		"prefix": "render.OverrideBlendFunc"
	},
	"render.OverrideColorWriteEnable": {
		"body": [
			"render.OverrideColorWriteEnable(${1:enable}, ${2:shouldWrite})$0"
		],
		"description": "Overrides the write behaviour of all next rendering operations towards the color channel of the current render target.",
		"prefix": "render.OverrideColorWriteEnable"
	},
	"render.OverrideDepthEnable": {
		"body": [
			"render.OverrideDepthEnable(${1:enable}, ${2:shouldWrite})$0"
		],
		"description": "Overrides the write behaviour of all next rendering operations towards the depth buffer.",
		"prefix": "render.OverrideDepthEnable"
	},
	"render.PerformFullScreenStencilOperation": {
		"body": [
			"render.PerformFullScreenStencilOperation()$0"
		],
		"description": "",
		"prefix": "render.PerformFullScreenStencilOperation"
	},
	"render.PopCustomClipPlane": {
		"body": [
			"render.PopCustomClipPlane()$0"
		],
		"description": "Removes the current active clipping plane from the clip plane stack.",
		"prefix": "render.PopCustomClipPlane"
	},
	"render.PopFilterMag": {
		"body": [
			"render.PopFilterMag()$0"
		],
		"description": "Pops the current texture magnification filter from the filter stack.\n\nSee render.PushFilterMag",
		"prefix": "render.PopFilterMag"
	},
	"render.PopFilterMin": {
		"body": [
			"render.PopFilterMin()$0"
		],
		"description": "Pops the current texture minification filter from the filter stack.\n\nSee render.PushFilterMin",
		"prefix": "render.PopFilterMin"
	},
	"render.PopFlashlightMode": {
		"body": [
			"render.PopFlashlightMode()$0"
		],
		"description": "Pops the current flashlight mode from the flashlight mode stack.",
		"prefix": "render.PopFlashlightMode"
	},
	"render.PopRenderTarget": {
		"body": [
			"render.PopRenderTarget()$0"
		],
		"description": "Pops the last render target and viewport from the RT stack and sets them as the current render target and viewport.\n\nThis is should be called to restore the previous render target and viewport after a call to render.PushRenderTarget.",
		"prefix": "render.PopRenderTarget"
	},
	"render.PushCustomClipPlane": {
		"body": [
			"render.PushCustomClipPlane(${1:normal}, ${2:distance})$0"
		],
		"description": "Pushes a new clipping plane of the clip plane stack and sets it as active.\n\nA max of 2 clip planes are supported on Linux/POSIX, and 6 on Windows.",
		"prefix": "render.PushCustomClipPlane"
	},
	"render.PushFilterMag": {
		"body": [
			"render.PushFilterMag(${1:texFilterType})$0"
		],
		"description": "Pushes a texture filter onto the magnification texture filter stack.",
		"prefix": "render.PushFilterMag"
	},
	"render.PushFilterMin": {
		"body": [
			"render.PushFilterMin(${1:texFilterType})$0"
		],
		"description": "Pushes a texture filter onto the minification texture filter stack.",
		"prefix": "render.PushFilterMin"
	},
	"render.PushFlashlightMode": {
		"body": [
			"render.PushFlashlightMode(${1:enable=false})$0"
		],
		"description": "Enables the flashlight projection for the upcoming rendering.\n\nThis will leave models lit under specific conditions.",
		"prefix": "render.PushFlashlightMode"
	},
	"render.PushRenderTarget": {
		"body": [
			"render.PushRenderTarget(${1:texture}, ${2:x=0}, ${3:y=0}, ${4:w=texture:Width()}, ${5:h=texture:Height()})$0"
		],
		"description": "Pushes the current render target and viewport to the RT stack then sets a new current render target and viewport. If the viewport is not specified, the dimensions of the render target are used instead.\n\nThis is similar to a call to render.SetRenderTarget and render.SetViewPort where the current render target and viewport have been saved beforehand, except the viewport isn't clipped to screen bounds.\n\nSee also render.PopRenderTarget.\n\nIf you want to render to the render target in 2d mode and it is not the same size as the screen, use cam.Start2D and cam.End2D.\nIf the render target is bigger than the screen, rendering done with the surface library will be clipped to the screen bounds unless you call Global.DisableClipping",
		"prefix": "render.PushRenderTarget"
	},
	"render.ReadPixel": {
		"body": [
			"render.ReadPixel(${1:x}, ${2:y})$0"
		],
		"description": "Reads the color of the specified pixel from the RenderTarget sent by render.CapturePixels",
		"prefix": "render.ReadPixel"
	},
	"render.RedownloadAllLightmaps": {
		"body": [
			"render.RedownloadAllLightmaps(${1:DoStaticProps=false}, ${2:UpdateStaticLighting=false})$0"
		],
		"description": "This applies the changes made to map lighting using engine.LightStyle.",
		"prefix": "render.RedownloadAllLightmaps"
	},
	"render.RenderHUD": {
		"body": [
			"render.RenderHUD(${1:x}, ${2:y}, ${3:w}, ${4:h})$0"
		],
		"description": "Renders the HUD on the screen.",
		"prefix": "render.RenderHUD"
	},
	"render.RenderView": {
		"body": [
			"render.RenderView(${1:view=nil})$0"
		],
		"description": "Renders the scene with the specified viewData to the current active render target.\n\nStatic props and LODs are rendered improperly due to incorrectly perceived distance.",
		"prefix": "render.RenderView"
	},
	"render.ResetModelLighting": {
		"body": [
			"render.ResetModelLighting(${1:r}, ${2:g}, ${3:b})$0"
		],
		"description": "Resets the model lighting to the specified color.\n\nCalls render.SetModelLighting for every direction with given color.",
		"prefix": "render.ResetModelLighting"
	},
	"render.ResetToneMappingScale": {
		"body": [
			"render.ResetToneMappingScale(${1:scale})$0"
		],
		"description": "Resets the HDR tone multiplier to the specified value.\n\nThis will only work on HDR maps, and the value will automatically fade to what it was ( or whatever render.SetGoalToneMappingScale is ) if called only once.",
		"prefix": "render.ResetToneMappingScale"
	},
	"render.SetAmbientLight": {
		"body": [
			"render.SetAmbientLight(${1:r}, ${2:g}, ${3:b})$0"
		],
		"description": "Sets the ambient lighting for any upcoming render operation.",
		"prefix": "render.SetAmbientLight"
	},
	"render.SetBlend": {
		"body": [
			"render.SetBlend(${1:blending})$0"
		],
		"description": "Sets the alpha blending for every upcoming render operation.\n\nThis does not affect non-model render.Draw* functions.",
		"prefix": "render.SetBlend"
	},
	"render.SetColorMaterial": {
		"body": [
			"render.SetColorMaterial()$0"
		],
		"description": "Sets the current drawing material to \"color\".\n\nThe material is defined as:\n```\n\n\"UnlitGeneric\"\n{\n\"$basetexture\" \"color/white\"\n\"$model\" \t\t1\n\"$translucent\" \t1\n\"$vertexalpha\" \t1\n\"$vertexcolor\" \t1\n}\n```",
		"prefix": "render.SetColorMaterial"
	},
	"render.SetColorMaterialIgnoreZ": {
		"body": [
			"render.SetColorMaterialIgnoreZ()$0"
		],
		"description": "Sets the current drawing material to \"color_ignorez\".\n\nThe material is defined as:\n```\n\n\"UnlitGeneric\"\n{\n\"$basetexture\" \"color/white\"\n\"$model\" \t\t1\n\"$translucent\" \t1\n\"$vertexalpha\" \t1\n\"$vertexcolor\" \t1\n\"$ignorez\"\t\t1\n}\n```",
		"prefix": "render.SetColorMaterialIgnoreZ"
	},
	"render.SetColorModulation": {
		"body": [
			"render.SetColorModulation(${1:r}, ${2:g}, ${3:b})$0"
		],
		"description": "Sets the color modulation.",
		"prefix": "render.SetColorModulation"
	},
	"render.SetFogZ": {
		"body": [
			"render.SetFogZ(${1:fogZ})$0"
		],
		"description": "If the fog mode is set to Enums/MATERIAL_FOG, the fog will only be rendered below the specified height.",
		"prefix": "render.SetFogZ"
	},
	"render.SetGoalToneMappingScale": {
		"body": [
			"render.SetGoalToneMappingScale(${1:scale})$0"
		],
		"description": "Sets the goal HDR tone mapping scale.\n\nUse this in a rendering/think hook as it is reset every frame.",
		"prefix": "render.SetGoalToneMappingScale"
	},
	"render.SetLightingMode": {
		"body": [
			"render.SetLightingMode(${1:Mode})$0"
		],
		"description": "Sets lighting mode when rendering something.\n\n**Do not forget to restore the default value** to avoid unexpected behavior, like the world and the HUD/UI being affected",
		"prefix": "render.SetLightingMode"
	},
	"render.SetLightingOrigin": {
		"body": [
			"render.SetLightingOrigin(${1:lightingOrigin})$0"
		],
		"description": "Sets the lighting origin.\n\nThis does not work for prop_physics.",
		"prefix": "render.SetLightingOrigin"
	},
	"render.SetLightmapTexture": {
		"body": [
			"render.SetLightmapTexture(${1:tex})$0"
		],
		"description": "Sets the texture to be used as the lightmap in upcoming rendering operations. This is required when rendering meshes using a material with a lightmapped shader such as LightmappedGeneric.\n\n\n",
		"prefix": "render.SetLightmapTexture"
	},
	"render.SetLocalModelLights": {
		"body": [
			"render.SetLocalModelLights(${1:lights={}})$0"
		],
		"description": "Sets up the local lighting for any upcoming render operation. Up to 4 local lights can be defined, with one of three different types (point, directional, spot).\n\nDisables all local lights if called with no arguments.",
		"prefix": "render.SetLocalModelLights"
	},
	"render.SetMaterial": {
		"body": [
			"render.SetMaterial(${1:mat})$0"
		],
		"description": "Sets the material to be used in any upcoming render operation using the render.\n\nNot to be confused with surface.SetMaterial.\n\n\n",
		"prefix": "render.SetMaterial"
	},
	"render.SetModelLighting": {
		"body": [
			"render.SetModelLighting(${1:lightDirection}, ${2:red}, ${3:green}, ${4:blue})$0"
		],
		"description": "Sets up the ambient lighting for any upcoming render operation. Ambient lighting can be seen as a cube enclosing the object to be drawn, each of its faces representing a directional light source that shines towards the object. Thus, there is a total of six different light sources that can be configured separately.\n\nLight color components are not restricted to a specific range (i.e. 0-255), instead, higher values will result in a brighter light.",
		"prefix": "render.SetModelLighting"
	},
	"render.SetRenderTarget": {
		"body": [
			"render.SetRenderTarget(${1:texture})$0"
		],
		"description": "Sets the render target to the specified rt.",
		"prefix": "render.SetRenderTarget"
	},
	"render.SetRenderTargetEx": {
		"body": [
			"render.SetRenderTargetEx(${1:rtIndex}, ${2:texture})$0"
		],
		"description": "Sets the render target with the specified index to the specified rt.",
		"prefix": "render.SetRenderTargetEx"
	},
	"render.SetScissorRect": {
		"body": [
			"render.SetScissorRect(${1:startX}, ${2:startY}, ${3:endX}, ${4:endY}, ${5:enable})$0"
		],
		"description": "Sets a scissoring rect which limits the drawing area.",
		"prefix": "render.SetScissorRect"
	},
	"render.SetShadowColor": {
		"body": [
			"render.SetShadowColor(${1:red}, ${2:green}, ${3:blue})$0"
		],
		"description": "Sets the shadow color.",
		"prefix": "render.SetShadowColor"
	},
	"render.SetShadowDirection": {
		"body": [
			"render.SetShadowDirection(${1:shadowDirections})$0"
		],
		"description": "Sets the shadow projection direction.",
		"prefix": "render.SetShadowDirection"
	},
	"render.SetShadowDistance": {
		"body": [
			"render.SetShadowDistance(${1:shadowDistance})$0"
		],
		"description": "Sets the maximum shadow projection range.",
		"prefix": "render.SetShadowDistance"
	},
	"render.SetShadowsDisabled": {
		"body": [
			"render.SetShadowsDisabled(${1:newState})$0"
		],
		"description": "Sets whether any future render operations will ignore shadow drawing.",
		"prefix": "render.SetShadowsDisabled"
	},
	"render.SetStencilCompareFunction": {
		"body": [
			"render.SetStencilCompareFunction(${1:compareFunction})$0"
		],
		"description": "Sets the compare function of the stencil.\n\nPixels which fail the stencil comparison function are not written to the render target. The operation to be performed on the stencil buffer values for these pixels can be set using render.SetStencilFailOperation.\n\nPixels which pass the stencil comparison function are written to the render target unless they fail the depth buffer test (where applicable). The operation to perform on the stencil buffer values for these pixels can be set using render.SetStencilPassOperation and render.SetStencilZFailOperation.",
		"prefix": "render.SetStencilCompareFunction"
	},
	"render.SetStencilEnable": {
		"body": [
			"render.SetStencilEnable(${1:newState})$0"
		],
		"description": "Sets whether stencil tests are carried out for each rendered pixel.\n\nOnly pixels passing the stencil test are written to the render target.",
		"prefix": "render.SetStencilEnable"
	},
	"render.SetStencilFailOperation": {
		"body": [
			"render.SetStencilFailOperation(${1:failOperation})$0"
		],
		"description": "Sets the operation to be performed on the stencil buffer values if the compare function was not successful.\nNote that this takes place **before** depth testing.",
		"prefix": "render.SetStencilFailOperation"
	},
	"render.SetStencilPassOperation": {
		"body": [
			"render.SetStencilPassOperation(${1:passOperation})$0"
		],
		"description": "Sets the operation to be performed on the stencil buffer values if the compare function was successful.",
		"prefix": "render.SetStencilPassOperation"
	},
	"render.SetStencilReferenceValue": {
		"body": [
			"render.SetStencilReferenceValue(${1:referenceValue})$0"
		],
		"description": "Sets the reference value which will be used for all stencil operations. This is an unsigned integer.",
		"prefix": "render.SetStencilReferenceValue"
	},
	"render.SetStencilTestMask": {
		"body": [
			"render.SetStencilTestMask(${1:mask})$0"
		],
		"description": "Sets the unsigned 8-bit test bitflag mask to be used for any stencil testing.",
		"prefix": "render.SetStencilTestMask"
	},
	"render.SetStencilWriteMask": {
		"body": [
			"render.SetStencilWriteMask(${1:mask})$0"
		],
		"description": "Sets the unsigned 8-bit write bitflag mask to be used for any writes to the stencil buffer.",
		"prefix": "render.SetStencilWriteMask"
	},
	"render.SetStencilZFailOperation": {
		"body": [
			"render.SetStencilZFailOperation(${1:zFailOperation})$0"
		],
		"description": "Sets the operation to be performed on the stencil buffer values if the stencil test is passed but the depth buffer test fails.",
		"prefix": "render.SetStencilZFailOperation"
	},
	"render.SetToneMappingScaleLinear": {
		"body": [
			"render.SetToneMappingScaleLinear(${1:vec})$0"
		],
		"description": "",
		"prefix": "render.SetToneMappingScaleLinear"
	},
	"render.SetViewPort": {
		"body": [
			"render.SetViewPort(${1:x}, ${2:y}, ${3:w}, ${4:h})$0"
		],
		"description": "Changes the view port position and size. The values will be clamped to the game's screen resolution.\n\nIf you are looking to render something to a texture (render target), you should use render.PushRenderTarget.\n\nThis function will override values of Global.ScrW and Global.ScrH with the ones you set.",
		"prefix": "render.SetViewPort"
	},
	"render.SetWriteDepthToDestAlpha": {
		"body": [
			"render.SetWriteDepthToDestAlpha(${1:enable})$0"
		],
		"description": "Sets the internal parameter **INT_RENDERPARM_WRITE_DEPTH_TO_DESTALPHA**",
		"prefix": "render.SetWriteDepthToDestAlpha"
	},
	"render.Spin": {
		"body": [
			"render.Spin()$0"
		],
		"description": "Swaps the frame buffers/cycles the frame. In other words, this updates the screen.\n\nIf you take a really long time during a single frame render, it is a good idea to use this and let the user know that the game isn't stuck.",
		"prefix": "render.Spin"
	},
	"render.StartBeam": {
		"body": [
			"render.StartBeam(${1:segmentCount})$0"
		],
		"description": "Start a new beam draw operation.\n\n",
		"prefix": "render.StartBeam"
	},
	"render.SupportsHDR": {
		"body": [
			"render.SupportsHDR()$0"
		],
		"description": "Returns whether the player's hardware supports HDR. (High Dynamic Range) HDR can still be disabled by the `mat_hdr_level` console variable or just not be supported by the map.",
		"prefix": "render.SupportsHDR"
	},
	"render.SupportsPixelShaders_1_4": {
		"body": [
			"render.SupportsPixelShaders_1_4()$0"
		],
		"description": "Returns if the current settings and the system allow the usage of pixel shaders 1.4.",
		"prefix": "render.SupportsPixelShaders_1_4"
	},
	"render.SupportsPixelShaders_2_0": {
		"body": [
			"render.SupportsPixelShaders_2_0()$0"
		],
		"description": "Returns if the current settings and the system allow the usage of pixel shaders 2.0.",
		"prefix": "render.SupportsPixelShaders_2_0"
	},
	"render.SupportsVertexShaders_2_0": {
		"body": [
			"render.SupportsVertexShaders_2_0()$0"
		],
		"description": "Returns if the current settings and the system allow the usage of vertex shaders 2.0.",
		"prefix": "render.SupportsVertexShaders_2_0"
	},
	"render.SuppressEngineLighting": {
		"body": [
			"render.SuppressEngineLighting(${1:suppressLighting})$0"
		],
		"description": "Suppresses or enables any engine lighting for any upcoming render operation.\n\nThis does not affect IMeshes.",
		"prefix": "render.SuppressEngineLighting"
	},
	"render.TurnOnToneMapping": {
		"body": [
			"render.TurnOnToneMapping()$0"
		],
		"description": "Enables HDR tone mapping which influences the brightness.",
		"prefix": "render.TurnOnToneMapping"
	},
	"render.UpdateFullScreenDepthTexture": {
		"body": [
			"render.UpdateFullScreenDepthTexture()$0"
		],
		"description": "Updates the texture returned by render.GetFullScreenDepthTexture.\n\nSilently fails if render.SupportsPixelShaders_2_0 returns false.",
		"prefix": "render.UpdateFullScreenDepthTexture"
	},
	"render.UpdatePowerOfTwoTexture": {
		"body": [
			"render.UpdatePowerOfTwoTexture()$0"
		],
		"description": "Updates the power of two texture.",
		"prefix": "render.UpdatePowerOfTwoTexture"
	},
	"render.UpdateRefractTexture": {
		"body": [
			"render.UpdateRefractTexture()$0"
		],
		"description": "Pretty much alias of render.UpdatePowerOfTwoTexture but does not return the texture.",
		"prefix": "render.UpdateRefractTexture"
	},
	"render.UpdateScreenEffectTexture": {
		"body": [
			"render.UpdateScreenEffectTexture()$0"
		],
		"description": "Copies the entire screen to the screen effect texture, which can be acquired via render.GetScreenEffectTexture. This function is mainly intended to be used in GM:RenderScreenspaceEffects",
		"prefix": "render.UpdateScreenEffectTexture"
	},
	"resource.AddFile": {
		"body": [
			"resource.AddFile(${1:path})$0"
		],
		"description": "Adds the specified and all related files to the files the client should download.\n\nFor convenience, this function will automatically add any other files that are related to the selected one, and throw an error if it can't find them. For example, a `.vmt` file will automatically add the `.vtf` with the same name, and a `.mdl` file will automatically add all `.vvd`, `.ani`, `.dx80.vtx`, `.dx90.vtx`, `.sw.vtx`, `.phy` and `.jpg` files with the same name, with a separate error for each missing file.\n\nIf you do not want it to do this, use resource.AddSingleFile.\n\nThere's a 8192 downloadable file limit. If you need more, consider using Workshop addons - resource.AddWorkshop. You should also consider the fact that you have way too many downloads. This limit is shared among all resource.Add functions.\n\nRunning this function using a path relative to the main `garrysmod/` folder will not work for files in addons and gamemodes. Instead, the files must be added relative to their respective content folders. For example, a sound file from an addon would use the path \"sound/[FILENAME_AND_EXTENSION],\" despite the file being located in \"addons/[ADDON_NAME]/sound/[FILENAME_AND_EXTENSION]\"\n\nThe file must exist on the server or players will not download it!",
		"prefix": "resource.AddFile"
	},
	"resource.AddSingleFile": {
		"body": [
			"resource.AddSingleFile(${1:path})$0"
		],
		"description": "Adds the specified file to the files the client should download.\n\nIf you wish to add textures or models, consider using resource.AddFile to add all the files required for a texture/model.\n\nThere's a 8192 downloadable file limit. \nIf you need more than 8192, consider using Workshop addons - resource.AddWorkshop. You should also consider the fact that you have way too many downloads. This limit is shared among all resource.Add functions.\n\nThe file must exist on the server or players will not download it!",
		"prefix": "resource.AddSingleFile"
	},
	"resource.AddWorkshop": {
		"body": [
			"resource.AddWorkshop(${1:workshopid})$0"
		],
		"description": "Adds a workshop addon for the client to download before entering the server.\n\nHaving the raw files from a workshop item does not count as having already downloaded it.\nSo players who previously downloaded a map through Fast Download will have to re-download it if you use the workshop.\n\nYou should try to only add addons that have custom content ( models, sounds, etc ).\n\nGamemodes that are Gamemode_Creation#Gamemode_Text_File are automatically added to this list - so there's no need to add them.\n\n\nThe server's current map is also automatically added, if it is loaded from a workshop addon.\n\nThis will not \"install\" the addon on your server, see Workshop for Dedicated Servers for installing Steam Workshop addons onto your servers",
		"prefix": "resource.AddWorkshop"
	},
	"saverestore.AddRestoreHook": {
		"body": [
			"saverestore.AddRestoreHook(${1:identifier}, ${2:callback})$0"
		],
		"description": "Adds a restore/load hook for the Half-Life 2 save system.",
		"prefix": "saverestore.AddRestoreHook"
	},
	"saverestore.AddSaveHook": {
		"body": [
			"saverestore.AddSaveHook(${1:identifier}, ${2:callback})$0"
		],
		"description": "Adds a save hook for the Half-Life 2 save system. You can this to carry data through level transitions in Half-Life 2.",
		"prefix": "saverestore.AddSaveHook"
	},
	"saverestore.LoadEntity": {
		"body": [
			"saverestore.LoadEntity(${1:ent}, ${2:save})$0"
		],
		"description": "Loads Entity:GetTable from the save game file that is being loaded and merges it with the given entitys Entity:GetTable.",
		"prefix": "saverestore.LoadEntity"
	},
	"saverestore.LoadGlobal": {
		"body": [
			"saverestore.LoadGlobal(${1:save})$0"
		],
		"description": "\n\nCalled by engine when a save is being loaded.\n\nThis handles loading gamemode and calls all of the hooks added with saverestore.AddRestoreHook.",
		"prefix": "saverestore.LoadGlobal"
	},
	"saverestore.PreRestore": {
		"body": [
			"saverestore.PreRestore()$0"
		],
		"description": "\n\nCalled by the engine just before saverestore.LoadGlobal is.",
		"prefix": "saverestore.PreRestore"
	},
	"saverestore.PreSave": {
		"body": [
			"saverestore.PreSave()$0"
		],
		"description": "\n\nCalled by the engine just before saverestore.SaveGlobal is.",
		"prefix": "saverestore.PreSave"
	},
	"saverestore.ReadTable": {
		"body": [
			"saverestore.ReadTable(${1:save})$0"
		],
		"description": "Reads a table from the save game file that is being loaded.",
		"prefix": "saverestore.ReadTable"
	},
	"saverestore.ReadVar": {
		"body": [
			"saverestore.ReadVar(${1:save})$0"
		],
		"description": "Loads a variable from the save game file that is being loaded.\n\nVariables will be read in the save order you have saved them.",
		"prefix": "saverestore.ReadVar"
	},
	"saverestore.SaveEntity": {
		"body": [
			"saverestore.SaveEntity(${1:ent}, ${2:save})$0"
		],
		"description": "Saves entitys Entity:GetTable to the save game file that is being saved.",
		"prefix": "saverestore.SaveEntity"
	},
	"saverestore.SaveGlobal": {
		"body": [
			"saverestore.SaveGlobal(${1:save})$0"
		],
		"description": "\n\nCalled by engine when a save is being saved.\n\nThis handles saving gamemode and calls all of the hooks added with saverestore.AddSaveHook.",
		"prefix": "saverestore.SaveGlobal"
	},
	"saverestore.WritableKeysInTable": {
		"body": [
			"saverestore.WritableKeysInTable(${1:table})$0"
		],
		"description": "Returns how many writable keys are in the given table.",
		"prefix": "saverestore.WritableKeysInTable"
	},
	"saverestore.WriteTable": {
		"body": [
			"saverestore.WriteTable(${1:table}, ${2:save})$0"
		],
		"description": "Write a table to a save game file that is being saved.",
		"prefix": "saverestore.WriteTable"
	},
	"saverestore.WriteVar": {
		"body": [
			"saverestore.WriteVar(${1:value}, ${2:save})$0"
		],
		"description": "Writes a variable to the save game file that is being saved.",
		"prefix": "saverestore.WriteVar"
	},
	"scripted_ents.Alias": {
		"body": [
			"scripted_ents.Alias(${1:alias}, ${2:classname})$0"
		],
		"description": "Defines an alias string that can be used to refer to another classname",
		"prefix": "scripted_ents.Alias"
	},
	"scripted_ents.Get": {
		"body": [
			"scripted_ents.Get(${1:classname})$0"
		],
		"description": "Returns a copy of the ENT table for a class, including functions defined by the base class",
		"prefix": "scripted_ents.Get"
	},
	"scripted_ents.GetList": {
		"body": [
			"scripted_ents.GetList()$0"
		],
		"description": "Returns a copy of the list of all ENT tables registered",
		"prefix": "scripted_ents.GetList"
	},
	"scripted_ents.GetMember": {
		"body": [
			"scripted_ents.GetMember(${1:class}, ${2:name})$0"
		],
		"description": "Retrieves a member of entity's table.",
		"prefix": "scripted_ents.GetMember"
	},
	"scripted_ents.GetSpawnable": {
		"body": [
			"scripted_ents.GetSpawnable()$0"
		],
		"description": "Returns a list of all ENT tables which contain either ENT.Spawnable or ENT.AdminSpawnable",
		"prefix": "scripted_ents.GetSpawnable"
	},
	"scripted_ents.GetStored": {
		"body": [
			"scripted_ents.GetStored(${1:classname})$0"
		],
		"description": "Returns the actual ENT table for a class. Modifying functions/variables in this table will change newly spawned entities",
		"prefix": "scripted_ents.GetStored"
	},
	"scripted_ents.GetType": {
		"body": [
			"scripted_ents.GetType(${1:classname})$0"
		],
		"description": "Returns the 'type' of a class, this will one of the following: 'anim', 'ai', 'brush', 'point'.",
		"prefix": "scripted_ents.GetType"
	},
	"scripted_ents.IsBasedOn": {
		"body": [
			"scripted_ents.IsBasedOn(${1:name}, ${2:base})$0"
		],
		"description": "Checks if name is based on base",
		"prefix": "scripted_ents.IsBasedOn"
	},
	"scripted_ents.OnLoaded": {
		"body": [
			"scripted_ents.OnLoaded()$0"
		],
		"description": "\n\nCalled after all ENTS have been loaded and runs baseclass.Set on each one.\n\nYou can retrieve all the currently registered ENTS with scripted_ents.GetList.\n\nThis is not called after an ENT auto refresh, and thus the inherited baseclass functions retrieved with baseclass.Get will not be updated",
		"prefix": "scripted_ents.OnLoaded"
	},
	"scripted_ents.Register": {
		"body": [
			"scripted_ents.Register(${1:ENT}, ${2:classname})$0"
		],
		"description": "Registers an ENT table with a classname. Reregistering an existing classname will automatically update the functions of all existing entities of that class.\n\nSub-tables provided in the first argument will not carry over their metatable, and will receive a BaseClass key if the table was merged with the base's. Userdata references, which includes Vectors, Angles, Entities, etc. will not be copied.",
		"prefix": "scripted_ents.Register"
	},
	"search.AddProvider": {
		"body": [
			"search.AddProvider(${1:provider}, ${2:id=nil})$0"
		],
		"description": "Adds a search result provider. For examples, see gamemodes/sandbox/gamemode/cl_search_models.lua",
		"prefix": "search.AddProvider"
	},
	"search.GetResults": {
		"body": [
			"search.GetResults(${1:query}, ${2:types=nil}, ${3:maxResults=1024})$0"
		],
		"description": "Retrieves search results.",
		"prefix": "search.GetResults"
	},
	"serverlist.AddCurrentServerToFavorites": {
		"body": [
			"serverlist.AddCurrentServerToFavorites()$0"
		],
		"description": "Adds current server the player is on to their favorites.",
		"prefix": "serverlist.AddCurrentServerToFavorites"
	},
	"serverlist.PlayerList": {
		"body": [
			"serverlist.PlayerList(${1:ip}, ${2:callback})$0"
		],
		"description": "Queries a server for its player list.",
		"prefix": "serverlist.PlayerList"
	},
	"serverlist.Query": {
		"body": [
			"serverlist.Query(${1:data})$0"
		],
		"description": "Queries the master server for server list.",
		"prefix": "serverlist.Query"
	},
	"sound.Add": {
		"body": [
			"sound.Add(${1:soundData})$0"
		],
		"description": "Creates a sound script. It can also override sounds, which seems to only work when set on the server.",
		"prefix": "sound.Add"
	},
	"sound.AddSoundOverrides": {
		"body": [
			"sound.AddSoundOverrides(${1:filepath})$0"
		],
		"description": "Overrides sounds defined inside of a txt file; typically used for adding map-specific sounds.",
		"prefix": "sound.AddSoundOverrides"
	},
	"sound.EmitHint": {
		"body": [
			"sound.EmitHint(${1:hint}, ${2:pos}, ${3:volume}, ${4:duration}, ${5:owner=NULL})$0"
		],
		"description": "Emits a sound hint to the game elements to react to, for example to repel or attract antlions.",
		"prefix": "sound.EmitHint"
	},
	"sound.Generate": {
		"body": [
			"sound.Generate(${1:indentifier}, ${2:samplerate}, ${3:length}, ${4:callback})$0"
		],
		"description": "Creates a sound from a function.\n\nThis function cannot generate sounds that have a duration of less than 1 second.\nSounds persist between disconnects.",
		"prefix": "sound.Generate"
	},
	"sound.GetProperties": {
		"body": [
			"sound.GetProperties(${1:name})$0"
		],
		"description": "Returns properties of the soundscript.",
		"prefix": "sound.GetProperties"
	},
	"sound.GetTable": {
		"body": [
			"sound.GetTable()$0"
		],
		"description": "Returns a list of all registered sound scripts.",
		"prefix": "sound.GetTable"
	},
	"sound.Play": {
		"body": [
			"sound.Play(${1:Name}, ${2:Pos}, ${3:Level}, ${4:Pitch}, ${5:Volume})$0"
		],
		"description": "Plays a sound from the specified position in the world.\nIf you want to play a sound without a position, such as a UI sound, use surface.PlaySound instead.",
		"prefix": "sound.Play"
	},
	"sound.PlayFile": {
		"body": [
			"sound.PlayFile(${1:path}, ${2:flags}, ${3:callback})$0"
		],
		"description": "Plays a file from GMod directory. You can find a list of all error codes [here](http://www.un4seen.com/doc/#bass/BASS_ErrorGetCode.html)\n\nFor external file/stream playback, see sound.PlayURL.\n\nThis fails for looping .wav files in 3D mode.\n\nThis fails with unicode file names.",
		"prefix": "sound.PlayFile"
	},
	"sound.PlayURL": {
		"body": [
			"sound.PlayURL(${1:url}, ${2:flags}, ${3:callback})$0"
		],
		"description": "Allows you to play external sound files, as well as online radio streams.\nYou can find a list of all error codes [here](http://www.un4seen.com/doc/#bass/BASS_ErrorGetCode.html)\n\nFor offline file playback, see sound.PlayFile.\n\nDue to a bug with [BASS](http://www.un4seen.com/), AAC codec streams cannot be played in 3D mode.",
		"prefix": "sound.PlayURL"
	},
	"spawnmenu.ActivateTool": {
		"body": [
			"spawnmenu.ActivateTool(${1:tool})$0"
		],
		"description": "Activates a tool, opens context menu and brings up the tool gun.",
		"prefix": "spawnmenu.ActivateTool"
	},
	"spawnmenu.ActivateToolPanel": {
		"body": [
			"spawnmenu.ActivateToolPanel(${1:tab}, ${2:cp})$0"
		],
		"description": "Activates tools context menu in specified tool tab.",
		"prefix": "spawnmenu.ActivateToolPanel"
	},
	"spawnmenu.ActiveControlPanel": {
		"body": [
			"spawnmenu.ActiveControlPanel()$0"
		],
		"description": "Returns currently opened control panel of a tool, post process effect or some other menu in spawnmenu.",
		"prefix": "spawnmenu.ActiveControlPanel"
	},
	"spawnmenu.AddContentType": {
		"body": [
			"spawnmenu.AddContentType(${1:name}, ${2:constructor})$0"
		],
		"description": "Registers a new content type that is saveable into spawnlists.\nCreated/called by spawnmenu.CreateContentIcon.",
		"prefix": "spawnmenu.AddContentType"
	},
	"spawnmenu.AddCreationTab": {
		"body": [
			"spawnmenu.AddCreationTab(${1:name}, ${2:function}, ${3:material=icon16/exclamation.png}, ${4:order=1000}, ${5:tooltip=nil})$0"
		],
		"description": "Inserts a new tab into the CreationMenus table, which will be used by the creation menu to generate its tabs (Spawnlists, Weapons, Entities, etc.)",
		"prefix": "spawnmenu.AddCreationTab"
	},
	"spawnmenu.AddPropCategory": {
		"body": [
			"spawnmenu.AddPropCategory(${1:classname}, ${2:name}, ${3:contents}, ${4:icon}, ${5:id=1000}, ${6:parentID=0}, ${7:needsApp})$0"
		],
		"description": "Used to add addon spawnlists to the spawnmenu tree. This function should be called within SANDBOX:PopulatePropMenu.\n\nAddon spawnlists will not save to disk if edited.\n\nYou should never try to modify player customized spawnlists!",
		"prefix": "spawnmenu.AddPropCategory"
	},
	"spawnmenu.AddToolCategory": {
		"body": [
			"spawnmenu.AddToolCategory(${1:tab}, ${2:RealName}, ${3:PrintName})$0"
		],
		"description": "Used to create a new category in the list inside of a spawnmenu ToolTab.\n\nYou must call this function from SANDBOX:AddToolMenuCategories for it to work properly.",
		"prefix": "spawnmenu.AddToolCategory"
	},
	"spawnmenu.AddToolMenuOption": {
		"body": [
			"spawnmenu.AddToolMenuOption(${1:tab}, ${2:category}, ${3:class}, ${4:name}, ${5:cmd}, ${6:config}, ${7:cpanel}, ${8:table={}})$0"
		],
		"description": "Adds an option to the right side of the spawnmenu",
		"prefix": "spawnmenu.AddToolMenuOption"
	},
	"spawnmenu.AddToolTab": {
		"body": [
			"spawnmenu.AddToolTab(${1:name}, ${2:label=name}, ${3:icon=icon16/wrench.png})$0"
		],
		"description": "Adds a new tool tab to the right side of the spawnmenu via the SANDBOX:AddToolMenuTabs hook.\n\nThis function is a inferior duplicate of spawnmenu.GetToolMenu, just without its return value.",
		"prefix": "spawnmenu.AddToolTab"
	},
	"spawnmenu.ClearToolMenus": {
		"body": [
			"spawnmenu.ClearToolMenus()$0"
		],
		"description": "Clears all the tools from the different tool categories and the categories itself, if ran at the correct place.\n\nSeems to only work when ran at initialization.",
		"prefix": "spawnmenu.ClearToolMenus"
	},
	"spawnmenu.CreateContentIcon": {
		"body": [
			"spawnmenu.CreateContentIcon(${1:type}, ${2:parent}, ${3:data})$0"
		],
		"description": "Creates a new content icon.",
		"prefix": "spawnmenu.CreateContentIcon"
	},
	"spawnmenu.DoSaveToTextFiles": {
		"body": [
			"spawnmenu.DoSaveToTextFiles(${1:spawnlists})$0"
		],
		"description": "\n\nCalls spawnmenu.SaveToTextFiles.",
		"prefix": "spawnmenu.DoSaveToTextFiles"
	},
	"spawnmenu.GetContentType": {
		"body": [
			"spawnmenu.GetContentType(${1:contentType})$0"
		],
		"description": "Returns the function to create an vgui element for a specified content type",
		"prefix": "spawnmenu.GetContentType"
	},
	"spawnmenu.GetCreationTabs": {
		"body": [
			"spawnmenu.GetCreationTabs()$0"
		],
		"description": "Gets the CreationMenus table, which was filled with creation menu tabs from spawnmenu.AddCreationTab.",
		"prefix": "spawnmenu.GetCreationTabs"
	},
	"spawnmenu.GetCustomPropTable": {
		"body": [
			"spawnmenu.GetCustomPropTable()$0"
		],
		"description": "Similar to spawnmenu.GetPropTable, but only returns spawnlists created by addons via spawnmenu.AddPropCategory.\n\nThese spawnlists are shown in a separate menu in-game.",
		"prefix": "spawnmenu.GetCustomPropTable"
	},
	"spawnmenu.GetPropTable": {
		"body": [
			"spawnmenu.GetPropTable()$0"
		],
		"description": "Returns a table of all prop categories and their props in the spawnmenu.\n\nNote that if the spawnmenu has not been populated, this will return an empty table.\n\nThis will not return spawnlists created by addons, see  spawnmenu.GetCustomPropTable for that.",
		"prefix": "spawnmenu.GetPropTable"
	},
	"spawnmenu.GetToolMenu": {
		"body": [
			"spawnmenu.GetToolMenu(${1:name}, ${2:label=name}, ${3:icon=icon16/wrench.png})$0"
		],
		"description": "Adds a new tool tab (or returns an existing one by name) to the right side of the spawnmenu via the SANDBOX:AddToolMenuTabs hook.",
		"prefix": "spawnmenu.GetToolMenu"
	},
	"spawnmenu.GetTools": {
		"body": [
			"spawnmenu.GetTools()$0"
		],
		"description": "Gets a table of tools on the client.",
		"prefix": "spawnmenu.GetTools"
	},
	"spawnmenu.PopulateFromEngineTextFiles": {
		"body": [
			"spawnmenu.PopulateFromEngineTextFiles()$0"
		],
		"description": "\n\nCalls spawnmenu.PopulateFromTextFiles.",
		"prefix": "spawnmenu.PopulateFromEngineTextFiles"
	},
	"spawnmenu.PopulateFromTextFiles": {
		"body": [
			"spawnmenu.PopulateFromTextFiles(${1:callback})$0"
		],
		"description": "Loads spawnlists from text files.",
		"prefix": "spawnmenu.PopulateFromTextFiles"
	},
	"spawnmenu.SaveToTextFiles": {
		"body": [
			"spawnmenu.SaveToTextFiles(${1:spawnlists})$0"
		],
		"description": "\n\nSaves a table of spawnlists to files.",
		"prefix": "spawnmenu.SaveToTextFiles"
	},
	"spawnmenu.SetActiveControlPanel": {
		"body": [
			"spawnmenu.SetActiveControlPanel(${1:pnl})$0"
		],
		"description": "Sets currently active control panel to be returned by spawnmenu.ActiveControlPanel.",
		"prefix": "spawnmenu.SetActiveControlPanel"
	},
	"spawnmenu.SwitchToolTab": {
		"body": [
			"spawnmenu.SwitchToolTab(${1:id})$0"
		],
		"description": "\n\nSupposed to open specified tool tab in spawnmenu, in reality does nothing.",
		"prefix": "spawnmenu.SwitchToolTab"
	},
	"sql.Begin": {
		"body": [
			"sql.Begin()$0"
		],
		"description": "Tells the engine a set of queries is coming. Will wait until sql.Commit is called to run them.\nThis is most useful when you run more than 100+ queries.\nThis is equivalent to :\n```\nsql.Query( \"BEGIN;\" )\n```",
		"prefix": "sql.Begin"
	},
	"sql.Commit": {
		"body": [
			"sql.Commit()$0"
		],
		"description": "Tells the engine to execute a series of queries queued for execution, must be preceded by sql.Begin.\n\nThis is equivalent to `sql.Query( \"COMMIT;\" )`.",
		"prefix": "sql.Commit"
	},
	"sql.IndexExists": {
		"body": [
			"sql.IndexExists(${1:indexName})$0"
		],
		"description": "Returns true if the index with the specified name exists.",
		"prefix": "sql.IndexExists"
	},
	"sql.LastError": {
		"body": [
			"sql.LastError()$0"
		],
		"description": "Returns the last error from a SQLite query.",
		"prefix": "sql.LastError"
	},
	"sql.Query": {
		"body": [
			"sql.Query(${1:query})$0"
		],
		"description": "Performs a query on the local SQLite database, returns a table as result set, nil if result is empty and false on error.",
		"prefix": "sql.Query"
	},
	"sql.QueryRow": {
		"body": [
			"sql.QueryRow(${1:query}, ${2:row=1})$0"
		],
		"description": "Performs the query like sql.Query, but returns the first row found.\n\nBasically equivalent to :\n```\nsql.Query( \"*query* LIMIT 1;\" )\n```",
		"prefix": "sql.QueryRow"
	},
	"sql.QueryValue": {
		"body": [
			"sql.QueryValue(${1:query})$0"
		],
		"description": "Performs the query like sql.QueryRow, but returns the first value found.",
		"prefix": "sql.QueryValue"
	},
	"sql.SQLStr": {
		"body": [
			"sql.SQLStr(${1:string}, ${2:bNoQuotes=false})$0"
		],
		"description": "Escapes dangerous characters and symbols from user input used in an SQLite SQL Query.\n\nthis function is not meant to be used with external database engines such as `MySQL`. Escaping strings with inadequate functions is dangerous!",
		"prefix": "sql.SQLStr"
	},
	"sql.TableExists": {
		"body": [
			"sql.TableExists(${1:tableName})$0"
		],
		"description": "Returns true if the table with the specified name exists.",
		"prefix": "sql.TableExists"
	},
	"steamworks.ApplyAddons": {
		"body": [
			"steamworks.ApplyAddons()$0"
		],
		"description": "Refreshes clients addons.",
		"prefix": "steamworks.ApplyAddons"
	},
	"steamworks.Download": {
		"body": [
			"steamworks.Download(${1:workshopPreviewID}, ${2:uncompress}, ${3:resultCallback})$0"
		],
		"description": "Downloads a file from the supplied addon and saves it as a .cache file in garrysmod/cache folder.\n\nThis is mostly used to download the preview image of the addon, but the game seems to also use it to download replays and saves.\n\nIn case the retrieved file is an image and you need the IMaterial, use Global.AddonMaterial with the path supplied from the callback.",
		"prefix": "steamworks.Download"
	},
	"steamworks.DownloadUGC": {
		"body": [
			"steamworks.DownloadUGC(${1:workshopID}, ${2:resultCallback})$0"
		],
		"description": "Downloads a Steam Workshop file by its ID and returns a path to it.",
		"prefix": "steamworks.DownloadUGC"
	},
	"steamworks.FileInfo": {
		"body": [
			"steamworks.FileInfo(${1:workshopItemID}, ${2:resultCallback})$0"
		],
		"description": "Retrieves info about supplied Steam Workshop addon.",
		"prefix": "steamworks.FileInfo"
	},
	"steamworks.GetList": {
		"body": [
			"steamworks.GetList(${1:type}, ${2:tags}, ${3:offset}, ${4:numRetrieve}, ${5:days}, ${6:userID}, ${7:resultCallback})$0"
		],
		"description": "Retrieves a customized list of Steam Workshop addons.",
		"prefix": "steamworks.GetList"
	},
	"steamworks.GetPlayerName": {
		"body": [
			"steamworks.GetPlayerName(${1:steamID64})$0"
		],
		"description": "You should use the callback of steamworks.RequestPlayerInfo instead.\n\nRetrieves players name by his 64bit SteamID.\n\nYou must call steamworks.RequestPlayerInfo a decent amount of time before calling this function.",
		"prefix": "steamworks.GetPlayerName"
	},
	"steamworks.IsSubscribed": {
		"body": [
			"steamworks.IsSubscribed(${1:workshopItemID})$0"
		],
		"description": "Returns whenever the client is subscribed to the specified Steam Workshop item.",
		"prefix": "steamworks.IsSubscribed"
	},
	"steamworks.OpenWorkshop": {
		"body": [
			"steamworks.OpenWorkshop()$0"
		],
		"description": "Opens the workshop website in the steam overlay browser.",
		"prefix": "steamworks.OpenWorkshop"
	},
	"steamworks.Publish": {
		"body": [
			"steamworks.Publish(${1:tags}, ${2:filename}, ${3:image}, ${4:name}, ${5:desc})$0"
		],
		"description": "\nPublishes dupes, saves or demos to workshop.",
		"prefix": "steamworks.Publish"
	},
	"steamworks.RequestPlayerInfo": {
		"body": [
			"steamworks.RequestPlayerInfo(${1:steamID64}, ${2:callback})$0"
		],
		"description": "Requests information of the player with SteamID64 for later use with steamworks.GetPlayerName.",
		"prefix": "steamworks.RequestPlayerInfo"
	},
	"steamworks.SetFileCompleted": {
		"body": [
			"steamworks.SetFileCompleted(${1:workshopid})$0"
		],
		"description": "",
		"prefix": "steamworks.SetFileCompleted"
	},
	"steamworks.SetFilePlayed": {
		"body": [
			"steamworks.SetFilePlayed(${1:workshopid})$0"
		],
		"description": "Sets whether you have played this addon or not. This will be shown to the user in the Steam Workshop itself:\n",
		"prefix": "steamworks.SetFilePlayed"
	},
	"steamworks.SetShouldMountAddon": {
		"body": [
			"steamworks.SetShouldMountAddon(${1:workshopItemID}, ${2:shouldMount})$0"
		],
		"description": "Sets if an addon should be enabled or disabled. Call steamworks.ApplyAddons afterwards to update.",
		"prefix": "steamworks.SetShouldMountAddon"
	},
	"steamworks.ShouldMountAddon": {
		"body": [
			"steamworks.ShouldMountAddon(${1:workshopItemID})$0"
		],
		"description": "Returns whenever the specified Steam Workshop addon will be mounted or not.",
		"prefix": "steamworks.ShouldMountAddon"
	},
	"steamworks.Subscribe": {
		"body": [
			"steamworks.Subscribe(${1:workshopItemID})$0"
		],
		"description": "\n\nSubscribes to the specified workshop addon. Call steamworks.ApplyAddons afterwards to update.",
		"prefix": "steamworks.Subscribe"
	},
	"steamworks.Unsubscribe": {
		"body": [
			"steamworks.Unsubscribe(${1:workshopItemID})$0"
		],
		"description": " Unsubscribes to the specified workshop addon. Call steamworks.ApplyAddons afterwards to update.\n\nThis function should `never` be called without a user's consent and should not be called if the addon is currently in use (aka: the user is not in the main menu) as it may result in unexpected behaviour.",
		"prefix": "steamworks.Unsubscribe"
	},
	"steamworks.ViewFile": {
		"body": [
			"steamworks.ViewFile(${1:workshopItemID})$0"
		],
		"description": "Opens the workshop website for specified Steam Workshop item in the Steam overlay browser.",
		"prefix": "steamworks.ViewFile"
	},
	"steamworks.Vote": {
		"body": [
			"steamworks.Vote(${1:workshopItemID}, ${2:upOrDown})$0"
		],
		"description": " Makes the user vote for the specified addon",
		"prefix": "steamworks.Vote"
	},
	"steamworks.VoteInfo": {
		"body": [
			"steamworks.VoteInfo(${1:workshopItemID}, ${2:resultCallback})$0"
		],
		"description": "Use data steamworks.FileInfo instead.\n\nRetrieves vote info of supplied addon.",
		"prefix": "steamworks.VoteInfo"
	},
	"string.Comma": {
		"body": [
			"string.Comma(${1:InputNumber})$0"
		],
		"description": "Inserts commas for every third digit.",
		"prefix": "string.Comma"
	},
	"string.EndsWith": {
		"body": [
			"string.EndsWith(${1:str}, ${2:end})$0"
		],
		"description": "Returns whether or not the second passed string matches the end of the first.",
		"prefix": "string.EndsWith"
	},
	"string.Explode": {
		"body": [
			"string.Explode(${1:separator}, ${2:str}, ${3:use_patterns})$0"
		],
		"description": "Splits a string up wherever it finds the given separator.\n\nThis is the reverse of string.Implode.",
		"prefix": "string.Explode"
	},
	"string.FormattedTime": {
		"body": [
			"string.FormattedTime(${1:float}, ${2:format=nil})$0"
		],
		"description": "Returns the time as a formatted string or as a table if no format is given.",
		"prefix": "string.FormattedTime"
	},
	"string.FromColor": {
		"body": [
			"string.FromColor(${1:color})$0"
		],
		"description": "Creates a string from a Color variable.",
		"prefix": "string.FromColor"
	},
	"string.GetChar": {
		"body": [
			"string.GetChar(${1:str}, ${2:index})$0"
		],
		"description": "Use either string.sub(str, index, index) or str[index]. Returns char value from the specified index in the supplied string.",
		"prefix": "string.GetChar"
	},
	"string.GetExtensionFromFilename": {
		"body": [
			"string.GetExtensionFromFilename(${1:file})$0"
		],
		"description": "Returns extension of the file.",
		"prefix": "string.GetExtensionFromFilename"
	},
	"string.GetFileFromFilename": {
		"body": [
			"string.GetFileFromFilename(${1:pathString})$0"
		],
		"description": "Returns file name and extension.",
		"prefix": "string.GetFileFromFilename"
	},
	"string.GetPathFromFilename": {
		"body": [
			"string.GetPathFromFilename(${1:Inputstring})$0"
		],
		"description": "Returns the path only from a file's path.",
		"prefix": "string.GetPathFromFilename"
	},
	"string.Implode": {
		"body": [
			"string.Implode(${1:separator}, ${2:pieces})$0"
		],
		"description": "You really should just use table.concat.\n\nJoins the values of a table together to form a string.\n\nThis is the reverse of string.Explode and is functionally identical to table.concat, but with less features.",
		"prefix": "string.Implode"
	},
	"string.JavascriptSafe": {
		"body": [
			"string.JavascriptSafe(${1:str})$0"
		],
		"description": "Escapes special characters for JavaScript in a string, making the string safe for inclusion in to JavaScript strings.",
		"prefix": "string.JavascriptSafe"
	},
	"string.Left": {
		"body": [
			"string.Left(${1:str}, ${2:num})$0"
		],
		"description": "Returns everything left of supplied place of that string.",
		"prefix": "string.Left"
	},
	"string.NiceSize": {
		"body": [
			"string.NiceSize(${1:bytes})$0"
		],
		"description": "Converts a digital filesize to human-readable text.",
		"prefix": "string.NiceSize"
	},
	"string.NiceTime": {
		"body": [
			"string.NiceTime(${1:num})$0"
		],
		"description": "Formats the supplied number (in seconds) to the highest possible time unit.",
		"prefix": "string.NiceTime"
	},
	"string.PatternSafe": {
		"body": [
			"string.PatternSafe(${1:str})$0"
		],
		"description": "Escapes all special characters within a string, making the string safe for inclusion in a Lua pattern.",
		"prefix": "string.PatternSafe"
	},
	"string.Replace": {
		"body": [
			"string.Replace(${1:str}, ${2:find}, ${3:replace})$0"
		],
		"description": "Replaces all occurrences of the supplied second string.",
		"prefix": "string.Replace"
	},
	"string.Right": {
		"body": [
			"string.Right(${1:str}, ${2:num})$0"
		],
		"description": "Returns the last n-th characters of the string.",
		"prefix": "string.Right"
	},
	"string.SetChar": {
		"body": [
			"string.SetChar(${1:InputString}, ${2:Index}, ${3:ReplacementChar})$0"
		],
		"description": "Sets the character at the specific index of the string.",
		"prefix": "string.SetChar"
	},
	"string.Split": {
		"body": [
			"string.Split(${1:Inputstring}, ${2:Separator})$0"
		],
		"description": "Splits the string into a table of strings, separated by the second argument.",
		"prefix": "string.Split"
	},
	"string.StartWith": {
		"body": [
			"string.StartWith(${1:inputStr}, ${2:start})$0"
		],
		"description": "Returns whether or not the first string starts with the second.",
		"prefix": "string.StartWith"
	},
	"string.StripExtension": {
		"body": [
			"string.StripExtension(${1:Inputstring})$0"
		],
		"description": "Removes the extension of a path.",
		"prefix": "string.StripExtension"
	},
	"string.ToColor": {
		"body": [
			"string.ToColor(${1:Inputstring})$0"
		],
		"description": "Fetches a Color type from a string.",
		"prefix": "string.ToColor"
	},
	"string.ToMinutesSeconds": {
		"body": [
			"string.ToMinutesSeconds(${1:time})$0"
		],
		"description": "Returns given time in \"MM:SS\" format.",
		"prefix": "string.ToMinutesSeconds"
	},
	"string.ToMinutesSecondsMilliseconds": {
		"body": [
			"string.ToMinutesSecondsMilliseconds(${1:time})$0"
		],
		"description": "Returns given time in \"MM:SS:MS\" format.",
		"prefix": "string.ToMinutesSecondsMilliseconds"
	},
	"string.ToTable": {
		"body": [
			"string.ToTable(${1:str})$0"
		],
		"description": "Splits the string into characters and creates a sequential table of characters.\n\nAs a result of the  encoding, non-ASCII characters will be split into more than one character in the output table. Each character value in the output table will always be 1 byte.",
		"prefix": "string.ToTable"
	},
	"string.Trim": {
		"body": [
			"string.Trim(${1:Inputstring}, ${2:Char=%s})$0"
		],
		"description": "Removes leading and trailing matches of a string.",
		"prefix": "string.Trim"
	},
	"string.TrimLeft": {
		"body": [
			"string.TrimLeft(${1:str}, ${2:char})$0"
		],
		"description": "Removes leading spaces/characters from a string.",
		"prefix": "string.TrimLeft"
	},
	"string.TrimRight": {
		"body": [
			"string.TrimRight(${1:str}, ${2:char})$0"
		],
		"description": "Removes trailing spaces/passed character from a string.",
		"prefix": "string.TrimRight"
	},
	"string.byte": {
		"body": [
			"string.byte(${1:string}, ${2:startPos=1}, ${3:endPos=startPos})$0"
		],
		"description": "Returns the given string's characters in their numeric ASCII representation.",
		"prefix": "string.byte"
	},
	"string.char": {
		"body": [
			"string.char(${1:bytes})$0"
		],
		"description": "Takes the given numerical bytes and converts them to a string.",
		"prefix": "string.char"
	},
	"string.dump": {
		"body": [
			"string.dump(${1:func}, ${2:stripDebugInfo=false})$0"
		],
		"description": "Returns the binary bytecode of the given function.\n\nThis does not work with functions created in C/C++. An error will be thrown if it is",
		"prefix": "string.dump"
	},
	"string.find": {
		"body": [
			"string.find(${1:haystack}, ${2:needle}, ${3:startPos=1}, ${4:noPatterns=false})$0"
		],
		"description": "Attempts to find the specified substring in a string, uses Patterns by default.",
		"prefix": "string.find"
	},
	"string.format": {
		"body": [
			"string.format(${1:format}, ${2:formatParameters})$0"
		],
		"description": "Formats the specified values into the string given.",
		"prefix": "string.format"
	},
	"string.gfind": {
		"body": [
			"string.gfind(${1:data}, ${2:pattern})$0"
		],
		"description": "This function is removed in Lua versions later than what GMod is currently using. Use string.gmatch instead.Returns an iterator function that is called for every complete match of the pattern, all sub matches will be passed as to the loop.",
		"prefix": "string.gfind"
	},
	"string.gmatch": {
		"body": [
			"string.gmatch(${1:data}, ${2:pattern})$0"
		],
		"description": "Using Patterns, returns an iterator which will return either one value if no capture groups are defined, or any capture group matches.",
		"prefix": "string.gmatch"
	},
	"string.gsub": {
		"body": [
			"string.gsub(${1:string}, ${2:pattern}, ${3:replacement}, ${4:maxReplaces=nil})$0"
		],
		"description": "This functions main purpose is to replace certain character sequences in a string using Patterns.",
		"prefix": "string.gsub"
	},
	"string.len": {
		"body": [
			"string.len(${1:str})$0"
		],
		"description": "Counts the number of characters in the string (length). This is equivalent to using the length operator (#).",
		"prefix": "string.len"
	},
	"string.lower": {
		"body": [
			"string.lower(${1:str})$0"
		],
		"description": "Changes any upper-case letters in a string to lower-case letters.",
		"prefix": "string.lower"
	},
	"string.match": {
		"body": [
			"string.match(${1:string}, ${2:pattern}, ${3:startPosition=1})$0"
		],
		"description": "Finds a Patterns in a string.",
		"prefix": "string.match"
	},
	"string.rep": {
		"body": [
			"string.rep(${1:str}, ${2:repetitions}, ${3:separator})$0"
		],
		"description": "Repeats a string by the provided number, with an optional separator.",
		"prefix": "string.rep"
	},
	"string.reverse": {
		"body": [
			"string.reverse(${1:str})$0"
		],
		"description": "Reverses a string.",
		"prefix": "string.reverse"
	},
	"string.sub": {
		"body": [
			"string.sub(${1:string}, ${2:StartPos}, ${3:EndPos=nil})$0"
		],
		"description": "Returns a sub-string, starting from the character at position `StartPos` of the string (inclusive), and optionally ending at the character at position `EndPos` of the string (also inclusive). If EndPos is not given, the rest of the string is returned.",
		"prefix": "string.sub"
	},
	"string.upper": {
		"body": [
			"string.upper(${1:str})$0"
		],
		"description": "Changes any lower-case letters in a string to upper-case letters.",
		"prefix": "string.upper"
	},
	"surface.CreateFont": {
		"body": [
			"surface.CreateFont(${1:fontName}, ${2:fontData})$0"
		],
		"description": "Creates a new font.\n\nTo prevent the font from displaying incorrectly when using the `outline` setting, set `antialias` to false. This will ensure the text properly fills out the entire outline.\n\nBe sure to check the Default_Fonts first! Those fonts can be used without using this function.\n\nSee Also: Finding the Font Name.\n\nDue to the static nature of fonts, do **NOT** create the font more than once. You should only be creating them once, it is recommended to create them at the top of your script. Do not use this function within GM:HUDPaint or any other hook!\n\nDefine fonts that you will actually use, as fonts are very taxing on performance and will cause crashes! Do not create fonts for every size.",
		"prefix": "surface.CreateFont"
	},
	"surface.DisableClipping": {
		"body": [
			"surface.DisableClipping(${1:disable})$0"
		],
		"description": "Alias of Global.DisableClipping so use that instead.\n\nEnables or disables the clipping used by the VGUI that limits the drawing operations to a panels bounds.\n\nIdentical to Global.DisableClipping. See also Panel:NoClipping.",
		"prefix": "surface.DisableClipping"
	},
	"surface.DrawCircle": {
		"body": [
			"surface.DrawCircle(${1:originX}, ${2:originY}, ${3:radius}, ${4:r}, ${5:g}, ${6:b}, ${7:a=255})$0"
		],
		"description": "Draws a hollow circle, made of lines. For a filled circle, see examples for surface.DrawPoly.\n\n",
		"prefix": "surface.DrawCircle"
	},
	"surface.DrawLine": {
		"body": [
			"surface.DrawLine(${1:startX}, ${2:startY}, ${3:endX}, ${4:endY})$0"
		],
		"description": "Draws a line from one point to another.\n\n",
		"prefix": "surface.DrawLine"
	},
	"surface.DrawOutlinedRect": {
		"body": [
			"surface.DrawOutlinedRect(${1:x}, ${2:y}, ${3:w}, ${4:h}, ${5:thickness})$0"
		],
		"description": "Draws a hollow box with a given border width.\n\n",
		"prefix": "surface.DrawOutlinedRect"
	},
	"surface.DrawPoly": {
		"body": [
			"surface.DrawPoly(${1:vertices})$0"
		],
		"description": "Draws a textured polygon (secretly a triangle fan) with a maximum of 256 vertices.\nOnly works properly with convex polygons. You may try to render concave polygons, but there is no guarantee that things wont get messed up.\n\nUnlike most surface library functions, non-integer coordinates are not rounded.\n\nYou must reset the drawing color and texture before calling the function to ensure consistent results. See examples below.\n\n",
		"prefix": "surface.DrawPoly"
	},
	"surface.DrawRect": {
		"body": [
			"surface.DrawRect(${1:x}, ${2:y}, ${3:width}, ${4:height})$0"
		],
		"description": "Draws a solid rectangle on the screen.\n\n",
		"prefix": "surface.DrawRect"
	},
	"surface.DrawText": {
		"body": [
			"surface.DrawText(${1:text}, ${2:forceAdditive=nil})$0"
		],
		"description": "Draw the specified text on the screen, using the previously set position, font and color.\n\nThis function does not handle newlines properly\nThis function sets new text position at the end of the previous drawn text length - this can be used to change text properties (such as font or color) without recalculating and resetting text position. See example #2 for example use of this behavior.\n\n",
		"prefix": "surface.DrawText"
	},
	"surface.DrawTexturedRect": {
		"body": [
			"surface.DrawTexturedRect(${1:x}, ${2:y}, ${3:width}, ${4:height})$0"
		],
		"description": "Draw a textured rectangle with the given position and dimensions on the screen, using the current active texture set with surface.SetMaterial. It is also affected by surface.SetDrawColor.\n\nSee also render.SetMaterial and render.DrawScreenQuadEx.\n\nSee also surface.DrawTexturedRectUV.\n\n",
		"prefix": "surface.DrawTexturedRect"
	},
	"surface.DrawTexturedRectRotated": {
		"body": [
			"surface.DrawTexturedRectRotated(${1:x}, ${2:y}, ${3:width}, ${4:height}, ${5:rotation})$0"
		],
		"description": "Draw a textured rotated rectangle with the given position and dimensions and angle on the screen, using the current active texture.\n\n",
		"prefix": "surface.DrawTexturedRectRotated"
	},
	"surface.DrawTexturedRectUV": {
		"body": [
			"surface.DrawTexturedRectUV(${1:x}, ${2:y}, ${3:width}, ${4:height}, ${5:startU}, ${6:startV}, ${7:endU}, ${8:endV})$0"
		],
		"description": "Draws a textured rectangle with a repeated or partial texture.\n\nu and v refer to texture coordinates.\n* (u, v) = (0, 0) is the top left\n* (u, v) = (1, 0) is the top right\n* (u, v) = (1, 1) is the bottom right\n* (u, v) = (0, 1) is the bottom left\n\nUsing a start point of (1, 0) and an end point to (0, 1), you can draw an image flipped horizontally, same goes with other directions. Going above 1 will tile the texture. Negative values are allowed as well.\n\nHere's a helper image:\n\n\nIf you are using a .png image, you need supply the \"noclamp\" flag as second parameter for Global.Material if you intend to use tiling.\n\nIf you find that surface.DrawTexturedRectUV is getting your texture coordinates (u0, v0), (u1, v1) wrong and you're rendering with a material created with Global.CreateMaterial, try adjusting them with the following code:\n\n```\nlocal du = 0.5 / 32 -- half pixel anticorrection\nlocal dv = 0.5 / 32 -- half pixel anticorrection\nlocal u0, v0 = (u0 - du) / (1 - 2 * du), (v0 - dv) / (1 - 2 * dv)\nlocal u1, v1 = (u1 - du) / (1 - 2 * du), (v1 - dv) / (1 - 2 * dv)\n```\n\n\n**Explanation:**\nsurface.DrawTexturedRectUV tries to correct the texture coordinates by half a pixel (something to do with sampling) and computes the correction using IMaterial::GetMappingWidth()/GetMappingHeight(). If the material was created without a $basetexture, then GetMappingWidth()/GetMappingHeight() uses the width and height of the error material (which is 32x32).\n\n\n\nThe UV offsets might require (sub-)pixel correction for accurate tiling results.\n",
		"prefix": "surface.DrawTexturedRectUV"
	},
	"surface.GetAlphaMultiplier": {
		"body": [
			"surface.GetAlphaMultiplier()$0"
		],
		"description": "Returns the current alpha multiplier affecting drawing operations. This is set by surface.SetAlphaMultiplier or by the game engine in certain other cases.",
		"prefix": "surface.GetAlphaMultiplier"
	},
	"surface.GetDrawColor": {
		"body": [
			"surface.GetDrawColor()$0"
		],
		"description": "Returns the current color affecting draw operations.\n\nThe returned color will not have the color metatable.",
		"prefix": "surface.GetDrawColor"
	},
	"surface.GetHUDTexture": {
		"body": [
			"surface.GetHUDTexture(${1:name})$0"
		],
		"description": "Gets the [HUD icon](https://github.com/Facepunch/garrysmod/blob/master/garrysmod/scripts/hud_textures.txt) TextureID with the specified name.",
		"prefix": "surface.GetHUDTexture"
	},
	"surface.GetTextColor": {
		"body": [
			"surface.GetTextColor()$0"
		],
		"description": "Returns the current color affecting text draw operations.\n\nThe returned color will not have the color metatable.",
		"prefix": "surface.GetTextColor"
	},
	"surface.GetTextSize": {
		"body": [
			"surface.GetTextSize(${1:text})$0"
		],
		"description": "Returns the width and height (in pixels) of the given text, but only if the font has been set with surface.SetFont.",
		"prefix": "surface.GetTextSize"
	},
	"surface.GetTextureID": {
		"body": [
			"surface.GetTextureID(${1:name/path})$0"
		],
		"description": "Returns the texture id of the material with the given name/path.\n\nThis function will not work with .png or .jpg images. For that, see Global.Material",
		"prefix": "surface.GetTextureID"
	},
	"surface.GetTextureSize": {
		"body": [
			"surface.GetTextureSize(${1:textureID})$0"
		],
		"description": "Returns the size of the texture with the associated texture ID.\n\nFor `.png/.jpg` textures loaded with Global.Material you can use the `$realheight` and `$realwidth` material parameters (IMaterial:GetInt) to get the size of the image.",
		"prefix": "surface.GetTextureSize"
	},
	"surface.PlaySound": {
		"body": [
			"surface.PlaySound(${1:soundfile})$0"
		],
		"description": "Play a sound file directly on the client (such as UI sounds, etc).",
		"prefix": "surface.PlaySound"
	},
	"surface.ScreenHeight": {
		"body": [
			"surface.ScreenHeight()$0"
		],
		"description": "You should use Global.ScrH instead.\nReturns the height of the current client's screen.",
		"prefix": "surface.ScreenHeight"
	},
	"surface.ScreenWidth": {
		"body": [
			"surface.ScreenWidth()$0"
		],
		"description": "You should use Global.ScrW instead.\nReturns the width of the current client's screen.",
		"prefix": "surface.ScreenWidth"
	},
	"surface.SetAlphaMultiplier": {
		"body": [
			"surface.SetAlphaMultiplier(${1:multiplier})$0"
		],
		"description": "Sets the alpha multiplier that will influence all upcoming drawing operations.\nSee also render.SetBlend.",
		"prefix": "surface.SetAlphaMultiplier"
	},
	"surface.SetDrawColor": {
		"body": [
			"surface.SetDrawColor(${1:r}, ${2:g}, ${3:b}, ${4:a=255})$0"
		],
		"description": "Set the color of any future shapes to be drawn, can be set by either using R, G, B, A as separate values or by a Color. Using a color structure is not recommended to be created procedurally.\nProviding a Color structure is slower than providing four numbers. You may use Color:Unpack for this.\nThe alpha value may not work properly if you're using a material without `$vertexalpha`.\nDue to post processing and gamma correction the color you set with this function may appear differently when rendered. This problem does not occur on materials drawn with surface.DrawTexturedRect.",
		"prefix": "surface.SetDrawColor"
	},
	"surface.SetFont": {
		"body": [
			"surface.SetFont(${1:fontName})$0"
		],
		"description": "Set the current font to be used for text operations later.\n\nThe fonts must first be created with surface.CreateFont or be one of the Default Fonts.",
		"prefix": "surface.SetFont"
	},
	"surface.SetMaterial": {
		"body": [
			"surface.SetMaterial(${1:material})$0"
		],
		"description": "Sets the material to be used in all upcoming draw operations using the surface library.\n\nNot to be confused with render.SetMaterial.\n\nSee also surface.SetTexture.\n\nIf you need to unset the texture, use the draw.NoTexture convenience function.\n\nGlobal.Material function calls are expensive to be done inside this function or inside rendering context, you should be caching the results of Global.Material calls\nWhen using render.PushRenderTarget or render.SetRenderTarget, `material` should have the `$ignorez` flag set to make it visible. If the material is not used in 3D rendering, it is probably safe to add it with this code:\n```lua\nmaterial:SetInt( \"$flags\", bit.bor( material:GetInt( \"$flags\" ), 32768 ) )\n```\n",
		"prefix": "surface.SetMaterial"
	},
	"surface.SetTextColor": {
		"body": [
			"surface.SetTextColor(${1:r}, ${2:g}, ${3:b}, ${4:a=255})$0"
		],
		"description": "Set the color of any future text to be drawn, can be set by either using R, G, B, A as separate numbers or by a Color.\n\nUsing a color structure is not recommended to be created procedurally.\nProviding a Color structure is slower than providing four numbers. You may use Color:Unpack for this.",
		"prefix": "surface.SetTextColor"
	},
	"surface.SetTextPos": {
		"body": [
			"surface.SetTextPos(${1:x}, ${2:y})$0"
		],
		"description": "Set the top-left position to draw any future text at.",
		"prefix": "surface.SetTextPos"
	},
	"surface.SetTexture": {
		"body": [
			"surface.SetTexture(${1:textureID})$0"
		],
		"description": "Sets the texture to be used in all upcoming draw operations using the surface library.\n\nSee also surface.SetMaterial for an IMaterial alternative.",
		"prefix": "surface.SetTexture"
	},
	"system.AppTime": {
		"body": [
			"system.AppTime()$0"
		],
		"description": "Returns the total uptime of the current application as reported by Steam.\n\nThis will return a similar value to Global.SysTime.\n\nThis function does not work on Dedicated Servers and will instead return no value.",
		"prefix": "system.AppTime"
	},
	"system.BatteryPower": {
		"body": [
			"system.BatteryPower()$0"
		],
		"description": "Returns the current battery power.",
		"prefix": "system.BatteryPower"
	},
	"system.FlashWindow": {
		"body": [
			"system.FlashWindow()$0"
		],
		"description": "Flashes the window, turning the border to white briefly",
		"prefix": "system.FlashWindow"
	},
	"system.GetCountry": {
		"body": [
			"system.GetCountry()$0"
		],
		"description": "Returns the country code of this computer, determined by the localisation settings of the OS.\n\nThis function does not work on Dedicated Servers and will instead return no value.",
		"prefix": "system.GetCountry"
	},
	"system.HasFocus": {
		"body": [
			"system.HasFocus()$0"
		],
		"description": "Returns whether or not the game window has focus.\n\nThis function does not work on dedicated servers and will instead return no value.\n\nThis will return true when minimized in windowed-mode.",
		"prefix": "system.HasFocus"
	},
	"system.IsLinux": {
		"body": [
			"system.IsLinux()$0"
		],
		"description": "Returns whether the current OS is Linux.",
		"prefix": "system.IsLinux"
	},
	"system.IsOSX": {
		"body": [
			"system.IsOSX()$0"
		],
		"description": "Returns whether the current OS is OSX.",
		"prefix": "system.IsOSX"
	},
	"system.IsWindowed": {
		"body": [
			"system.IsWindowed()$0"
		],
		"description": "Returns whether the game is being run in a window or in fullscreen (you can change this by opening the menu, clicking 'Options', then clicking the 'Video' tab, and changing the Display Mode using the dropdown menu):\n\n",
		"prefix": "system.IsWindowed"
	},
	"system.IsWindows": {
		"body": [
			"system.IsWindows()$0"
		],
		"description": "Returns whether the current OS is Windows.",
		"prefix": "system.IsWindows"
	},
	"system.SteamTime": {
		"body": [
			"system.SteamTime()$0"
		],
		"description": "Returns the synchronized Steam time. This is the number of seconds since the [Unix epoch](http://en.wikipedia.org/wiki/Unix_time).\n\nThis function does not work on Dedicated Servers and will instead return no value.",
		"prefix": "system.SteamTime"
	},
	"system.UpTime": {
		"body": [
			"system.UpTime()$0"
		],
		"description": "Returns the amount of seconds since the Steam user last moved their mouse.\n\nThis is a direct binding to ISteamUtils->GetSecondsSinceComputerActive, and is most likely related to Steam's automatic \"Away\" online status.\n\nThis function does not work on Dedicated Servers and will instead return no value.",
		"prefix": "system.UpTime"
	},
	"table.Add": {
		"body": [
			"table.Add(${1:target}, ${2:source})$0"
		],
		"description": "Adds the contents from one table into another. The target table will be modified.\n\nSee also table.insert, table.Inherit and table.Merge.",
		"prefix": "table.Add"
	},
	"table.ClearKeys": {
		"body": [
			"table.ClearKeys(${1:table}, ${2:saveKeys=false})$0"
		],
		"description": "Changes all keys to sequential integers. This creates a new table object and does not affect the original.",
		"prefix": "table.ClearKeys"
	},
	"table.CollapseKeyValue": {
		"body": [
			"table.CollapseKeyValue(${1:input})$0"
		],
		"description": "Collapses a table with keyvalue structure",
		"prefix": "table.CollapseKeyValue"
	},
	"table.Copy": {
		"body": [
			"table.Copy(${1:originalTable})$0"
		],
		"description": "Creates a deep copy and returns that copy.\n\nThis function does NOT copy userdata, such as Vectors and Angles!",
		"prefix": "table.Copy"
	},
	"table.CopyFromTo": {
		"body": [
			"table.CopyFromTo(${1:source}, ${2:target})$0"
		],
		"description": "Empties the target table, and merges all values from the source table into it.",
		"prefix": "table.CopyFromTo"
	},
	"table.Count": {
		"body": [
			"table.Count(${1:tbl})$0"
		],
		"description": "Counts the amount of keys in a table. This should only be used when a table is not numerically and sequentially indexed. For those tables, consider the length (**#**) operator.\n\nIf you only want to test if the table is empty or not, use table.IsEmpty instead as it is a lot faster.",
		"prefix": "table.Count"
	},
	"table.DeSanitise": {
		"body": [
			"table.DeSanitise(${1:tbl})$0"
		],
		"description": "Converts a table that has been sanitised with table.Sanitise back to its original form",
		"prefix": "table.DeSanitise"
	},
	"table.Empty": {
		"body": [
			"table.Empty(${1:tbl})$0"
		],
		"description": "Removes all values from a table.",
		"prefix": "table.Empty"
	},
	"table.FindNext": {
		"body": [
			"table.FindNext(${1:tbl}, ${2:value})$0"
		],
		"description": "Instead, iterate the table using ipairs or increment from the previous index using Global.next. Non-numerically indexed tables are not ordered.\nReturns the value positioned after the supplied value in a table. If it isn't found then the first element in the table is returned",
		"prefix": "table.FindNext"
	},
	"table.FindPrev": {
		"body": [
			"table.FindPrev(${1:tbl}, ${2:value})$0"
		],
		"description": "Instead, iterate your table with ipairs, storing the previous value and checking for the target. Non-numerically indexed tables are not ordered.\nReturns the value positioned before the supplied value in a table. If it isn't found then the last element in the table is returned",
		"prefix": "table.FindPrev"
	},
	"table.ForceInsert": {
		"body": [
			"table.ForceInsert(${1:tab={}}, ${2:value})$0"
		],
		"description": "Inserts a value in to the given table even if the table is non-existent",
		"prefix": "table.ForceInsert"
	},
	"table.GetFirstKey": {
		"body": [
			"table.GetFirstKey(${1:tab})$0"
		],
		"description": "Instead, expect the first key to be 1.\n\nNon-numerically indexed tables are not ordered and do not have a first key.\nReturns the first key found in the given table",
		"prefix": "table.GetFirstKey"
	},
	"table.GetFirstValue": {
		"body": [
			"table.GetFirstValue(${1:tab})$0"
		],
		"description": "Instead, index the table with a key of 1.\n\nNon-numerically indexed tables are not ordered and do not have a first key.\nReturns the first value found in the given table",
		"prefix": "table.GetFirstValue"
	},
	"table.GetKeys": {
		"body": [
			"table.GetKeys(${1:tabl})$0"
		],
		"description": "Returns all keys of a table.",
		"prefix": "table.GetKeys"
	},
	"table.GetLastKey": {
		"body": [
			"table.GetLastKey(${1:tab})$0"
		],
		"description": "Instead, use the result of the length (#) operator, ensuring it is not zero. Non-numerically indexed tables are not ordered and do not have a last key.\nReturns the last key found in the given table",
		"prefix": "table.GetLastKey"
	},
	"table.GetLastValue": {
		"body": [
			"table.GetLastValue(${1:tab})$0"
		],
		"description": "Instead, index the table with the result of the length (#) operator, ensuring it is not zero. Non-numerically indexed tables are not ordered and do not have a last key.\nReturns the last value found in the given table",
		"prefix": "table.GetLastValue"
	},
	"table.GetWinningKey": {
		"body": [
			"table.GetWinningKey(${1:inputTable})$0"
		],
		"description": "Returns a key of the supplied table with the highest number value.",
		"prefix": "table.GetWinningKey"
	},
	"table.HasValue": {
		"body": [
			"table.HasValue(${1:tbl}, ${2:value})$0"
		],
		"description": "Checks if a table has a value.\nThis function is **very inefficient for large tables** (O(n)) and should probably not be called in things that run each frame. Instead, consider a table structure such as example 2 below. Also see: Tables: Bad Habits\nFor optimization, functions that look for a value by sorting the table should never be needed if you work on a table that you built yourself.",
		"prefix": "table.HasValue"
	},
	"table.Inherit": {
		"body": [
			"table.Inherit(${1:target}, ${2:base})$0"
		],
		"description": "Copies any missing data from base to target, and sets the target's `BaseClass` member to the base table's pointer.\n\nSee table.Merge, which overrides existing values and doesn't add a BaseClass member.\n\n\nSee also table.Add, which simply adds values of one table to another.\n\nSub-tables aren't inherited. The target's table value will take priority.",
		"prefix": "table.Inherit"
	},
	"table.IsEmpty": {
		"body": [
			"table.IsEmpty(${1:tab})$0"
		],
		"description": "Returns whether or not the given table is empty.\n\nThis works on both sequential and non-sequential tables, and is a lot faster to use than `table.Count(tbl) == 0`.",
		"prefix": "table.IsEmpty"
	},
	"table.IsSequential": {
		"body": [
			"table.IsSequential(${1:tab})$0"
		],
		"description": "Returns whether or not the table's keys are sequential",
		"prefix": "table.IsSequential"
	},
	"table.KeyFromValue": {
		"body": [
			"table.KeyFromValue(${1:tab}, ${2:value})$0"
		],
		"description": "Returns the first key found to be containing the supplied value",
		"prefix": "table.KeyFromValue"
	},
	"table.KeysFromValue": {
		"body": [
			"table.KeysFromValue(${1:tab}, ${2:value})$0"
		],
		"description": "Returns a table of keys containing the supplied value",
		"prefix": "table.KeysFromValue"
	},
	"table.LowerKeyNames": {
		"body": [
			"table.LowerKeyNames(${1:tbl})$0"
		],
		"description": "Returns a copy of the input table with all string keys converted to be lowercase recursively",
		"prefix": "table.LowerKeyNames"
	},
	"table.Merge": {
		"body": [
			"table.Merge(${1:destination}, ${2:source})$0"
		],
		"description": "Merges the contents of the second table with the content in the first one. The destination table will be modified.\n\nSee table.Inherit, which doesn't override existing values.\n\n\nSee also table.Add, which simply adds values of one table to another.\nThis function will cause a stack overflow under certain circumstances.",
		"prefix": "table.Merge"
	},
	"table.Random": {
		"body": [
			"table.Random(${1:haystack})$0"
		],
		"description": "Returns a random value from the supplied table.\n\nThis function iterates over the given table **twice**, therefore with sequential tables you should instead use following:\n\n```\nmytable[ math.random( #mytable ) ]\n```\n",
		"prefix": "table.Random"
	},
	"table.RemoveByValue": {
		"body": [
			"table.RemoveByValue(${1:tbl}, ${2:val})$0"
		],
		"description": "Removes the first instance of a given value from the specified table with table.remove, then returns the key that the value was found at.\n\nAvoid usage of this function. It does not remove all instances of given value in the table, only the first found, and it does not work with non sequential tables!",
		"prefix": "table.RemoveByValue"
	},
	"table.Reverse": {
		"body": [
			"table.Reverse(${1:tbl})$0"
		],
		"description": "Returns a reversed copy of a sequential table. Any non-sequential and non-numeric keyvalue pairs will not be copied.",
		"prefix": "table.Reverse"
	},
	"table.Sanitise": {
		"body": [
			"table.Sanitise(${1:tab})$0"
		],
		"description": "Converts Vectors, Angles and booleans to be able to be converted to and from key-values. table.DeSanitise does the opposite",
		"prefix": "table.Sanitise"
	},
	"table.SortByKey": {
		"body": [
			"table.SortByKey(${1:tab}, ${2:descending=false})$0"
		],
		"description": "Returns a list of keys sorted based on values of those keys.\n\nFor normal sorting see table.sort.",
		"prefix": "table.SortByKey"
	},
	"table.SortByMember": {
		"body": [
			"table.SortByMember(${1:tab}, ${2:memberKey}, ${3:ascending=false})$0"
		],
		"description": "Sorts a table by a named member.",
		"prefix": "table.SortByMember"
	},
	"table.SortDesc": {
		"body": [
			"table.SortDesc(${1:tbl})$0"
		],
		"description": "Sorts a table in reverse order from table.sort.\nThis function modifies the table you give to it. Like table.sort, it does not return anything.",
		"prefix": "table.SortDesc"
	},
	"table.ToString": {
		"body": [
			"table.ToString(${1:tbl}, ${2:displayName}, ${3:niceFormatting})$0"
		],
		"description": "Converts a table into a string",
		"prefix": "table.ToString"
	},
	"table.concat": {
		"body": [
			"table.concat(${1:tbl}, ${2:concatenator}, ${3:startPos=1}, ${4:endPos=#tbl})$0"
		],
		"description": "Concatenates the contents of a table to a string.",
		"prefix": "table.concat"
	},
	"table.foreach": {
		"body": [
			"table.foreach(${1:tbl}, ${2:callback})$0"
		],
		"description": "This was deprecated in Lua 5.1 and removed in 5.2. You should use Global.pairs instead. Iterates for each key-value pair in the table, calling the function with the key and value of the pair. If the function returns anything, the loop is broken.\n\nThis is inherited from the original Lua implementation and is deprecated in Lua as of 5.1; see [here](http://lua-users.org/wiki/TableLibraryTutorial). You should use Global.pairs instead. The GLua interpretation of this is table.ForEach.",
		"prefix": "table.foreach"
	},
	"table.foreachi": {
		"body": [
			"table.foreachi(${1:table}, ${2:func})$0"
		],
		"description": "This was deprecated in Lua 5.1 and removed in 5.2. You should use Global.ipairs() instead. Iterates for each numeric index in the table in order.\n\nThis is inherited from the original Lua implementation and is deprecated in Lua as of 5.1; see [here](http://lua-users.org/wiki/TableLibraryTutorial). You should use Global.ipairs() instead.",
		"prefix": "table.foreachi"
	},
	"table.getn": {
		"body": [
			"table.getn(${1:tbl})$0"
		],
		"description": "This function was deprecated in Lua 5.1 and is removed in 5.2. Use the length (#) operator instead. Returns the length of the table.",
		"prefix": "table.getn"
	},
	"table.insert": {
		"body": [
			"table.insert(${1:tbl}, ${2:position}, ${3:value})$0"
		],
		"description": "Inserts a value into a table at the end of the table or at the given position.\nThis function does not call the `__newindex` [metamethod](Metamethods).",
		"prefix": "table.insert"
	},
	"table.maxn": {
		"body": [
			"table.maxn(${1:tbl})$0"
		],
		"description": "Returns the highest numerical key.",
		"prefix": "table.maxn"
	},
	"table.remove": {
		"body": [
			"table.remove(${1:tbl}, ${2:index=#tbl})$0"
		],
		"description": "Removes a value from a table and shifts any other values down to fill the gap.\nDoes nothing if index is less than 1 or greater than `#tbl`",
		"prefix": "table.remove"
	},
	"table.sort": {
		"body": [
			"table.sort(${1:tbl}, ${2:sorter})$0"
		],
		"description": "Sorts a sequential table either ascending or by the given sort function.\nThis function modifies the table you give to it.",
		"prefix": "table.sort"
	},
	"team.AddScore": {
		"body": [
			"team.AddScore(${1:index}, ${2:increment})$0"
		],
		"description": "Increases the score of the given team",
		"prefix": "team.AddScore"
	},
	"team.BestAutoJoinTeam": {
		"body": [
			"team.BestAutoJoinTeam()$0"
		],
		"description": "Returns the team index of the team with the least players. Falls back to TEAM_UNASSIGNED",
		"prefix": "team.BestAutoJoinTeam"
	},
	"team.GetAllTeams": {
		"body": [
			"team.GetAllTeams()$0"
		],
		"description": "Returns a table consisting of information on every defined team",
		"prefix": "team.GetAllTeams"
	},
	"team.GetClass": {
		"body": [
			"team.GetClass(${1:index})$0"
		],
		"description": "Returns the selectable classes for the given team. This can be added to with team.SetClass",
		"prefix": "team.GetClass"
	},
	"team.GetColor": {
		"body": [
			"team.GetColor(${1:teamIndex})$0"
		],
		"description": "Returns the team's color.",
		"prefix": "team.GetColor"
	},
	"team.GetName": {
		"body": [
			"team.GetName(${1:teamIndex})$0"
		],
		"description": "Returns the name of the team.",
		"prefix": "team.GetName"
	},
	"team.GetPlayers": {
		"body": [
			"team.GetPlayers(${1:teamIndex})$0"
		],
		"description": "Returns a table with all player of the specified team.",
		"prefix": "team.GetPlayers"
	},
	"team.GetScore": {
		"body": [
			"team.GetScore(${1:teamIndex})$0"
		],
		"description": "Returns the score of the team.",
		"prefix": "team.GetScore"
	},
	"team.GetSpawnPoint": {
		"body": [
			"team.GetSpawnPoint(${1:index})$0"
		],
		"description": "Returns a table of valid spawnpoint classes the team can use. These are set with team.SetSpawnPoint.",
		"prefix": "team.GetSpawnPoint"
	},
	"team.GetSpawnPoints": {
		"body": [
			"team.GetSpawnPoints(${1:index})$0"
		],
		"description": "Returns a table of valid spawnpoint entities the team can use. These are set with  team.SetSpawnPoint.",
		"prefix": "team.GetSpawnPoints"
	},
	"team.Joinable": {
		"body": [
			"team.Joinable(${1:index})$0"
		],
		"description": "Returns if a team is joinable or not. This is set in team.SetUp.",
		"prefix": "team.Joinable"
	},
	"team.NumPlayers": {
		"body": [
			"team.NumPlayers(${1:teamIndex})$0"
		],
		"description": "Returns the amount of players in a team.",
		"prefix": "team.NumPlayers"
	},
	"team.SetClass": {
		"body": [
			"team.SetClass(${1:index}, ${2:classes})$0"
		],
		"description": "Sets valid classes for use by a team. Classes can be created using player_manager.RegisterClass",
		"prefix": "team.SetClass"
	},
	"team.SetColor": {
		"body": [
			"team.SetColor(${1:teamIndex}, ${2:color})$0"
		],
		"description": "Sets the team's color.",
		"prefix": "team.SetColor"
	},
	"team.SetScore": {
		"body": [
			"team.SetScore(${1:index}, ${2:score})$0"
		],
		"description": "Sets the score of the given team",
		"prefix": "team.SetScore"
	},
	"team.SetSpawnPoint": {
		"body": [
			"team.SetSpawnPoint(${1:index}, ${2:classes})$0"
		],
		"description": "Sets valid spawnpoint classes for use by a team.\n\nGM.TeamBased must be set to true for this to work",
		"prefix": "team.SetSpawnPoint"
	},
	"team.SetUp": {
		"body": [
			"team.SetUp(${1:teamIndex}, ${2:teamName}, ${3:teamColor}, ${4:isJoinable=true})$0"
		],
		"description": "Creates a new team.",
		"prefix": "team.SetUp"
	},
	"team.TotalDeaths": {
		"body": [
			"team.TotalDeaths(${1:teamIndex})$0"
		],
		"description": "Returns the sum of deaths of all players of the team.",
		"prefix": "team.TotalDeaths"
	},
	"team.TotalFrags": {
		"body": [
			"team.TotalFrags(${1:Entity or number})$0"
		],
		"description": "Get's the total frags in a team.",
		"prefix": "team.TotalFrags"
	},
	"team.Valid": {
		"body": [
			"team.Valid(${1:index})$0"
		],
		"description": "Returns true if the given team index is valid",
		"prefix": "team.Valid"
	},
	"timer.Adjust": {
		"body": [
			"timer.Adjust(${1:identifier}, ${2:delay}, ${3:repetitions}, ${4:func})$0"
		],
		"description": "Adjusts the timer if the timer with the given identifier exists.",
		"prefix": "timer.Adjust"
	},
	"timer.Check": {
		"body": [
			"timer.Check()$0"
		],
		"description": " This function does nothing.",
		"prefix": "timer.Check"
	},
	"timer.Create": {
		"body": [
			"timer.Create(${1:identifier}, ${2:delay}, ${3:repetitions}, ${4:func})$0"
		],
		"description": "Creates a new timer that will repeat its function given amount of times.\nThis function also requires the timer to be named, which allows you to control it after it was created via the timer.\n\nFor a simple one-time timer with no identifiers, see timer.Simple.\n\nTimers use Global.CurTime internally. Due to this, they won't advance while the client is timing out from the server or on an empty dedicated server due to hibernation. (unless sv_hibernate_think is set to 1)",
		"prefix": "timer.Create"
	},
	"timer.Destroy": {
		"body": [
			"timer.Destroy(${1:identifier})$0"
		],
		"description": "You should be using timer.Remove instead. Stops and destroys the given timer. Alias of timer.Remove.",
		"prefix": "timer.Destroy"
	},
	"timer.Exists": {
		"body": [
			"timer.Exists(${1:identifier})$0"
		],
		"description": "Returns whenever the given timer exists or not.",
		"prefix": "timer.Exists"
	},
	"timer.Pause": {
		"body": [
			"timer.Pause(${1:identifier})$0"
		],
		"description": "Pauses the given timer.",
		"prefix": "timer.Pause"
	},
	"timer.Remove": {
		"body": [
			"timer.Remove(${1:identifier})$0"
		],
		"description": "Stops and removes a timer created by timer.Create.\nThe timers are removed in the next frame! Keep this in mind when storing identifiers in variables.",
		"prefix": "timer.Remove"
	},
	"timer.RepsLeft": {
		"body": [
			"timer.RepsLeft(${1:identifier})$0"
		],
		"description": "Returns amount of repetitions/executions left before the timer destroys itself.",
		"prefix": "timer.RepsLeft"
	},
	"timer.Simple": {
		"body": [
			"timer.Simple(${1:delay}, ${2:func})$0"
		],
		"description": "Creates a simple timer that runs the given function after a specified delay.\n\nFor a more advanced version that you can control after creation, see timer.Create.\n\nTimers use Global.CurTime internally. Due to this, they won't advance while the client is timing out from the server or on an empty dedicated server due to hibernation. (unless sv_hibernate_think is set to 1)",
		"prefix": "timer.Simple"
	},
	"timer.Start": {
		"body": [
			"timer.Start(${1:identifier})$0"
		],
		"description": "Restarts the given timer.\n\nTimers use Global.CurTime for timing.\nTimers won't advance while the client is timing out from the server.",
		"prefix": "timer.Start"
	},
	"timer.Stop": {
		"body": [
			"timer.Stop(${1:identifier})$0"
		],
		"description": "Stops the given timer and rewinds it.",
		"prefix": "timer.Stop"
	},
	"timer.TimeLeft": {
		"body": [
			"timer.TimeLeft(${1:identifier})$0"
		],
		"description": "Returns amount of time left (in seconds) before the timer executes its function.\n\nIf the timer is paused, the amount will be negative.",
		"prefix": "timer.TimeLeft"
	},
	"timer.Toggle": {
		"body": [
			"timer.Toggle(${1:identifier})$0"
		],
		"description": "Runs either timer.Pause or timer.UnPause based on the timer's current status.",
		"prefix": "timer.Toggle"
	},
	"timer.UnPause": {
		"body": [
			"timer.UnPause(${1:identifier})$0"
		],
		"description": "Unpauses the timer.",
		"prefix": "timer.UnPause"
	},
	"umsg.Angle": {
		"body": [
			"umsg.Angle(${1:angle})$0"
		],
		"description": "Writes an angle to the usermessage.",
		"prefix": "umsg.Angle"
	},
	"umsg.Bool": {
		"body": [
			"umsg.Bool(${1:bool})$0"
		],
		"description": "Writes a bool to the usermessage.",
		"prefix": "umsg.Bool"
	},
	"umsg.Char": {
		"body": [
			"umsg.Char(${1:char})$0"
		],
		"description": "Writes a signed char to the usermessage.",
		"prefix": "umsg.Char"
	},
	"umsg.End": {
		"body": [
			"umsg.End()$0"
		],
		"description": "Dispatches the usermessage to the client(s).",
		"prefix": "umsg.End"
	},
	"umsg.Entity": {
		"body": [
			"umsg.Entity(${1:entity})$0"
		],
		"description": "Writes an entity object to the usermessage.",
		"prefix": "umsg.Entity"
	},
	"umsg.Float": {
		"body": [
			"umsg.Float(${1:float})$0"
		],
		"description": "Writes a float to the usermessage.",
		"prefix": "umsg.Float"
	},
	"umsg.Long": {
		"body": [
			"umsg.Long(${1:int})$0"
		],
		"description": "Writes a signed int (32 bit) to the usermessage.",
		"prefix": "umsg.Long"
	},
	"umsg.PoolString": {
		"body": [
			"umsg.PoolString(${1:string})$0"
		],
		"description": "Inferior version of util.AddNetworkString\n\nThe string specified will be networked to the client and receive a identifying number, which will be sent instead of the string to optimize networking.",
		"prefix": "umsg.PoolString"
	},
	"umsg.Short": {
		"body": [
			"umsg.Short(${1:short})$0"
		],
		"description": "Writes a signed short (16 bit) to the usermessage.",
		"prefix": "umsg.Short"
	},
	"umsg.Start": {
		"body": [
			"umsg.Start(${1:name}, ${2:filter})$0"
		],
		"description": "You should be using net instead\n\nStarts a new usermessage.\n\nUsermessages have a limit of only 256 bytes!",
		"prefix": "umsg.Start"
	},
	"umsg.String": {
		"body": [
			"umsg.String(${1:string})$0"
		],
		"description": "Writes a null terminated string to the usermessage.",
		"prefix": "umsg.String"
	},
	"umsg.Vector": {
		"body": [
			"umsg.Vector(${1:vector})$0"
		],
		"description": "Writes a Vector to the usermessage.",
		"prefix": "umsg.Vector"
	},
	"umsg.VectorNormal": {
		"body": [
			"umsg.VectorNormal(${1:normal})$0"
		],
		"description": "Writes a vector normal to the usermessage.",
		"prefix": "umsg.VectorNormal"
	},
	"undo.AddEntity": {
		"body": [
			"undo.AddEntity(${1:ent})$0"
		],
		"description": "Adds an entity to the current undo block",
		"prefix": "undo.AddEntity"
	},
	"undo.AddFunction": {
		"body": [
			"undo.AddFunction(${1:func}, ${2:arguments})$0"
		],
		"description": "Adds a function to call when the current undo block is undone. Note that if an undo has a function, the player will always be notified when this undo is performed, even if the entity it is meant to undo no longer exists.",
		"prefix": "undo.AddFunction"
	},
	"undo.Create": {
		"body": [
			"undo.Create(${1:name})$0"
		],
		"description": "Begins a new undo entry",
		"prefix": "undo.Create"
	},
	"undo.Do_Undo": {
		"body": [
			"undo.Do_Undo(${1:tab})$0"
		],
		"description": "Processes an undo block (in table form). This is used internally by the undo manager when a player presses Z.\n\nYou should use `gm_undo` or `gm_undonum *num*` console commands instead of calling this function directly.",
		"prefix": "undo.Do_Undo"
	},
	"undo.Finish": {
		"body": [
			"undo.Finish(${1:NiceText})$0"
		],
		"description": "Completes an undo entry, and registers it with the player's client",
		"prefix": "undo.Finish"
	},
	"undo.GetTable": {
		"body": [
			"undo.GetTable()$0"
		],
		"description": "Serverside, returns a table containing all undo blocks of all players. Clientside, returns a table of the local player's undo blocks.",
		"prefix": "undo.GetTable"
	},
	"undo.MakeUIDirty": {
		"body": [
			"undo.MakeUIDirty()$0"
		],
		"description": "\nMakes the UI dirty - it will re-create the controls the next time it is viewed.",
		"prefix": "undo.MakeUIDirty"
	},
	"undo.ReplaceEntity": {
		"body": [
			"undo.ReplaceEntity(${1:from}, ${2:to})$0"
		],
		"description": "Replaces any instance of the \"from\" reference with the \"to\" reference, in any existing undo block. Returns true if something was replaced",
		"prefix": "undo.ReplaceEntity"
	},
	"undo.SetCustomUndoText": {
		"body": [
			"undo.SetCustomUndoText(${1:customText})$0"
		],
		"description": "Sets a custom undo text for the current undo block",
		"prefix": "undo.SetCustomUndoText"
	},
	"undo.SetPlayer": {
		"body": [
			"undo.SetPlayer(${1:ply})$0"
		],
		"description": "Sets the player which the current undo block belongs to",
		"prefix": "undo.SetPlayer"
	},
	"undo.SetupUI": {
		"body": [
			"undo.SetupUI()$0"
		],
		"description": "\nAdds a hook (CPanelPaint) to the control panel paint function so we can determine when it is being drawn.",
		"prefix": "undo.SetupUI"
	},
	"usermessage.GetTable": {
		"body": [
			"usermessage.GetTable()$0"
		],
		"description": "Returns a table of every usermessage hook",
		"prefix": "usermessage.GetTable"
	},
	"usermessage.Hook": {
		"body": [
			"usermessage.Hook(${1:name}, ${2:callback}, ${3:preArgs=nil})$0"
		],
		"description": "You should be using net instead\n\nSets a hook for the specified to be called when a usermessage with the specified name arrives.\n\nUsermessages have a limit of only 256 bytes!",
		"prefix": "usermessage.Hook"
	},
	"usermessage.IncomingMessage": {
		"body": [
			"usermessage.IncomingMessage(${1:name}, ${2:msg})$0"
		],
		"description": "\nCalled by the engine when a usermessage arrives, this method calls the hook function specified by usermessage.Hook if any.",
		"prefix": "usermessage.IncomingMessage"
	},
	"utf8.GetChar": {
		"body": [
			"utf8.GetChar(${1:str}, ${2:index})$0"
		],
		"description": "A UTF-8 compatible version of string.GetChar.",
		"prefix": "utf8.GetChar"
	},
	"utf8.char": {
		"body": [
			"utf8.char(${1:codepoints})$0"
		],
		"description": "Receives zero or more integers, converts each one to its corresponding UTF-8 byte sequence and returns a string with the concatenation of all these sequences.",
		"prefix": "utf8.char"
	},
	"utf8.codepoint": {
		"body": [
			"utf8.codepoint(${1:string}, ${2:startPos=1}, ${3:endPos=1})$0"
		],
		"description": "Returns the codepoints (as numbers) from all characters in the given string that start between byte position startPos and endPos. It raises an error if it meets any invalid byte sequence. This functions similarly to string.byte.",
		"prefix": "utf8.codepoint"
	},
	"utf8.codes": {
		"body": [
			"utf8.codes(${1:string})$0"
		],
		"description": "Returns an iterator (like string.gmatch) which returns both the position and codepoint of each utf8 character in the string. It raises an error if it meets any invalid byte sequence.",
		"prefix": "utf8.codes"
	},
	"utf8.force": {
		"body": [
			"utf8.force(${1:string})$0"
		],
		"description": "Forces a string to contain only valid UTF-8 data. Invalid sequences are replaced with U+FFFD (the Unicode replacement character).\n\nThis is a lazy way for users to ensure a string contains only valid UTF-8 data.",
		"prefix": "utf8.force"
	},
	"utf8.len": {
		"body": [
			"utf8.len(${1:string}, ${2:startPos=1}, ${3:endPos=-1})$0"
		],
		"description": "Returns the number of UTF-8 sequences in the given string between positions startPos and endPos (both inclusive). If it finds any invalid UTF-8 byte sequence, returns false as well as the position of the first invalid byte.",
		"prefix": "utf8.len"
	},
	"utf8.offset": {
		"body": [
			"utf8.offset(${1:string}, ${2:n}, ${3:startPos=1 when n>=0, -1 otherwise})$0"
		],
		"description": "Returns the byte-index of the n'th UTF-8-character after the given startPos (nil if none). startPos defaults to 1 when n is positive and -1 when n is negative. If n is zero, this function instead returns the byte-index of the UTF-8-character startPos lies within.",
		"prefix": "utf8.offset"
	},
	"utf8.sub": {
		"body": [
			"utf8.sub(${1:string}, ${2:StartPos}, ${3:EndPos=nil})$0"
		],
		"description": "A UTF-8 compatible version of string.sub.",
		"prefix": "utf8.sub"
	},
	"util.Active": {
		"body": [
			"util.Active()$0"
		],
		"description": "Returns if the user is currently picking an entity.",
		"prefix": "util.Active"
	},
	"util.AddNetworkString": {
		"body": [
			"util.AddNetworkString(${1:str})$0"
		],
		"description": "Adds the specified string to a string table, which will cache it and network it to all clients automatically.\nWhenever you want to create a net message with net.Start, you must add the name of that message as a networked string via this function.\n\nIf the passed string already exists, nothing will happen and the ID of the existing item will be returned.\n\nEach unique network name needs to be pooled once - do not put this function call into any other functions if you're using a constant string. Preferable place for this function is in a serverside lua file, or in a shared file with the net.Receive function.\nThe string table used for this function does not interfere with the engine string tables and has 2048 slots.",
		"prefix": "util.AddNetworkString"
	},
	"util.AimVector": {
		"body": [
			"util.AimVector(${1:ViewAngles}, ${2:ViewFOV}, ${3:x}, ${4:y}, ${5:scrWidth}, ${6:scrHeight})$0"
		],
		"description": "Function used to calculate aim vector from 2D screen position. It is used in SuperDOF calculate Distance.\n\nEssentially a generic version of gui.ScreenToVector.",
		"prefix": "util.AimVector"
	},
	"util.Base64Decode": {
		"body": [
			"util.Base64Decode(${1:str})$0"
		],
		"description": "Decodes the specified string from base64.",
		"prefix": "util.Base64Decode"
	},
	"util.Base64Encode": {
		"body": [
			"util.Base64Encode(${1:str})$0"
		],
		"description": "Encodes the specified string to base64.",
		"prefix": "util.Base64Encode"
	},
	"util.BlastDamage": {
		"body": [
			"util.BlastDamage(${1:inflictor}, ${2:attacker}, ${3:damageOrigin}, ${4:damageRadius}, ${5:damage})$0"
		],
		"description": "Applies explosion damage to all entities in the specified radius.",
		"prefix": "util.BlastDamage"
	},
	"util.BlastDamageInfo": {
		"body": [
			"util.BlastDamageInfo(${1:dmg}, ${2:damageOrigin}, ${3:damageRadius})$0"
		],
		"description": "Applies spherical damage based on damage info to all entities in the specified radius.",
		"prefix": "util.BlastDamageInfo"
	},
	"util.CRC": {
		"body": [
			"util.CRC(${1:stringToHash})$0"
		],
		"description": "Generates the [CRC Checksum](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) of the specified string.",
		"prefix": "util.CRC"
	},
	"util.Compress": {
		"body": [
			"util.Compress(${1:str})$0"
		],
		"description": "Compresses the given string using the [LZMA](https://en.wikipedia.org/wiki/LZMA) algorithm.\n\nUse with net.WriteData and net.ReadData for networking and  util.Decompress to decompress the data.",
		"prefix": "util.Compress"
	},
	"util.DateStamp": {
		"body": [
			"util.DateStamp()$0"
		],
		"description": "Returns the current date formatted like '2012-10-31 18-00-00'",
		"prefix": "util.DateStamp"
	},
	"util.Decal": {
		"body": [
			"util.Decal(${1:name}, ${2:start}, ${3:end}, ${4:filter=NULL})$0"
		],
		"description": "Performs a trace and paints a decal to the surface hit.",
		"prefix": "util.Decal"
	},
	"util.DecalEx": {
		"body": [
			"util.DecalEx(${1:material}, ${2:ent}, ${3:position}, ${4:normal}, ${5:color}, ${6:w}, ${7:h})$0"
		],
		"description": "Performs a trace and paints a decal to the surface hit.\n\nThis function has trouble spanning across multiple brushes on the map.",
		"prefix": "util.DecalEx"
	},
	"util.DecalMaterial": {
		"body": [
			"util.DecalMaterial(${1:decalName})$0"
		],
		"description": "Gets the full material path by the decal name. Used with util.DecalEx.",
		"prefix": "util.DecalMaterial"
	},
	"util.Decompress": {
		"body": [
			"util.Decompress(${1:compressedString}, ${2:maxSize=nil})$0"
		],
		"description": "Decompresses the given string using [LZMA](https://en.wikipedia.org/wiki/LZMA) algorithm. Used to decompress strings previously compressed with util.Compress.",
		"prefix": "util.Decompress"
	},
	"util.DistanceToLine": {
		"body": [
			"util.DistanceToLine(${1:lineStart}, ${2:lineEnd}, ${3:pointPos})$0"
		],
		"description": "Gets the distance between a line and a point in 3d space.",
		"prefix": "util.DistanceToLine"
	},
	"util.Effect": {
		"body": [
			"util.Effect(${1:effectName}, ${2:effectData}, ${3:allowOverride=true}, ${4:ignorePredictionOrRecipientFilter=nil})$0"
		],
		"description": "Creates an effect with the specified data.\n\nYou can find a list of built-in engine effects Effects. You can create your own. Example effects can be found [here](https://github.com/garrynewman/garrysmod/tree/master/garrysmod/gamemodes/sandbox/entities/effects) and [here](https://github.com/garrynewman/garrysmod/tree/master/garrysmod/gamemodes/base/entities/effects).\n\nFor Orange Box `.pcf` particles, see Global.ParticleEffect,  Global.ParticleEffectAttach and  Global.CreateParticleSystem.\n\nWhen dispatching an effect from the server, some values may be clamped for networking optimizations. Visit the Set accessors on CEffectData to see which ones are affected.\nYou will need to couple this function with Global.IsFirstTimePredicted if you want to use it in Prediction.",
		"prefix": "util.Effect"
	},
	"util.Finish": {
		"body": [
			"util.Finish(${1:tr})$0"
		],
		"description": "\n\nFinishes the world picking. This is called when a user presses their mouse after calling util.worldpicker.Start.",
		"prefix": "util.Finish"
	},
	"util.GetModelInfo": {
		"body": [
			"util.GetModelInfo(${1:mdl})$0"
		],
		"description": "Returns a table containing the info about the model.\n\nThis function will silently fail if used on models with following strings in them:\n* _shared\n* _anims\n* _gestures\n* _anim\n* _postures\n* _gst\n* _pst\n* _shd\n* _ss\n* _anm\n* _include",
		"prefix": "util.GetModelInfo"
	},
	"util.GetModelMeshes": {
		"body": [
			"util.GetModelMeshes(${1:model}, ${2:lod=0}, ${3:bodygroupMask=0})$0"
		],
		"description": "Returns a table of visual meshes of given model.\n\nThis does not work on brush models (`*number` models)\n\nSee also ENTITY:GetRenderMesh.",
		"prefix": "util.GetModelMeshes"
	},
	"util.GetPData": {
		"body": [
			"util.GetPData(${1:steamID}, ${2:name}, ${3:default})$0"
		],
		"description": "Gets PData of an offline player using their SteamID\nThis function internally uses Player:UniqueID, which can cause collisions (two or more players sharing the same PData entry). It's recommended that you don't use it. See the related wiki page for more information.",
		"prefix": "util.GetPData"
	},
	"util.GetPixelVisibleHandle": {
		"body": [
			"util.GetPixelVisibleHandle()$0"
		],
		"description": "Creates a new PixVis handle. See util.PixelVisible.",
		"prefix": "util.GetPixelVisibleHandle"
	},
	"util.GetPlayerTrace": {
		"body": [
			"util.GetPlayerTrace(${1:ply}, ${2:dir=ply:GetAimVector()})$0"
		],
		"description": "Utility function to quickly generate a trace table that starts at the players view position, and ends `32768` units along a specified direction.",
		"prefix": "util.GetPlayerTrace"
	},
	"util.GetSunInfo": {
		"body": [
			"util.GetSunInfo()$0"
		],
		"description": "Gets information about the sun position and obstruction or nil if there is no sun.",
		"prefix": "util.GetSunInfo"
	},
	"util.GetSurfaceData": {
		"body": [
			"util.GetSurfaceData(${1:id})$0"
		],
		"description": "Returns data of a surface property at given ID.",
		"prefix": "util.GetSurfaceData"
	},
	"util.GetSurfaceIndex": {
		"body": [
			"util.GetSurfaceIndex(${1:surfaceName})$0"
		],
		"description": "Returns the matching surface property index for the given surface property name.\n\nSee also util.GetSurfaceData and util.GetSurfacePropName for opposite function.",
		"prefix": "util.GetSurfaceIndex"
	},
	"util.GetSurfacePropName": {
		"body": [
			"util.GetSurfacePropName(${1:id})$0"
		],
		"description": "Returns the name of a surface property at given ID.\n\nSee also util.GetSurfaceData and util.GetSurfaceIndex for opposite function.",
		"prefix": "util.GetSurfacePropName"
	},
	"util.GetUserGroups": {
		"body": [
			"util.GetUserGroups()$0"
		],
		"description": "Returns a table of all SteamIDs that have a usergroup.\n\nThis returns the original usergroups table, changes done to this table are not retroactive and will only affect newly connected users",
		"prefix": "util.GetUserGroups"
	},
	"util.IntersectRayWithOBB": {
		"body": [
			"util.IntersectRayWithOBB(${1:rayStart}, ${2:rayDelta}, ${3:boxOrigin}, ${4:boxAngles}, ${5:boxMins}, ${6:boxMaxs})$0"
		],
		"description": "Performs a \"ray\" box intersection and returns position, normal and the fraction.",
		"prefix": "util.IntersectRayWithOBB"
	},
	"util.IntersectRayWithPlane": {
		"body": [
			"util.IntersectRayWithPlane(${1:rayOrigin}, ${2:rayDirection}, ${3:planePosition}, ${4:planeNormal})$0"
		],
		"description": "Performs a [ray-plane intersection](https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection) and returns the hit position or nil.",
		"prefix": "util.IntersectRayWithPlane"
	},
	"util.IsInWorld": {
		"body": [
			"util.IsInWorld(${1:position})$0"
		],
		"description": "Checks if a certain position is within the world bounds.",
		"prefix": "util.IsInWorld"
	},
	"util.IsModelLoaded": {
		"body": [
			"util.IsModelLoaded(${1:modelName})$0"
		],
		"description": "Checks if the model is loaded in the game.",
		"prefix": "util.IsModelLoaded"
	},
	"util.IsSkyboxVisibleFromPoint": {
		"body": [
			"util.IsSkyboxVisibleFromPoint(${1:position})$0"
		],
		"description": "Check whether the skybox is visible from the point specified.\n\nThis will always return true in fullbright maps.",
		"prefix": "util.IsSkyboxVisibleFromPoint"
	},
	"util.IsValidModel": {
		"body": [
			"util.IsValidModel(${1:modelName})$0"
		],
		"description": "Checks if the specified model is valid.\n\nA model is considered invalid in following cases:\n* Starts with a space or **maps**\n* Doesn't start with **models**\n* Contains any of the following:\n* * _gestures\n* * _animations\n* * _postures\n* * _gst\n* * _pst\n* * _shd\n* * _ss\n* * _anm\n* * .bsp\n* * cs_fix\n* On server: If the model isn't precached, if the model file doesn't exist on the disk\n* If precache failed\n* Model is the error model",
		"prefix": "util.IsValidModel"
	},
	"util.IsValidPhysicsObject": {
		"body": [
			"util.IsValidPhysicsObject(${1:ent}, ${2:physobj})$0"
		],
		"description": "Checks if given numbered physics object of given entity is valid or not. Most useful for ragdolls.",
		"prefix": "util.IsValidPhysicsObject"
	},
	"util.IsValidProp": {
		"body": [
			"util.IsValidProp(${1:modelName})$0"
		],
		"description": "Checks if the specified prop is valid.",
		"prefix": "util.IsValidProp"
	},
	"util.IsValidRagdoll": {
		"body": [
			"util.IsValidRagdoll(${1:ragdollName})$0"
		],
		"description": "Checks if the specified model name points to a valid ragdoll.",
		"prefix": "util.IsValidRagdoll"
	},
	"util.JSONToTable": {
		"body": [
			"util.JSONToTable(${1:json})$0"
		],
		"description": "Converts a JSON string to a Lua table.\n\nKeys are converted to numbers wherever possible. This means using Player:SteamID64 as keys won't work.\nThere is a limit of 15,000 keys total.\nThis will attempt cast the string keys \"inf\", \"nan\", \"true\", and \"false\" to their respective Lua values. This completely ignores nulls in arrays.\nColors will not have the color metatable.",
		"prefix": "util.JSONToTable"
	},
	"util.KeyValuesToTable": {
		"body": [
			"util.KeyValuesToTable(${1:keyValues}, ${2:usesEscapeSequences=false}, ${3:preserveKeyCase=false})$0"
		],
		"description": "Converts a KeyValue string to a Lua table.\n\nTable keys will not repeat, see util.KeyValuesToTablePreserveOrder.",
		"prefix": "util.KeyValuesToTable"
	},
	"util.KeyValuesToTablePreserveOrder": {
		"body": [
			"util.KeyValuesToTablePreserveOrder(${1:keyvals}, ${2:usesEscapeSequences=false}, ${3:preserveKeyCase=false})$0"
		],
		"description": "Similar to util.KeyValuesToTable but it also preserves order of keys.",
		"prefix": "util.KeyValuesToTablePreserveOrder"
	},
	"util.LocalToWorld": {
		"body": [
			"util.LocalToWorld(${1:ent}, ${2:lpos}, ${3:bonenum})$0"
		],
		"description": "Returns a vector in world coordinates based on an entity and local coordinates",
		"prefix": "util.LocalToWorld"
	},
	"util.NetworkIDToString": {
		"body": [
			"util.NetworkIDToString(${1:stringTableID})$0"
		],
		"description": "Returns the networked string associated with the given ID from the string table.",
		"prefix": "util.NetworkIDToString"
	},
	"util.NetworkStringToID": {
		"body": [
			"util.NetworkStringToID(${1:networkString})$0"
		],
		"description": "Returns the networked ID associated with the given string from the string table.",
		"prefix": "util.NetworkStringToID"
	},
	"util.NiceFloat": {
		"body": [
			"util.NiceFloat(${1:float})$0"
		],
		"description": "Formats a float by stripping off extra `0's` and `.'s`.",
		"prefix": "util.NiceFloat"
	},
	"util.ParticleTracer": {
		"body": [
			"util.ParticleTracer(${1:name}, ${2:startPos}, ${3:endPos}, ${4:doWhiz})$0"
		],
		"description": "Creates a tracer effect with the given parameters.",
		"prefix": "util.ParticleTracer"
	},
	"util.ParticleTracerEx": {
		"body": [
			"util.ParticleTracerEx(${1:name}, ${2:startPos}, ${3:endPos}, ${4:doWhiz}, ${5:entityIndex}, ${6:attachmentIndex})$0"
		],
		"description": "Creates a tracer effect with the given parameters.",
		"prefix": "util.ParticleTracerEx"
	},
	"util.PixelVisible": {
		"body": [
			"util.PixelVisible(${1:position}, ${2:radius}, ${3:PixVis})$0"
		],
		"description": "Returns the visibility of a sphere in the world.",
		"prefix": "util.PixelVisible"
	},
	"util.PointContents": {
		"body": [
			"util.PointContents(${1:position})$0"
		],
		"description": "Returns the contents of the position specified.",
		"prefix": "util.PointContents"
	},
	"util.PrecacheModel": {
		"body": [
			"util.PrecacheModel(${1:modelName})$0"
		],
		"description": "Precaches a model for later use. Model is cached after being loaded once.\n\nModelprecache is limited to 4096 unique models. When it reaches the limit the game will crash.\n",
		"prefix": "util.PrecacheModel"
	},
	"util.PrecacheSound": {
		"body": [
			"util.PrecacheSound(${1:soundName})$0"
		],
		"description": "Precaches a sound for later use. Sound is cached after being loaded once.\nSoundcache is limited to 16384 unique sounds on the server.\n\nBroken on purpose because hitting the limit above causes the server to shutdown\nUltimately does nothing on client, and only works with sound scripts, not direct paths.",
		"prefix": "util.PrecacheSound"
	},
	"util.QuickTrace": {
		"body": [
			"util.QuickTrace(${1:origin}, ${2:endpos}, ${3:filter=nil})$0"
		],
		"description": "Performs a trace with the given origin, direction and filter.",
		"prefix": "util.QuickTrace"
	},
	"util.RelativePathToFull": {
		"body": [
			"util.RelativePathToFull(${1:file})$0"
		],
		"description": "Will be removed.\n\nReturns the absolute system path the file relative to /garrysmod/.",
		"prefix": "util.RelativePathToFull"
	},
	"util.RemovePData": {
		"body": [
			"util.RemovePData(${1:steamID}, ${2:name})$0"
		],
		"description": "Removes PData of offline player using his SteamID.\n\nThis function internally uses Player:UniqueID, which can cause collisions (two or more players sharing the same PData entry). It's recommended that you don't use it. See the related wiki page for more information.",
		"prefix": "util.RemovePData"
	},
	"util.ScreenShake": {
		"body": [
			"util.ScreenShake(${1:pos}, ${2:amplitude}, ${3:frequency}, ${4:duration}, ${5:radius})$0"
		],
		"description": "Makes the screen shake",
		"prefix": "util.ScreenShake"
	},
	"util.SetPData": {
		"body": [
			"util.SetPData(${1:steamID}, ${2:name}, ${3:value})$0"
		],
		"description": "Sets PData for offline player using his SteamID\nThis function internally uses Player:UniqueID, which can cause collisions (two or more players sharing the same PData entry). It's recommended that you don't use it. See the related wiki page for more information.",
		"prefix": "util.SetPData"
	},
	"util.SharedRandom": {
		"body": [
			"util.SharedRandom(${1:uniqueName}, ${2:min}, ${3:max}, ${4:additionalSeed=0})$0"
		],
		"description": "Generates a random float value that should be the same on client and server.\n\nThis function is best used in a Predicted Hook",
		"prefix": "util.SharedRandom"
	},
	"util.SpriteTrail": {
		"body": [
			"util.SpriteTrail(${1:ent}, ${2:attachmentID}, ${3:color}, ${4:additive}, ${5:startWidth}, ${6:endWidth}, ${7:lifetime}, ${8:textureRes}, ${9:texture})$0"
		],
		"description": "Adds a trail to the specified entity.",
		"prefix": "util.SpriteTrail"
	},
	"util.Stack": {
		"body": [
			"util.Stack()$0"
		],
		"description": "Returns a new Stack object",
		"prefix": "util.Stack"
	},
	"util.Start": {
		"body": [
			"util.Start(${1:callback})$0"
		],
		"description": "Starts picking an entity in the world. This will suppress the next mouse click, and instead use it as a direction in the trace sent to the callback.",
		"prefix": "util.Start"
	},
	"util.SteamIDFrom64": {
		"body": [
			"util.SteamIDFrom64(${1:id})$0"
		],
		"description": "Given a 64bit SteamID will return a STEAM_0: style Steam ID",
		"prefix": "util.SteamIDFrom64"
	},
	"util.SteamIDTo64": {
		"body": [
			"util.SteamIDTo64(${1:id})$0"
		],
		"description": "Given a STEAM_0 style Steam ID will return a 64bit Steam ID",
		"prefix": "util.SteamIDTo64"
	},
	"util.StringToType": {
		"body": [
			"util.StringToType(${1:str}, ${2:typename})$0"
		],
		"description": "Converts a string to the specified type.\n\nThis can be useful when dealing with ConVars.",
		"prefix": "util.StringToType"
	},
	"util.TableToJSON": {
		"body": [
			"util.TableToJSON(${1:table}, ${2:prettyPrint=false})$0"
		],
		"description": "Converts a table to a JSON string.\nAll integers will be converted to decimals (5 -> 5.0).\nAll keys are strings in the JSON format, so all keys will be converted to strings!\nThis will produce invalid JSON if the provided table contains nan or inf values.",
		"prefix": "util.TableToJSON"
	},
	"util.TableToKeyValues": {
		"body": [
			"util.TableToKeyValues(${1:table}, ${2:parentKey=TableToKeyValues})$0"
		],
		"description": "Converts the given table into a key value string.",
		"prefix": "util.TableToKeyValues"
	},
	"util.Timer": {
		"body": [
			"util.Timer(${1:startdelay=0})$0"
		],
		"description": "Creates a timer object.",
		"prefix": "util.Timer"
	},
	"util.TimerCycle": {
		"body": [
			"util.TimerCycle()$0"
		],
		"description": "Returns the time since this function has been last called",
		"prefix": "util.TimerCycle"
	},
	"util.TraceEntity": {
		"body": [
			"util.TraceEntity(${1:tracedata}, ${2:ent})$0"
		],
		"description": "Runs a trace using the entity's collisionmodel between two points. This does not take the entity's angles into account and will trace its unrotated collisionmodel.\n\nClientside entities will not be hit by traces.",
		"prefix": "util.TraceEntity"
	},
	"util.TraceEntityHull": {
		"body": [
			"util.TraceEntityHull(${1:ent1}, ${2:ent2})$0"
		],
		"description": "This function is broken and returns the same values all the time\nTraces from one entity to another.",
		"prefix": "util.TraceEntityHull"
	},
	"util.TraceHull": {
		"body": [
			"util.TraceHull(${1:TraceData})$0"
		],
		"description": "Performs an AABB hull (axis-aligned bounding box, aka not rotated) trace with the given trace data.\n\nClientside entities will not be hit by traces.\n\nThis function may not always give desired results clientside due to certain physics mechanisms not existing on the client. Use it serverside for accurate results.",
		"prefix": "util.TraceHull"
	},
	"util.TraceLine": {
		"body": [
			"util.TraceLine(${1:TraceData})$0"
		],
		"description": "Performs a trace with the given trace data.\n\nClientside entities will not be hit by traces.",
		"prefix": "util.TraceLine"
	},
	"util.TypeToString": {
		"body": [
			"util.TypeToString(${1:input})$0"
		],
		"description": "Converts a type to a (nice, but still parsable) string",
		"prefix": "util.TypeToString"
	},
	"util.tobool": {
		"body": [
			"util.tobool(${1:input})$0"
		],
		"description": "You should use Global.tobool instead.\n\nConverts string or a number to a bool, if possible. Alias of Global.tobool.",
		"prefix": "util.tobool"
	},
	"vgui.Create": {
		"body": [
			"vgui.Create(${1:classname}, ${2:parent=nil}, ${3:name=nil})$0"
		],
		"description": "Creates a panel by the specified classname.\nCustom VGUI elements are not loaded instantly. Use GM:OnGamemodeLoaded to create them on startup.",
		"prefix": "vgui.Create"
	},
	"vgui.CreateFromTable": {
		"body": [
			"vgui.CreateFromTable(${1:metatable}, ${2:parent=nil}, ${3:name=nil})$0"
		],
		"description": "Creates a panel from table.",
		"prefix": "vgui.CreateFromTable"
	},
	"vgui.CreateX": {
		"body": [
			"vgui.CreateX(${1:class}, ${2:parent=nil}, ${3:name=nil})$0"
		],
		"description": " Creates a engine panel.",
		"prefix": "vgui.CreateX"
	},
	"vgui.CursorVisible": {
		"body": [
			"vgui.CursorVisible()$0"
		],
		"description": "Returns whenever the cursor is currently active and visible.",
		"prefix": "vgui.CursorVisible"
	},
	"vgui.FocusedHasParent": {
		"body": [
			"vgui.FocusedHasParent(${1:parent})$0"
		],
		"description": "Returns whether the currently focused panel is a child of the given one.",
		"prefix": "vgui.FocusedHasParent"
	},
	"vgui.GetControlTable": {
		"body": [
			"vgui.GetControlTable(${1:Panelname})$0"
		],
		"description": "Gets the method table of this panel. Does not return parent methods!",
		"prefix": "vgui.GetControlTable"
	},
	"vgui.GetHoveredPanel": {
		"body": [
			"vgui.GetHoveredPanel()$0"
		],
		"description": "Returns the panel the cursor is hovering above.\n\nThis returns a cached value that is only updated after rendering and `before` the next VGUI Think/Layout pass.\n\nie. it lags one frame behind panel layout and is completely unhelpful for PANEL:Paint if your panels are moving around under the mouse a lot every frame.",
		"prefix": "vgui.GetHoveredPanel"
	},
	"vgui.GetKeyboardFocus": {
		"body": [
			"vgui.GetKeyboardFocus()$0"
		],
		"description": "Returns the panel which is currently receiving keyboard input.",
		"prefix": "vgui.GetKeyboardFocus"
	},
	"vgui.GetWorldPanel": {
		"body": [
			"vgui.GetWorldPanel()$0"
		],
		"description": "Returns the global world panel which is the parent to all others, except for the HUD panel.\n\nSee also Global.GetHUDPanel.",
		"prefix": "vgui.GetWorldPanel"
	},
	"vgui.IsHoveringWorld": {
		"body": [
			"vgui.IsHoveringWorld()$0"
		],
		"description": "Returns whenever the cursor is hovering the world panel.",
		"prefix": "vgui.IsHoveringWorld"
	},
	"vgui.Register": {
		"body": [
			"vgui.Register(${1:classname}, ${2:panelTable}, ${3:baseName=Panel})$0"
		],
		"description": "Registers a panel for later creation.",
		"prefix": "vgui.Register"
	},
	"vgui.RegisterFile": {
		"body": [
			"vgui.RegisterFile(${1:file})$0"
		],
		"description": "Registers a new VGUI panel from a file.",
		"prefix": "vgui.RegisterFile"
	},
	"vgui.RegisterTable": {
		"body": [
			"vgui.RegisterTable(${1:panel}, ${2:base=Panel})$0"
		],
		"description": "Registers a table to use as a panel. All this function does is assigns Base key to your table and returns the table.",
		"prefix": "vgui.RegisterTable"
	},
	"video.Record": {
		"body": [
			"video.Record(${1:config})$0"
		],
		"description": "Attempts to create an IVideoWriter.",
		"prefix": "video.Record"
	},
	"weapons.Get": {
		"body": [
			"weapons.Get(${1:classname})$0"
		],
		"description": "Get a `copy` of weapon table by name. This function also inherits fields from the weapon's base class, unlike weapons.GetStored.\n This will only work on SWEP's, this means that this will not return anything for HL2 weapons. ",
		"prefix": "weapons.Get"
	},
	"weapons.GetList": {
		"body": [
			"weapons.GetList()$0"
		],
		"description": "Get a list of all the registered SWEPs. This does not include weapons added to spawnmenu manually.",
		"prefix": "weapons.GetList"
	},
	"weapons.GetStored": {
		"body": [
			"weapons.GetStored(${1:weapon_class})$0"
		],
		"description": "Gets the REAL weapon table, not a copy. The produced table does `not` inherit fields from the weapon's base class, unlike weapons.Get.\n\nModifying this table will modify what is stored by the weapons library. Take a copy or use weapons.Get to avoid this.",
		"prefix": "weapons.GetStored"
	},
	"weapons.IsBasedOn": {
		"body": [
			"weapons.IsBasedOn(${1:name}, ${2:base})$0"
		],
		"description": "Checks if name is based on base",
		"prefix": "weapons.IsBasedOn"
	},
	"weapons.OnLoaded": {
		"body": [
			"weapons.OnLoaded()$0"
		],
		"description": "\n\nCalled after all SWEPS have been loaded and runs baseclass.Set on each one.\n\nYou can retrieve all the currently registered SWEPS with weapons.GetList.\n\nThis is not called after a SWEP auto refresh, and thus the inherited baseclass functions retrieved with baseclass.Get will not be updated",
		"prefix": "weapons.OnLoaded"
	},
	"weapons.Register": {
		"body": [
			"weapons.Register(${1:swep_table}, ${2:classname})$0"
		],
		"description": "Used to register your SWEP with the engine.\n\nSub-tables provided in the first argument will not carry over their metatable, and will receive a BaseClass key if the table was merged with the base's. Userdata references, which includes Vectors, Angles, Entities, etc. will not be copied.",
		"prefix": "weapons.Register"
	},
	"widgets.PlayerTick": {
		"body": [
			"widgets.PlayerTick(${1:ply}, ${2:mv})$0"
		],
		"description": " Automatically called to update all widgets.",
		"prefix": "widgets.PlayerTick"
	},
	"widgets.RenderMe": {
		"body": [
			"widgets.RenderMe(${1:ent})$0"
		],
		"description": "Renders a widget. Normally you won't need to call this.",
		"prefix": "widgets.RenderMe"
	}
}