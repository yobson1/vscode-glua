{
	"Angle:Add": {
		"body": [
			"Add(${1:angle})$0"
		],
		"description": "Adds the values of the argument angle to the orignal angle.\n\nThis functions the same as angle1 + angle2 without creating a new angle object, skipping object construction and garbage collection.",
		"prefix": "Add"
	},
	"Angle:Div": {
		"body": [
			"Div(${1:scalar})$0"
		],
		"description": "Divides all values of the original angle by a scalar. This functions the same as angle1 / num without creating a new angle object, skipping object construction and garbage collection.",
		"prefix": "Div"
	},
	"Angle:Forward": {
		"body": [
			"Forward()$0"
		],
		"description": "Returns a normal vector facing in the direction that the angle points.",
		"prefix": "Forward"
	},
	"Angle:IsZero": {
		"body": [
			"IsZero()$0"
		],
		"description": "Returns whether the pitch, yaw and roll are 0 or not.",
		"prefix": "IsZero"
	},
	"Angle:Mul": {
		"body": [
			"Mul(${1:scalar})$0"
		],
		"description": "Multiplies a scalar to all the values of the orignal angle. This functions the same as num * angle without creating a new angle object, skipping object construction and garbage collection.",
		"prefix": "Mul"
	},
	"Angle:Normalize": {
		"body": [
			"Normalize()$0"
		],
		"description": "Normalizes the angles by applying a module with 360 to pitch, yaw and roll.",
		"prefix": "Normalize"
	},
	"Angle:Right": {
		"body": [
			"Right()$0"
		],
		"description": "Returns a normal vector facing in the direction that points right relative to the angle's direction.",
		"prefix": "Right"
	},
	"Angle:RotateAroundAxis": {
		"body": [
			"RotateAroundAxis(${1:axis}, ${2:rotation})$0"
		],
		"description": "Rotates the angle around the specified axis by the specified degrees.",
		"prefix": "RotateAroundAxis"
	},
	"Angle:Set": {
		"body": [
			"Set(${1:originalAngle})$0"
		],
		"description": "Copies pitch, yaw and roll from the second angle to the first.",
		"prefix": "Set"
	},
	"Angle:SetUnpacked": {
		"body": [
			"SetUnpacked(${1:p}, ${2:y}, ${3:r})$0"
		],
		"description": "Sets the p, y, and r of the angle.",
		"prefix": "SetUnpacked"
	},
	"Angle:SnapTo": {
		"body": [
			"SnapTo(${1:axis}, ${2:target})$0"
		],
		"description": "Snaps the angle to nearest interval of degrees.\n\nThis will modify the original angle too!",
		"prefix": "SnapTo"
	},
	"Angle:Sub": {
		"body": [
			"Sub(${1:angle})$0"
		],
		"description": "Subtracts the values of the argument angle to the orignal angle. This functions the same as angle1 - angle2 without creating a new angle object, skipping object construction and garbage collection.",
		"prefix": "Sub"
	},
	"Angle:ToTable": {
		"body": [
			"ToTable()$0"
		],
		"description": "Returns the angle as a table with three elements.",
		"prefix": "ToTable"
	},
	"Angle:Unpack": {
		"body": [
			"Unpack()$0"
		],
		"description": "Returns the pitch, yaw, and roll components of the angle.",
		"prefix": "Unpack"
	},
	"Angle:Up": {
		"body": [
			"Up()$0"
		],
		"description": "Returns a normal vector facing in the direction that points up relative to the angle's direction.",
		"prefix": "Up"
	},
	"Angle:Zero": {
		"body": [
			"Zero()$0"
		],
		"description": "Sets pitch, yaw and roll to 0.\nThis function is faster than doing it manually.",
		"prefix": "Zero"
	},
	"CEffectData:GetAngles": {
		"body": [
			"GetAngles()$0"
		],
		"description": "Returns the angles of the effect.",
		"prefix": "GetAngles"
	},
	"CEffectData:GetAttachment": {
		"body": [
			"GetAttachment()$0"
		],
		"description": "Returns the attachment ID for the effect.",
		"prefix": "GetAttachment"
	},
	"CEffectData:GetColor": {
		"body": [
			"GetColor()$0"
		],
		"description": "Returns byte which represents the color of the effect.",
		"prefix": "GetColor"
	},
	"CEffectData:GetDamageType": {
		"body": [
			"GetDamageType()$0"
		],
		"description": "Returns the damage type of the effect",
		"prefix": "GetDamageType"
	},
	"CEffectData:GetEntIndex": {
		"body": [
			"GetEntIndex()$0"
		],
		"description": "Returns the entity index of the entity set for the effect.",
		"prefix": "GetEntIndex"
	},
	"CEffectData:GetEntity": {
		"body": [
			"GetEntity()$0"
		],
		"description": "Returns the entity assigned to the effect.",
		"prefix": "GetEntity"
	},
	"CEffectData:GetFlags": {
		"body": [
			"GetFlags()$0"
		],
		"description": "Returns the flags of the effect.",
		"prefix": "GetFlags"
	},
	"CEffectData:GetHitBox": {
		"body": [
			"GetHitBox()$0"
		],
		"description": "Returns the hit box ID of the effect.",
		"prefix": "GetHitBox"
	},
	"CEffectData:GetMagnitude": {
		"body": [
			"GetMagnitude()$0"
		],
		"description": "Returns the magnitude of the effect.",
		"prefix": "GetMagnitude"
	},
	"CEffectData:GetMaterialIndex": {
		"body": [
			"GetMaterialIndex()$0"
		],
		"description": "Returns the material ID of the effect.",
		"prefix": "GetMaterialIndex"
	},
	"CEffectData:GetNormal": {
		"body": [
			"GetNormal()$0"
		],
		"description": "Returns the normalized direction vector of the effect.",
		"prefix": "GetNormal"
	},
	"CEffectData:GetOrigin": {
		"body": [
			"GetOrigin()$0"
		],
		"description": "Returns the origin position of the effect.",
		"prefix": "GetOrigin"
	},
	"CEffectData:GetRadius": {
		"body": [
			"GetRadius()$0"
		],
		"description": "Returns the radius of the effect.",
		"prefix": "GetRadius"
	},
	"CEffectData:GetScale": {
		"body": [
			"GetScale()$0"
		],
		"description": "Returns the scale of the effect.",
		"prefix": "GetScale"
	},
	"CEffectData:GetStart": {
		"body": [
			"GetStart()$0"
		],
		"description": "Returns the start position of the effect.",
		"prefix": "GetStart"
	},
	"CEffectData:GetSurfaceProp": {
		"body": [
			"GetSurfaceProp()$0"
		],
		"description": "Returns the surface property index of the effect.",
		"prefix": "GetSurfaceProp"
	},
	"CEffectData:SetAngles": {
		"body": [
			"SetAngles(${1:ang})$0"
		],
		"description": "Sets the angles of the effect.",
		"prefix": "SetAngles"
	},
	"CEffectData:SetAttachment": {
		"body": [
			"SetAttachment(${1:attachment})$0"
		],
		"description": "Sets the attachment id of the effect to be created with this effect data.\n\nThis is internally stored as an integer, but only the first 5 bits will be networked, effectively limiting this function to 0-31 range.",
		"prefix": "SetAttachment"
	},
	"CEffectData:SetColor": {
		"body": [
			"SetColor(${1:color})$0"
		],
		"description": "Sets the \"color\" of the effect.\n\nAll this does is provide an addition 8 bits of data for the effect to use. What this will actually do will vary from effect to effect, depending on how a specific effect uses this given data, if at all.\n\nInternally stored as an integer, but only first 8 bits are networked, effectively limiting this function to 0-255 range.",
		"prefix": "SetColor"
	},
	"CEffectData:SetDamageType": {
		"body": [
			"SetDamageType(${1:damageType})$0"
		],
		"description": "Sets the damage type of the effect to be created with this effect data.",
		"prefix": "SetDamageType"
	},
	"CEffectData:SetEntIndex": {
		"body": [
			"SetEntIndex(${1:entIndex})$0"
		],
		"description": "Sets the entity of the effect via its index.",
		"prefix": "SetEntIndex"
	},
	"CEffectData:SetEntity": {
		"body": [
			"SetEntity(${1:entity})$0"
		],
		"description": "Sets the entity of the effect to be created with this effect data.",
		"prefix": "SetEntity"
	},
	"CEffectData:SetFlags": {
		"body": [
			"SetFlags(${1:flags})$0"
		],
		"description": "Sets the flags of the effect.\n\nInternally stored as an integer, but only first 8 bits are networked, effectively limiting this function to 0-255 range.",
		"prefix": "SetFlags"
	},
	"CEffectData:SetHitBox": {
		"body": [
			"SetHitBox(${1:hitBoxIndex})$0"
		],
		"description": "Sets the hit box index of the effect.\n\nInternally stored as an integer, but only first 11 bits are networked, effectively limiting this function to 0-2047 range.",
		"prefix": "SetHitBox"
	},
	"CEffectData:SetMagnitude": {
		"body": [
			"SetMagnitude(${1:magnitude})$0"
		],
		"description": "Sets the magnitude of the effect.\nInternally stored as a float with 12 bit precision for networking purposes, limited to range of 0-1023.",
		"prefix": "SetMagnitude"
	},
	"CEffectData:SetMaterialIndex": {
		"body": [
			"SetMaterialIndex(${1:materialIndex})$0"
		],
		"description": "Sets the material index of the effect.\n\nInternally stored as an integer, but only first 12 bits are networked, effectively limiting this function to 0-4095 range.",
		"prefix": "SetMaterialIndex"
	},
	"CEffectData:SetNormal": {
		"body": [
			"SetNormal(${1:normal})$0"
		],
		"description": "Sets the normalized (length=1) direction vector of the effect to be created with this effect data. This **must** be a normalized vector for networking purposes.",
		"prefix": "SetNormal"
	},
	"CEffectData:SetOrigin": {
		"body": [
			"SetOrigin(${1:origin})$0"
		],
		"description": "Sets the origin of the effect to be created with this effect data.\nLimited to world bounds (+-16386 on every axis) and has horrible networking precision. (17 bit float per component)",
		"prefix": "SetOrigin"
	},
	"CEffectData:SetRadius": {
		"body": [
			"SetRadius(${1:radius})$0"
		],
		"description": "Sets the radius of the effect to be created with this effect data.\n\nInternally stored as a float, but networked as a 10bit float, and is clamped to 0-1023 range.",
		"prefix": "SetRadius"
	},
	"CEffectData:SetScale": {
		"body": [
			"SetScale(${1:scale})$0"
		],
		"description": "Sets the scale of the effect to be created with this effect data.",
		"prefix": "SetScale"
	},
	"CEffectData:SetStart": {
		"body": [
			"SetStart(${1:start})$0"
		],
		"description": "Sets the start of the effect to be created with this effect data.\nLimited to world bounds (+-16386 on every axis) and has horrible networking precision. (17 bit float per component)",
		"prefix": "SetStart"
	},
	"CEffectData:SetSurfaceProp": {
		"body": [
			"SetSurfaceProp(${1:surfaceProperties})$0"
		],
		"description": "Sets the surface property index of the effect.\nInternally stored as an integer, but only first 8 bits are networked, effectively limiting this function to `-1`-`254` range.(yes, that's not a mistake)",
		"prefix": "SetSurfaceProp"
	},
	"CLuaEmitter:Add": {
		"body": [
			"Add(${1:material}, ${2:position})$0"
		],
		"description": "Creates a new CLuaParticle with the given material and position.",
		"prefix": "Add"
	},
	"CLuaEmitter:Draw": {
		"body": [
			"Draw()$0"
		],
		"description": "Manually renders all particles the emitter has created.",
		"prefix": "Draw"
	},
	"CLuaEmitter:Finish": {
		"body": [
			"Finish()$0"
		],
		"description": "Removes the emitter, making it no longer usable from Lua. If particles remain, the emitter will be removed when all particles die.",
		"prefix": "Finish"
	},
	"CLuaEmitter:GetNumActiveParticles": {
		"body": [
			"GetNumActiveParticles()$0"
		],
		"description": "Returns the amount of active particles of this emitter.",
		"prefix": "GetNumActiveParticles"
	},
	"CLuaEmitter:GetPos": {
		"body": [
			"GetPos()$0"
		],
		"description": "Returns the position of this emitter. This is set when creating the emitter with Global.ParticleEmitter.",
		"prefix": "GetPos"
	},
	"CLuaEmitter:Is3D": {
		"body": [
			"Is3D()$0"
		],
		"description": "Returns whether this emitter is 3D or not. This is set when creating the emitter with Global.ParticleEmitter.",
		"prefix": "Is3D"
	},
	"CLuaEmitter:IsValid": {
		"body": [
			"IsValid()$0"
		],
		"description": "Returns whether this CLuaEmitter is valid or not.",
		"prefix": "IsValid"
	},
	"CLuaEmitter:SetBBox": {
		"body": [
			"SetBBox(${1:mins}, ${2:maxs})$0"
		],
		"description": "Sets the bounding box for this emitter.\n\nUsually the bounding box is automatically determined by the particles, but this function overrides it.",
		"prefix": "SetBBox"
	},
	"CLuaEmitter:SetNearClip": {
		"body": [
			"SetNearClip(${1:distanceMin}, ${2:distanceMax})$0"
		],
		"description": "This function sets the the distance between the render camera and the emitter at which the particles should start fading and at which distance fade ends ( alpha becomes 0 ).",
		"prefix": "SetNearClip"
	},
	"CLuaEmitter:SetNoDraw": {
		"body": [
			"SetNoDraw(${1:noDraw})$0"
		],
		"description": "Prevents all particles of the emitter from automatically drawing.",
		"prefix": "SetNoDraw"
	},
	"CLuaEmitter:SetParticleCullRadius": {
		"body": [
			"SetParticleCullRadius(${1:radius})$0"
		],
		"description": "The function name has not much in common with its actual function, it applies a radius to every particles that affects the building of the bounding box, as it, usually is constructed by the particle that has the lowest x, y and z and the highest x, y and z, this function just adds/subtracts the radius and inflates the bounding box.",
		"prefix": "SetParticleCullRadius"
	},
	"CLuaEmitter:SetPos": {
		"body": [
			"SetPos(${1:position})$0"
		],
		"description": "Sets the position of the particle emitter.",
		"prefix": "SetPos"
	},
	"CLuaLocomotion:Approach": {
		"body": [
			"Approach(${1:goal}, ${2:goalweight})$0"
		],
		"description": "Sets the location we want to get to",
		"prefix": "Approach"
	},
	"CLuaLocomotion:ClearStuck": {
		"body": [
			"ClearStuck()$0"
		],
		"description": "Removes the stuck status from the bot",
		"prefix": "ClearStuck"
	},
	"CLuaLocomotion:FaceTowards": {
		"body": [
			"FaceTowards(${1:goal})$0"
		],
		"description": "Sets the direction we want to face",
		"prefix": "FaceTowards"
	},
	"CLuaLocomotion:GetAcceleration": {
		"body": [
			"GetAcceleration()$0"
		],
		"description": "Returns the acceleration speed",
		"prefix": "GetAcceleration"
	},
	"CLuaLocomotion:GetCurrentAcceleration": {
		"body": [
			"GetCurrentAcceleration()$0"
		],
		"description": "Returns the current acceleration as a vector",
		"prefix": "GetCurrentAcceleration"
	},
	"CLuaLocomotion:GetDeathDropHeight": {
		"body": [
			"GetDeathDropHeight()$0"
		],
		"description": "Gets the height the bot is scared to fall from",
		"prefix": "GetDeathDropHeight"
	},
	"CLuaLocomotion:GetDeceleration": {
		"body": [
			"GetDeceleration()$0"
		],
		"description": "Gets the deceleration speed",
		"prefix": "GetDeceleration"
	},
	"CLuaLocomotion:GetGravity": {
		"body": [
			"GetGravity()$0"
		],
		"description": "Returns the locomotion's gravity.",
		"prefix": "GetGravity"
	},
	"CLuaLocomotion:GetGroundMotionVector": {
		"body": [
			"GetGroundMotionVector()$0"
		],
		"description": "Return unit vector in XY plane describing our direction of motion - even if we are currently not moving",
		"prefix": "GetGroundMotionVector"
	},
	"CLuaLocomotion:GetJumpHeight": {
		"body": [
			"GetJumpHeight()$0"
		],
		"description": "Gets the height of the bot's jump",
		"prefix": "GetJumpHeight"
	},
	"CLuaLocomotion:GetMaxJumpHeight": {
		"body": [
			"GetMaxJumpHeight()$0"
		],
		"description": "Returns maximum jump height of this CLuaLocomotion.",
		"prefix": "GetMaxJumpHeight"
	},
	"CLuaLocomotion:GetMaxYawRate": {
		"body": [
			"GetMaxYawRate()$0"
		],
		"description": "Returns the max rate at which the NextBot can visually rotate.",
		"prefix": "GetMaxYawRate"
	},
	"CLuaLocomotion:GetNextBot": {
		"body": [
			"GetNextBot()$0"
		],
		"description": "Returns the NextBot this locomotion is associated with.",
		"prefix": "GetNextBot"
	},
	"CLuaLocomotion:GetStepHeight": {
		"body": [
			"GetStepHeight()$0"
		],
		"description": "Gets the max height the bot can step up",
		"prefix": "GetStepHeight"
	},
	"CLuaLocomotion:GetVelocity": {
		"body": [
			"GetVelocity()$0"
		],
		"description": "Returns the current movement velocity as a vector",
		"prefix": "GetVelocity"
	},
	"CLuaLocomotion:IsAreaTraversable": {
		"body": [
			"IsAreaTraversable(${1:area})$0"
		],
		"description": "Returns whether this CLuaLocomotion can reach and/or traverse/move in given CNavArea.",
		"prefix": "IsAreaTraversable"
	},
	"CLuaLocomotion:IsAttemptingToMove": {
		"body": [
			"IsAttemptingToMove()$0"
		],
		"description": "Returns true if we're trying to move.",
		"prefix": "IsAttemptingToMove"
	},
	"CLuaLocomotion:IsClimbingOrJumping": {
		"body": [
			"IsClimbingOrJumping()$0"
		],
		"description": "Returns true of the locomotion engine is jumping or climbing",
		"prefix": "IsClimbingOrJumping"
	},
	"CLuaLocomotion:IsOnGround": {
		"body": [
			"IsOnGround()$0"
		],
		"description": "Returns whether the nextbot this locomotion is attached to is on ground or not.",
		"prefix": "IsOnGround"
	},
	"CLuaLocomotion:IsStuck": {
		"body": [
			"IsStuck()$0"
		],
		"description": "Returns true if we're stuck",
		"prefix": "IsStuck"
	},
	"CLuaLocomotion:IsUsingLadder": {
		"body": [
			"IsUsingLadder()$0"
		],
		"description": "Returns whether or not the target in question is on a ladder or not.",
		"prefix": "IsUsingLadder"
	},
	"CLuaLocomotion:Jump": {
		"body": [
			"Jump()$0"
		],
		"description": "Makes the bot jump. It must be on ground (Entity:IsOnGround) and its model must have `ACT_JUMP` activity.",
		"prefix": "Jump"
	},
	"CLuaLocomotion:JumpAcrossGap": {
		"body": [
			"JumpAcrossGap(${1:landingGoal}, ${2:landingForward})$0"
		],
		"description": "Makes the bot jump across a gap. The bot must be on ground (Entity:IsOnGround) and its model must have `ACT_JUMP` activity.",
		"prefix": "JumpAcrossGap"
	},
	"CLuaLocomotion:SetAcceleration": {
		"body": [
			"SetAcceleration(${1:speed})$0"
		],
		"description": "Sets the acceleration speed",
		"prefix": "SetAcceleration"
	},
	"CLuaLocomotion:SetDeathDropHeight": {
		"body": [
			"SetDeathDropHeight(${1:height})$0"
		],
		"description": "Sets the height the bot is scared to fall from.",
		"prefix": "SetDeathDropHeight"
	},
	"CLuaLocomotion:SetDeceleration": {
		"body": [
			"SetDeceleration(${1:deceleration})$0"
		],
		"description": "Sets the deceleration speed.",
		"prefix": "SetDeceleration"
	},
	"CLuaLocomotion:SetDesiredSpeed": {
		"body": [
			"SetDesiredSpeed(${1:speed})$0"
		],
		"description": "Sets movement speed.",
		"prefix": "SetDesiredSpeed"
	},
	"CLuaLocomotion:SetGravity": {
		"body": [
			"SetGravity(${1:gravity})$0"
		],
		"description": "Sets the locomotion's gravity.\n\nWith values 0 or below, or even lower positive values, the nextbot will start to drift sideways, use CLuaLocomotion:SetVelocity to counteract this.",
		"prefix": "SetGravity"
	},
	"CLuaLocomotion:SetJumpHeight": {
		"body": [
			"SetJumpHeight(${1:height})$0"
		],
		"description": "Sets the height of the bot's jump",
		"prefix": "SetJumpHeight"
	},
	"CLuaLocomotion:SetMaxYawRate": {
		"body": [
			"SetMaxYawRate(${1:yawRate})$0"
		],
		"description": "Sets the max rate at which the NextBot can visually rotate. This will not affect moving or pathing.",
		"prefix": "SetMaxYawRate"
	},
	"CLuaLocomotion:SetStepHeight": {
		"body": [
			"SetStepHeight(${1:height})$0"
		],
		"description": "Sets the max height the bot can step up",
		"prefix": "SetStepHeight"
	},
	"CLuaLocomotion:SetVelocity": {
		"body": [
			"SetVelocity(${1:velocity})$0"
		],
		"description": "Sets the current movement velocity",
		"prefix": "SetVelocity"
	},
	"CLuaParticle:GetAirResistance": {
		"body": [
			"GetAirResistance()$0"
		],
		"description": "Returns the air resistance of the particle.",
		"prefix": "GetAirResistance"
	},
	"CLuaParticle:GetAngleVelocity": {
		"body": [
			"GetAngleVelocity()$0"
		],
		"description": "Returns the angular velocity of the particle",
		"prefix": "GetAngleVelocity"
	},
	"CLuaParticle:GetAngles": {
		"body": [
			"GetAngles()$0"
		],
		"description": "Returns the current orientation of the particle.",
		"prefix": "GetAngles"
	},
	"CLuaParticle:GetBounce": {
		"body": [
			"GetBounce()$0"
		],
		"description": "Returns the 'bounciness' of the particle.",
		"prefix": "GetBounce"
	},
	"CLuaParticle:GetColor": {
		"body": [
			"GetColor()$0"
		],
		"description": "Returns the color of the particle.",
		"prefix": "GetColor"
	},
	"CLuaParticle:GetDieTime": {
		"body": [
			"GetDieTime()$0"
		],
		"description": "Returns the amount of time in seconds after which the particle will be destroyed.",
		"prefix": "GetDieTime"
	},
	"CLuaParticle:GetEndAlpha": {
		"body": [
			"GetEndAlpha()$0"
		],
		"description": "Returns the alpha value that the particle will reach on its death.",
		"prefix": "GetEndAlpha"
	},
	"CLuaParticle:GetEndLength": {
		"body": [
			"GetEndLength()$0"
		],
		"description": "Returns the length that the particle will reach on its death.",
		"prefix": "GetEndLength"
	},
	"CLuaParticle:GetEndSize": {
		"body": [
			"GetEndSize()$0"
		],
		"description": "Returns the size that the particle will reach on its death.",
		"prefix": "GetEndSize"
	},
	"CLuaParticle:GetGravity": {
		"body": [
			"GetGravity()$0"
		],
		"description": "Returns the gravity of the particle.",
		"prefix": "GetGravity"
	},
	"CLuaParticle:GetLifeTime": {
		"body": [
			"GetLifeTime()$0"
		],
		"description": "Returns the 'life time' of the particle, how long the particle existed since its creation.\n\nThis value will always be between 0 and CLuaParticle:GetDieTime.\n\n\nIt changes automatically as time goes.\n\nIt can be manipulated using CLuaParticle:SetLifeTime.\n\n\nIf the life time of the particle will be more than CLuaParticle:GetDieTime, it will be removed.",
		"prefix": "GetLifeTime"
	},
	"CLuaParticle:GetMaterial": {
		"body": [
			"GetMaterial()$0"
		],
		"description": "Returns the current material of the particle.",
		"prefix": "GetMaterial"
	},
	"CLuaParticle:GetPos": {
		"body": [
			"GetPos()$0"
		],
		"description": "Returns the absolute position of the particle.",
		"prefix": "GetPos"
	},
	"CLuaParticle:GetRoll": {
		"body": [
			"GetRoll()$0"
		],
		"description": "Returns the current rotation of the particle in radians, this should only be used for 2D particles.",
		"prefix": "GetRoll"
	},
	"CLuaParticle:GetRollDelta": {
		"body": [
			"GetRollDelta()$0"
		],
		"description": "Returns the current rotation speed of the particle in radians, this should only be used for 2D particles.",
		"prefix": "GetRollDelta"
	},
	"CLuaParticle:GetStartAlpha": {
		"body": [
			"GetStartAlpha()$0"
		],
		"description": "Returns the alpha value which the particle has when it's created.",
		"prefix": "GetStartAlpha"
	},
	"CLuaParticle:GetStartLength": {
		"body": [
			"GetStartLength()$0"
		],
		"description": "Returns the length which the particle has when it's created.",
		"prefix": "GetStartLength"
	},
	"CLuaParticle:GetStartSize": {
		"body": [
			"GetStartSize()$0"
		],
		"description": "Returns the size which the particle has when it's created.",
		"prefix": "GetStartSize"
	},
	"CLuaParticle:GetVelocity": {
		"body": [
			"GetVelocity()$0"
		],
		"description": "Returns the current velocity of the particle.",
		"prefix": "GetVelocity"
	},
	"CLuaParticle:SetAirResistance": {
		"body": [
			"SetAirResistance(${1:airResistance})$0"
		],
		"description": "Sets the air resistance of the the particle.",
		"prefix": "SetAirResistance"
	},
	"CLuaParticle:SetAngleVelocity": {
		"body": [
			"SetAngleVelocity(${1:angVel})$0"
		],
		"description": "Sets the angular velocity of the the particle.",
		"prefix": "SetAngleVelocity"
	},
	"CLuaParticle:SetAngles": {
		"body": [
			"SetAngles(${1:ang})$0"
		],
		"description": "Sets the angles of the particle.",
		"prefix": "SetAngles"
	},
	"CLuaParticle:SetBounce": {
		"body": [
			"SetBounce(${1:bounce})$0"
		],
		"description": "Sets the 'bounciness' of the the particle.",
		"prefix": "SetBounce"
	},
	"CLuaParticle:SetCollide": {
		"body": [
			"SetCollide(${1:shouldCollide})$0"
		],
		"description": "Sets the whether the particle should collide with the world or not.",
		"prefix": "SetCollide"
	},
	"CLuaParticle:SetCollideCallback": {
		"body": [
			"SetCollideCallback(${1:collideFunc})$0"
		],
		"description": "Sets the function that gets called whenever the particle collides with the world.",
		"prefix": "SetCollideCallback"
	},
	"CLuaParticle:SetColor": {
		"body": [
			"SetColor(${1:r}, ${2:g}, ${3:b})$0"
		],
		"description": "Sets the color of the particle.",
		"prefix": "SetColor"
	},
	"CLuaParticle:SetDieTime": {
		"body": [
			"SetDieTime(${1:dieTime})$0"
		],
		"description": "Sets the time where the particle will be removed.",
		"prefix": "SetDieTime"
	},
	"CLuaParticle:SetEndAlpha": {
		"body": [
			"SetEndAlpha(${1:endAlpha})$0"
		],
		"description": "Sets the alpha value of the particle that it will reach when it dies.",
		"prefix": "SetEndAlpha"
	},
	"CLuaParticle:SetEndLength": {
		"body": [
			"SetEndLength(${1:endLength})$0"
		],
		"description": "Sets the length of the particle that it will reach when it dies.",
		"prefix": "SetEndLength"
	},
	"CLuaParticle:SetEndSize": {
		"body": [
			"SetEndSize(${1:endSize})$0"
		],
		"description": "Sets the size of the particle that it will reach when it dies.",
		"prefix": "SetEndSize"
	},
	"CLuaParticle:SetGravity": {
		"body": [
			"SetGravity(${1:gravity})$0"
		],
		"description": "Sets the directional gravity aka. acceleration of the particle.",
		"prefix": "SetGravity"
	},
	"CLuaParticle:SetLifeTime": {
		"body": [
			"SetLifeTime(${1:lifeTime})$0"
		],
		"description": "Sets the 'life time' of the particle, how long the particle existed since its creation.\n\nThis value should always be between 0 and CLuaParticle:GetDieTime.\n\n\nIt changes automatically as time goes.\n\n\nIf the life time of the particle will be more than CLuaParticle:GetDieTime, it will be removed.",
		"prefix": "SetLifeTime"
	},
	"CLuaParticle:SetLighting": {
		"body": [
			"SetLighting(${1:useLighting})$0"
		],
		"description": "Sets whether the particle should be affected by lighting.",
		"prefix": "SetLighting"
	},
	"CLuaParticle:SetMaterial": {
		"body": [
			"SetMaterial(${1:mat})$0"
		],
		"description": "Sets the material of the particle.",
		"prefix": "SetMaterial"
	},
	"CLuaParticle:SetNextThink": {
		"body": [
			"SetNextThink(${1:nextThink})$0"
		],
		"description": "Sets when the particles think function should be called next, this uses the synchronized server time returned by Global.CurTime.",
		"prefix": "SetNextThink"
	},
	"CLuaParticle:SetPos": {
		"body": [
			"SetPos(${1:pos})$0"
		],
		"description": "Sets the absolute position of the particle.",
		"prefix": "SetPos"
	},
	"CLuaParticle:SetRoll": {
		"body": [
			"SetRoll(${1:roll})$0"
		],
		"description": "Sets the roll of the particle in radians. This should only be used for 2D particles.",
		"prefix": "SetRoll"
	},
	"CLuaParticle:SetRollDelta": {
		"body": [
			"SetRollDelta(${1:rollDelta})$0"
		],
		"description": "Sets the rotation speed of the particle in radians. This should only be used for 2D particles.",
		"prefix": "SetRollDelta"
	},
	"CLuaParticle:SetStartAlpha": {
		"body": [
			"SetStartAlpha(${1:startAlpha})$0"
		],
		"description": "Sets the initial alpha value of the particle.",
		"prefix": "SetStartAlpha"
	},
	"CLuaParticle:SetStartLength": {
		"body": [
			"SetStartLength(${1:startLength})$0"
		],
		"description": "Sets the initial length value of the particle.",
		"prefix": "SetStartLength"
	},
	"CLuaParticle:SetStartSize": {
		"body": [
			"SetStartSize(${1:startSize})$0"
		],
		"description": "Sets the initial size value of the particle.",
		"prefix": "SetStartSize"
	},
	"CLuaParticle:SetThinkFunction": {
		"body": [
			"SetThinkFunction(${1:thinkFunc})$0"
		],
		"description": "Sets the think function of the particle.",
		"prefix": "SetThinkFunction"
	},
	"CLuaParticle:SetVelocity": {
		"body": [
			"SetVelocity(${1:vel})$0"
		],
		"description": "Sets the velocity of the particle.",
		"prefix": "SetVelocity"
	},
	"CLuaParticle:SetVelocityScale": {
		"body": [
			"SetVelocityScale(${1:doScale=false})$0"
		],
		"description": "Scales the velocity based on the particle speed.",
		"prefix": "SetVelocityScale"
	},
	"CMoveData:AddKey": {
		"body": [
			"AddKey(${1:keys})$0"
		],
		"description": "Adds keys to the move data, as if player pressed them.",
		"prefix": "AddKey"
	},
	"CMoveData:GetAbsMoveAngles": {
		"body": [
			"GetAbsMoveAngles()$0"
		],
		"description": "Gets the aim angle. Seems to be same as CMoveData:GetAngles.",
		"prefix": "GetAbsMoveAngles"
	},
	"CMoveData:GetAngles": {
		"body": [
			"GetAngles()$0"
		],
		"description": "Gets the aim angle. On client is the same as Entity:GetAngles.",
		"prefix": "GetAngles"
	},
	"CMoveData:GetButtons": {
		"body": [
			"GetButtons()$0"
		],
		"description": "Gets which buttons are down",
		"prefix": "GetButtons"
	},
	"CMoveData:GetConstraintRadius": {
		"body": [
			"GetConstraintRadius()$0"
		],
		"description": "Returns the radius that constrains the players movement.",
		"prefix": "GetConstraintRadius"
	},
	"CMoveData:GetForwardSpeed": {
		"body": [
			"GetForwardSpeed()$0"
		],
		"description": "Returns the players forward speed.",
		"prefix": "GetForwardSpeed"
	},
	"CMoveData:GetImpulseCommand": {
		"body": [
			"GetImpulseCommand()$0"
		],
		"description": "Gets the number passed to \"impulse\" console command",
		"prefix": "GetImpulseCommand"
	},
	"CMoveData:GetMaxClientSpeed": {
		"body": [
			"GetMaxClientSpeed()$0"
		],
		"description": "Returns the maximum client speed of the player",
		"prefix": "GetMaxClientSpeed"
	},
	"CMoveData:GetMaxSpeed": {
		"body": [
			"GetMaxSpeed()$0"
		],
		"description": "Returns the maximum speed of the player.",
		"prefix": "GetMaxSpeed"
	},
	"CMoveData:GetMoveAngles": {
		"body": [
			"GetMoveAngles()$0"
		],
		"description": "Returns the angle the player is moving at. For more info, see CMoveData:SetMoveAngles.",
		"prefix": "GetMoveAngles"
	},
	"CMoveData:GetOldAngles": {
		"body": [
			"GetOldAngles()$0"
		],
		"description": "Gets the aim angle. Only works clientside, server returns same as CMoveData:GetAngles.",
		"prefix": "GetOldAngles"
	},
	"CMoveData:GetOldButtons": {
		"body": [
			"GetOldButtons()$0"
		],
		"description": "Get which buttons were down last frame",
		"prefix": "GetOldButtons"
	},
	"CMoveData:GetOrigin": {
		"body": [
			"GetOrigin()$0"
		],
		"description": "Gets the player's position.",
		"prefix": "GetOrigin"
	},
	"CMoveData:GetSideSpeed": {
		"body": [
			"GetSideSpeed()$0"
		],
		"description": "Returns the strafe speed of the player.",
		"prefix": "GetSideSpeed"
	},
	"CMoveData:GetUpSpeed": {
		"body": [
			"GetUpSpeed()$0"
		],
		"description": "Returns the vertical speed of the player. ( Z axis of CMoveData:GetVelocity )",
		"prefix": "GetUpSpeed"
	},
	"CMoveData:GetVelocity": {
		"body": [
			"GetVelocity()$0"
		],
		"description": "Gets the players velocity.\n\nThis will return Vector(0,0,0) sometimes when walking on props.",
		"prefix": "GetVelocity"
	},
	"CMoveData:KeyDown": {
		"body": [
			"KeyDown(${1:key})$0"
		],
		"description": "Returns whether the key is down or not",
		"prefix": "KeyDown"
	},
	"CMoveData:KeyPressed": {
		"body": [
			"KeyPressed(${1:key})$0"
		],
		"description": "Returns whether the key was pressed. If you want to check if the key is held down, try CMoveData:KeyDown",
		"prefix": "KeyPressed"
	},
	"CMoveData:KeyReleased": {
		"body": [
			"KeyReleased(${1:key})$0"
		],
		"description": "Returns whether the key was released",
		"prefix": "KeyReleased"
	},
	"CMoveData:KeyWasDown": {
		"body": [
			"KeyWasDown(${1:key})$0"
		],
		"description": "Returns whether the key was down or not.\n\n\n\n\nUnlike CMoveData:KeyDown, it will return false if CMoveData:KeyPressed is true and it will return true if CMoveData:KeyReleased is true.",
		"prefix": "KeyWasDown"
	},
	"CMoveData:SetAbsMoveAngles": {
		"body": [
			"SetAbsMoveAngles(${1:ang})$0"
		],
		"description": "Sets absolute move angles.( ? ) Doesn't seem to do anything.",
		"prefix": "SetAbsMoveAngles"
	},
	"CMoveData:SetAngles": {
		"body": [
			"SetAngles(${1:ang})$0"
		],
		"description": "Sets angles.\n\nThis function does nothing.",
		"prefix": "SetAngles"
	},
	"CMoveData:SetButtons": {
		"body": [
			"SetButtons(${1:buttons})$0"
		],
		"description": "Sets the pressed buttons on the move data",
		"prefix": "SetButtons"
	},
	"CMoveData:SetConstraintRadius": {
		"body": [
			"SetConstraintRadius(${1:radius})$0"
		],
		"description": "Sets the radius that constrains the players movement.\n\n\nIt is unknown what this function does as changing its values doesn't affect player movement.",
		"prefix": "SetConstraintRadius"
	},
	"CMoveData:SetForwardSpeed": {
		"body": [
			"SetForwardSpeed(${1:speed})$0"
		],
		"description": "Sets players forward speed.",
		"prefix": "SetForwardSpeed"
	},
	"CMoveData:SetImpulseCommand": {
		"body": [
			"SetImpulseCommand(${1:impulse})$0"
		],
		"description": "Sets the impulse command. This isn't actually utilised in the engine anywhere.",
		"prefix": "SetImpulseCommand"
	},
	"CMoveData:SetMaxClientSpeed": {
		"body": [
			"SetMaxClientSpeed(${1:maxSpeed})$0"
		],
		"description": "Sets the maximum player speed. Player won't be able to run or sprint faster then this value.\n\n\nThis also automatically sets CMoveData:SetMaxSpeed when used in the GM:SetupMove hook. You must set it manually in the GM:Move hook.\n\n\nThis must be called on both client and server to avoid prediction errors.\n\n\nThis will **not** reduce speed in air.\nSetting this to 0 will not make the player stationary. It won't do anything.",
		"prefix": "SetMaxClientSpeed"
	},
	"CMoveData:SetMaxSpeed": {
		"body": [
			"SetMaxSpeed(${1:maxSpeed})$0"
		],
		"description": "Sets the maximum speed of the player. This must match with CMoveData:SetMaxClientSpeed both, on server and client.\n\n\nDoesn't seem to be doing anything on it's own, use CMoveData:SetMaxClientSpeed instead.",
		"prefix": "SetMaxSpeed"
	},
	"CMoveData:SetMoveAngles": {
		"body": [
			"SetMoveAngles(${1:dir})$0"
		],
		"description": "Sets the serverside move angles, making the movement keys act as if player was facing that direction.\n\nThis does nothing clientside.",
		"prefix": "SetMoveAngles"
	},
	"CMoveData:SetOldAngles": {
		"body": [
			"SetOldAngles(${1:aimAng})$0"
		],
		"description": "Sets old aim angles. ( ? ) Doesn't seem to be doing anything.",
		"prefix": "SetOldAngles"
	},
	"CMoveData:SetOldButtons": {
		"body": [
			"SetOldButtons(${1:buttons})$0"
		],
		"description": "Sets the 'old' pressed buttons on the move data. These buttons are used to work out which buttons have been released, which have just been pressed and which are being held down.",
		"prefix": "SetOldButtons"
	},
	"CMoveData:SetOrigin": {
		"body": [
			"SetOrigin(${1:pos})$0"
		],
		"description": "Sets the players position.",
		"prefix": "SetOrigin"
	},
	"CMoveData:SetSideSpeed": {
		"body": [
			"SetSideSpeed(${1:speed})$0"
		],
		"description": "Sets players strafe speed.",
		"prefix": "SetSideSpeed"
	},
	"CMoveData:SetUpSpeed": {
		"body": [
			"SetUpSpeed(${1:speed})$0"
		],
		"description": "Sets vertical speed of the player. ( Z axis of CMoveData:SetVelocity )",
		"prefix": "SetUpSpeed"
	},
	"CMoveData:SetVelocity": {
		"body": [
			"SetVelocity(${1:velocity})$0"
		],
		"description": "Sets the player's velocity",
		"prefix": "SetVelocity"
	},
	"CNavArea:AddHidingSpot": {
		"body": [
			"AddHidingSpot(${1:pos}, ${2:flags=7})$0"
		],
		"description": "Adds a hiding spot onto this nav area.\n\nThere's a limit of 255 hiding spots per area.",
		"prefix": "AddHidingSpot"
	},
	"CNavArea:AddToClosedList": {
		"body": [
			"AddToClosedList()$0"
		],
		"description": "Adds this CNavArea to the closed list, a list of areas that have been checked by A* pathfinding algorithm.\n\nUsed in pathfinding via the [A* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm).\n\n\nMore information can be found on the Simple Pathfinding page.",
		"prefix": "AddToClosedList"
	},
	"CNavArea:AddToOpenList": {
		"body": [
			"AddToOpenList()$0"
		],
		"description": "Adds this CNavArea to the Open List.\n\nUsed in pathfinding via the [A* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm).\n\n\nMore information can be found on the Simple Pathfinding page.",
		"prefix": "AddToOpenList"
	},
	"CNavArea:ClearSearchLists": {
		"body": [
			"ClearSearchLists()$0"
		],
		"description": "Clears the open and closed lists for a new search.\n\nUsed in pathfinding via the [A* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm).\n\n\nMore information can be found on the Simple Pathfinding page.",
		"prefix": "ClearSearchLists"
	},
	"CNavArea:ComputeAdjacentConnectionHeightChange": {
		"body": [
			"ComputeAdjacentConnectionHeightChange(${1:navarea})$0"
		],
		"description": "Returns the height difference between the edges of two connected navareas.",
		"prefix": "ComputeAdjacentConnectionHeightChange"
	},
	"CNavArea:ComputeDirection": {
		"body": [
			"ComputeDirection(${1:pos})$0"
		],
		"description": "Returns the Enums/NavDir direction that the given vector faces on this CNavArea.",
		"prefix": "ComputeDirection"
	},
	"CNavArea:ComputeGroundHeightChange": {
		"body": [
			"ComputeGroundHeightChange(${1:navArea})$0"
		],
		"description": "Returns the height difference on the Z axis of the two CNavAreas. This is calculated from the center most point on both CNavAreas.",
		"prefix": "ComputeGroundHeightChange"
	},
	"CNavArea:ConnectTo": {
		"body": [
			"ConnectTo(${1:area})$0"
		],
		"description": "Connects this CNavArea to another CNavArea or CNavLadder with a one way connection. ( From this area to the target )\n\nSee CNavLadder:ConnectTo for making the connection from ladder to area.",
		"prefix": "ConnectTo"
	},
	"CNavArea:Contains": {
		"body": [
			"Contains(${1:pos})$0"
		],
		"description": "Returns true if this CNavArea contains the given vector.",
		"prefix": "Contains"
	},
	"CNavArea:Disconnect": {
		"body": [
			"Disconnect(${1:area})$0"
		],
		"description": "Disconnects this nav area from given area or ladder. (Only disconnects one way)",
		"prefix": "Disconnect"
	},
	"CNavArea:Draw": {
		"body": [
			"Draw()$0"
		],
		"description": "Draws this navarea on debug overlay.",
		"prefix": "Draw"
	},
	"CNavArea:DrawSpots": {
		"body": [
			"DrawSpots()$0"
		],
		"description": "Draws the hiding spots on debug overlay. This includes sniper/exposed spots too!",
		"prefix": "DrawSpots"
	},
	"CNavArea:GetAdjacentAreas": {
		"body": [
			"GetAdjacentAreas()$0"
		],
		"description": "Returns a table of all the CNavAreas that have a  ( one and two way ) connection **from** this CNavArea.\n\nIf an area has a one-way incoming connection to this CNavArea, then it will **not** be returned from this function, use CNavArea:GetIncomingConnections to get all one-way incoming connections.\n\nSee CNavArea:GetAdjacentAreasAtSide for a function that only returns areas from one side/direction.",
		"prefix": "GetAdjacentAreas"
	},
	"CNavArea:GetAdjacentAreasAtSide": {
		"body": [
			"GetAdjacentAreasAtSide(${1:navDir})$0"
		],
		"description": "Returns a table of all the CNavAreas that have a ( one and two way ) connection **from** this CNavArea in given direction.\n\nIf an area has a one-way incoming connection to this CNavArea, then it will **not** be returned from this function, use CNavArea:GetIncomingConnections to get all incoming connections.\n\nSee CNavArea:GetAdjacentAreas for a function that returns all areas from all sides/directions.",
		"prefix": "GetAdjacentAreasAtSide"
	},
	"CNavArea:GetAdjacentCount": {
		"body": [
			"GetAdjacentCount()$0"
		],
		"description": "Returns the amount of CNavAreas that have a connection ( one and two way ) **from** this CNavArea.\n\nSee CNavArea:GetAdjacentCountAtSide for a function that only returns area count from one side/direction.",
		"prefix": "GetAdjacentCount"
	},
	"CNavArea:GetAdjacentCountAtSide": {
		"body": [
			"GetAdjacentCountAtSide(${1:navDir})$0"
		],
		"description": "Returns the amount of CNavAreas that have a connection ( one or two way ) **from** this CNavArea in given direction.\n\nSee CNavArea:GetAdjacentCount for a function that returns CNavArea count from/in all sides/directions.",
		"prefix": "GetAdjacentCountAtSide"
	},
	"CNavArea:GetAttributes": {
		"body": [
			"GetAttributes()$0"
		],
		"description": "Returns the attribute mask for the given CNavArea.",
		"prefix": "GetAttributes"
	},
	"CNavArea:GetCenter": {
		"body": [
			"GetCenter()$0"
		],
		"description": "Returns the center most vector point for the given CNavArea.",
		"prefix": "GetCenter"
	},
	"CNavArea:GetClosestPointOnArea": {
		"body": [
			"GetClosestPointOnArea(${1:pos})$0"
		],
		"description": "Returns the closest point of this Nav Area from the given position.",
		"prefix": "GetClosestPointOnArea"
	},
	"CNavArea:GetCorner": {
		"body": [
			"GetCorner(${1:cornerid})$0"
		],
		"description": "Returns the vector position of the corner for the given CNavArea.",
		"prefix": "GetCorner"
	},
	"CNavArea:GetCostSoFar": {
		"body": [
			"GetCostSoFar()$0"
		],
		"description": "Returns the cost from starting area this area when pathfinding. Set by CNavArea:SetCostSoFar.\n\nUsed in pathfinding via the [A* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm).\n\n\nMore information can be found on the Simple Pathfinding page.",
		"prefix": "GetCostSoFar"
	},
	"CNavArea:GetExposedSpots": {
		"body": [
			"GetExposedSpots()$0"
		],
		"description": "Returns a table of very bad hiding spots in this area.\n\nSee also CNavArea:GetHidingSpots.",
		"prefix": "GetExposedSpots"
	},
	"CNavArea:GetExtentInfo": {
		"body": [
			"GetExtentInfo()$0"
		],
		"description": "Returns size info about the nav area.",
		"prefix": "GetExtentInfo"
	},
	"CNavArea:GetHidingSpots": {
		"body": [
			"GetHidingSpots(${1:type=1})$0"
		],
		"description": "Returns a table of good hiding spots in this area.\n\nSee also CNavArea:GetExposedSpots.",
		"prefix": "GetHidingSpots"
	},
	"CNavArea:GetID": {
		"body": [
			"GetID()$0"
		],
		"description": "Returns this CNavAreas unique ID.",
		"prefix": "GetID"
	},
	"CNavArea:GetIncomingConnections": {
		"body": [
			"GetIncomingConnections()$0"
		],
		"description": "Returns a table of all the CNavAreas that have a one-way connection **to** this CNavArea.\n\nIf a CNavArea has a two-way connection **to or from** this CNavArea then it will not be returned from this function, use CNavArea:GetAdjacentAreas to get outgoing ( one and two way ) connections.\n\nSee CNavArea:GetIncomingConnectionsAtSide for a function that returns one-way incoming connections from  only one side/direction.",
		"prefix": "GetIncomingConnections"
	},
	"CNavArea:GetIncomingConnectionsAtSide": {
		"body": [
			"GetIncomingConnectionsAtSide(${1:navDir})$0"
		],
		"description": "Returns a table of all the CNavAreas that have a one-way connection **to** this CNavArea from given direction.\n\nIf a CNavArea has a two-way connection **to or from** this CNavArea then it will not be returned from this function, use CNavArea:GetAdjacentAreas to get outgoing ( one and two way ) connections.\n\nSee CNavArea:GetIncomingConnections for a function that returns one-way incoming connections from  all sides/directions.",
		"prefix": "GetIncomingConnectionsAtSide"
	},
	"CNavArea:GetLadders": {
		"body": [
			"GetLadders()$0"
		],
		"description": "Returns all CNavLadders that have a ( one or two way ) connection **from** this CNavArea.\n\nSee CNavArea:GetLaddersAtSide for a function that only returns CNavLadders in given direction.",
		"prefix": "GetLadders"
	},
	"CNavArea:GetLaddersAtSide": {
		"body": [
			"GetLaddersAtSide(${1:navDir})$0"
		],
		"description": "Returns all CNavLadders that have a ( one or two way ) connection **from** ( one and two way ) this CNavArea in given direction.\n\nSee CNavArea:GetLadders for a function that returns CNavLadder from/in all sides/directions.",
		"prefix": "GetLaddersAtSide"
	},
	"CNavArea:GetParent": {
		"body": [
			"GetParent()$0"
		],
		"description": "Returns the parent CNavArea",
		"prefix": "GetParent"
	},
	"CNavArea:GetParentHow": {
		"body": [
			"GetParentHow()$0"
		],
		"description": "Returns how this CNavArea is connected to its parent.",
		"prefix": "GetParentHow"
	},
	"CNavArea:GetPlace": {
		"body": [
			"GetPlace()$0"
		],
		"description": "Returns the Place of the nav area.",
		"prefix": "GetPlace"
	},
	"CNavArea:GetRandomAdjacentAreaAtSide": {
		"body": [
			"GetRandomAdjacentAreaAtSide(${1:navDir})$0"
		],
		"description": "Returns a random CNavArea that has an outgoing ( one or two way ) connection **from** this CNavArea in given direction.",
		"prefix": "GetRandomAdjacentAreaAtSide"
	},
	"CNavArea:GetRandomPoint": {
		"body": [
			"GetRandomPoint()$0"
		],
		"description": "Returns a random point on the nav area.",
		"prefix": "GetRandomPoint"
	},
	"CNavArea:GetSizeX": {
		"body": [
			"GetSizeX()$0"
		],
		"description": "Returns the width this Nav Area.",
		"prefix": "GetSizeX"
	},
	"CNavArea:GetSizeY": {
		"body": [
			"GetSizeY()$0"
		],
		"description": "Returns the height of this Nav Area.",
		"prefix": "GetSizeY"
	},
	"CNavArea:GetTotalCost": {
		"body": [
			"GetTotalCost()$0"
		],
		"description": "Returns the total cost when passing from starting area to the goal area through this node. Set by CNavArea:SetTotalCost.\n\nUsed in pathfinding via the [A* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm).\n\n\nMore information can be found on the Simple Pathfinding page.",
		"prefix": "GetTotalCost"
	},
	"CNavArea:GetZ": {
		"body": [
			"GetZ(${1:pos})$0"
		],
		"description": "Returns the elevation of this Nav Area at the given position.",
		"prefix": "GetZ"
	},
	"CNavArea:HasAttributes": {
		"body": [
			"HasAttributes(${1:attribs})$0"
		],
		"description": "Returns true if the given CNavArea has this attribute flag set.",
		"prefix": "HasAttributes"
	},
	"CNavArea:IsBlocked": {
		"body": [
			"IsBlocked(${1:teamID=-2}, ${2:ignoreNavBlockers=false})$0"
		],
		"description": "Returns whether the nav area is blocked or not, i.e. whether it can be walked through or not.",
		"prefix": "IsBlocked"
	},
	"CNavArea:IsClosed": {
		"body": [
			"IsClosed()$0"
		],
		"description": "Returns whether this node is in the Closed List.\n\nUsed in pathfinding via the [A* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm).\n\n\nMore information can be found on the Simple Pathfinding page.",
		"prefix": "IsClosed"
	},
	"CNavArea:IsCompletelyVisible": {
		"body": [
			"IsCompletelyVisible(${1:area})$0"
		],
		"description": "Returns whether this CNavArea can completely (i.e. all corners of this area can see all corners of the given area) see the given CNavArea.",
		"prefix": "IsCompletelyVisible"
	},
	"CNavArea:IsConnected": {
		"body": [
			"IsConnected(${1:navArea})$0"
		],
		"description": "Returns whether this CNavArea has an outgoing ( one or two way ) connection **to** given CNavArea.\n\nSee CNavArea:IsConnectedAtSide for a function that only checks for outgoing connections in one direction.",
		"prefix": "IsConnected"
	},
	"CNavArea:IsConnectedAtSide": {
		"body": [
			"IsConnectedAtSide(${1:navArea}, ${2:navDirType})$0"
		],
		"description": "Returns whether this CNavArea has an outgoing ( one or two way ) connection **to** given CNavArea in given direction.\n\nSee CNavArea:IsConnected for a function that checks all sides.",
		"prefix": "IsConnectedAtSide"
	},
	"CNavArea:IsCoplanar": {
		"body": [
			"IsCoplanar(${1:navArea})$0"
		],
		"description": "Returns whether this Nav Area is in the same plane as the given one.",
		"prefix": "IsCoplanar"
	},
	"CNavArea:IsFlat": {
		"body": [
			"IsFlat()$0"
		],
		"description": "Returns whether this Nav Area is flat within the tolerance of the **nav_coplanar_slope_limit_displacement** and **nav_coplanar_slope_limit** convars.",
		"prefix": "IsFlat"
	},
	"CNavArea:IsOpen": {
		"body": [
			"IsOpen()$0"
		],
		"description": "Returns whether this area is in the Open List.\n\nUsed in pathfinding via the [A* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm).\n\n\nMore information can be found on the Simple Pathfinding page.",
		"prefix": "IsOpen"
	},
	"CNavArea:IsOpenListEmpty": {
		"body": [
			"IsOpenListEmpty()$0"
		],
		"description": "Returns whether the Open List is empty or not.\n\nUsed in pathfinding via the [A* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm).\n\n\nMore information can be found on the Simple Pathfinding page.",
		"prefix": "IsOpenListEmpty"
	},
	"CNavArea:IsOverlapping": {
		"body": [
			"IsOverlapping(${1:pos}, ${2:tolerance=0})$0"
		],
		"description": "Returns if this position overlaps the Nav Area within the given tolerance.",
		"prefix": "IsOverlapping"
	},
	"CNavArea:IsOverlappingArea": {
		"body": [
			"IsOverlappingArea(${1:navArea})$0"
		],
		"description": "Returns true if this CNavArea is overlapping the given CNavArea.",
		"prefix": "IsOverlappingArea"
	},
	"CNavArea:IsPartiallyVisible": {
		"body": [
			"IsPartiallyVisible(${1:pos}, ${2:ignoreEnt=NULL})$0"
		],
		"description": "Returns whether this CNavArea can see given position.",
		"prefix": "IsPartiallyVisible"
	},
	"CNavArea:IsPotentiallyVisible": {
		"body": [
			"IsPotentiallyVisible(${1:area})$0"
		],
		"description": "Returns whether this CNavArea can potentially see the given CNavArea.",
		"prefix": "IsPotentiallyVisible"
	},
	"CNavArea:IsRoughlySquare": {
		"body": [
			"IsRoughlySquare()$0"
		],
		"description": "Returns if we're shaped like a square.",
		"prefix": "IsRoughlySquare"
	},
	"CNavArea:IsUnderwater": {
		"body": [
			"IsUnderwater()$0"
		],
		"description": "Whether this Nav Area is placed underwater.",
		"prefix": "IsUnderwater"
	},
	"CNavArea:IsValid": {
		"body": [
			"IsValid()$0"
		],
		"description": "Returns whether this CNavArea is valid or not.",
		"prefix": "IsValid"
	},
	"CNavArea:IsVisible": {
		"body": [
			"IsVisible(${1:pos})$0"
		],
		"description": "Returns whether we can be seen from the given position.",
		"prefix": "IsVisible"
	},
	"CNavArea:PlaceOnGround": {
		"body": [
			"PlaceOnGround(${1:corner})$0"
		],
		"description": "Drops a corner or all corners of a CNavArea to the ground below it.",
		"prefix": "PlaceOnGround"
	},
	"CNavArea:PopOpenList": {
		"body": [
			"PopOpenList()$0"
		],
		"description": "Removes a CNavArea from the Open List with the lowest cost to traverse to from the starting node, and returns it.\n\nUsed in pathfinding via the [A* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm).\n\n\nMore information can be found on the Simple Pathfinding page.",
		"prefix": "PopOpenList"
	},
	"CNavArea:Remove": {
		"body": [
			"Remove()$0"
		],
		"description": "Removes the given nav area.",
		"prefix": "Remove"
	},
	"CNavArea:RemoveFromClosedList": {
		"body": [
			"RemoveFromClosedList()$0"
		],
		"description": "Removes this node from the Closed List.\n\nUsed in pathfinding via the [A* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm).\n\n\nMore information can be found on the Simple Pathfinding page.",
		"prefix": "RemoveFromClosedList"
	},
	"CNavArea:SetAttributes": {
		"body": [
			"SetAttributes(${1:attribs})$0"
		],
		"description": "Sets the attributes for given CNavArea.",
		"prefix": "SetAttributes"
	},
	"CNavArea:SetCorner": {
		"body": [
			"SetCorner(${1:corner}, ${2:position})$0"
		],
		"description": "Sets the position of a corner of a nav area.",
		"prefix": "SetCorner"
	},
	"CNavArea:SetCostSoFar": {
		"body": [
			"SetCostSoFar(${1:cost})$0"
		],
		"description": "Sets the cost from starting area this area when pathfinding.\n\nUsed in pathfinding via the [A* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm).\n\n\nMore information can be found on the Simple Pathfinding page.",
		"prefix": "SetCostSoFar"
	},
	"CNavArea:SetParent": {
		"body": [
			"SetParent(${1:parent})$0"
		],
		"description": "Sets the new parent of this CNavArea.",
		"prefix": "SetParent"
	},
	"CNavArea:SetPlace": {
		"body": [
			"SetPlace(${1:place})$0"
		],
		"description": "Sets the Place of the nav area.\n\nThere is a limit of 256 Places per nav file.",
		"prefix": "SetPlace"
	},
	"CNavArea:SetTotalCost": {
		"body": [
			"SetTotalCost(${1:cost})$0"
		],
		"description": "Sets the total cost when passing from starting area to the goal area through this node.\n\nUsed in pathfinding via the [A* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm).\n\n\nMore information can be found on the Simple Pathfinding page.",
		"prefix": "SetTotalCost"
	},
	"CNavArea:UpdateOnOpenList": {
		"body": [
			"UpdateOnOpenList()$0"
		],
		"description": "Moves this open list to appropriate position based on its CNavArea:GetTotalCost compared to the total cost of other areas in the open list.\n\nUsed in pathfinding via the [A* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm).\n\n\nMore information can be found on the Simple Pathfinding page.",
		"prefix": "UpdateOnOpenList"
	},
	"CNavLadder:ConnectTo": {
		"body": [
			"ConnectTo(${1:area})$0"
		],
		"description": "Connects this ladder to a CNavArea with a one way connection. ( From this ladder to the target area ).\n\nSee CNavArea:ConnectTo for making the connection from area to ladder.",
		"prefix": "ConnectTo"
	},
	"CNavLadder:Disconnect": {
		"body": [
			"Disconnect(${1:area})$0"
		],
		"description": "Disconnects this ladder from given area in a single direction.",
		"prefix": "Disconnect"
	},
	"CNavLadder:GetBottom": {
		"body": [
			"GetBottom()$0"
		],
		"description": "Returns the bottom most position of the ladder.",
		"prefix": "GetBottom"
	},
	"CNavLadder:GetBottomArea": {
		"body": [
			"GetBottomArea()$0"
		],
		"description": "Returns the bottom area of the CNavLadder.",
		"prefix": "GetBottomArea"
	},
	"CNavLadder:GetID": {
		"body": [
			"GetID()$0"
		],
		"description": "Returns this CNavLadders unique ID.",
		"prefix": "GetID"
	},
	"CNavLadder:GetLength": {
		"body": [
			"GetLength()$0"
		],
		"description": "Returns the length of the ladder.",
		"prefix": "GetLength"
	},
	"CNavLadder:GetNormal": {
		"body": [
			"GetNormal()$0"
		],
		"description": "Returns the direction of this CNavLadder. ( The direction in which players back will be facing if they are looking directly at the ladder )",
		"prefix": "GetNormal"
	},
	"CNavLadder:GetPosAtHeight": {
		"body": [
			"GetPosAtHeight(${1:height})$0"
		],
		"description": "Returns the world position based on given height relative to the ladder.",
		"prefix": "GetPosAtHeight"
	},
	"CNavLadder:GetTop": {
		"body": [
			"GetTop()$0"
		],
		"description": "Returns the topmost position of the ladder.",
		"prefix": "GetTop"
	},
	"CNavLadder:GetTopBehindArea": {
		"body": [
			"GetTopBehindArea()$0"
		],
		"description": "Returns the top behind CNavArea of the CNavLadder.",
		"prefix": "GetTopBehindArea"
	},
	"CNavLadder:GetTopForwardArea": {
		"body": [
			"GetTopForwardArea()$0"
		],
		"description": "Returns the top forward CNavArea of the CNavLadder.",
		"prefix": "GetTopForwardArea"
	},
	"CNavLadder:GetTopLeftArea": {
		"body": [
			"GetTopLeftArea()$0"
		],
		"description": "Returns the top left CNavArea of the CNavLadder.",
		"prefix": "GetTopLeftArea"
	},
	"CNavLadder:GetTopRightArea": {
		"body": [
			"GetTopRightArea()$0"
		],
		"description": "Returns the top right CNavArea of the CNavLadder.",
		"prefix": "GetTopRightArea"
	},
	"CNavLadder:GetWidth": {
		"body": [
			"GetWidth()$0"
		],
		"description": "Returns the width of the ladder in Hammer Units.",
		"prefix": "GetWidth"
	},
	"CNavLadder:IsConnectedAtSide": {
		"body": [
			"IsConnectedAtSide(${1:navArea}, ${2:navDirType})$0"
		],
		"description": "Returns whether this CNavLadder has an outgoing ( one or two way ) connection **to** given CNavArea in given direction.",
		"prefix": "IsConnectedAtSide"
	},
	"CNavLadder:IsValid": {
		"body": [
			"IsValid()$0"
		],
		"description": "Returns whether this CNavLadder is valid or not.",
		"prefix": "IsValid"
	},
	"CNavLadder:Remove": {
		"body": [
			"Remove()$0"
		],
		"description": "Removes the given nav ladder.",
		"prefix": "Remove"
	},
	"CNavLadder:SetBottomArea": {
		"body": [
			"SetBottomArea(${1:area})$0"
		],
		"description": "Sets the bottom area of the CNavLadder.",
		"prefix": "SetBottomArea"
	},
	"CNavLadder:SetTopBehindArea": {
		"body": [
			"SetTopBehindArea(${1:area})$0"
		],
		"description": "Sets the top behind area of the CNavLadder.",
		"prefix": "SetTopBehindArea"
	},
	"CNavLadder:SetTopForwardArea": {
		"body": [
			"SetTopForwardArea(${1:area})$0"
		],
		"description": "Sets the top forward area of the CNavLadder.",
		"prefix": "SetTopForwardArea"
	},
	"CNavLadder:SetTopLeftArea": {
		"body": [
			"SetTopLeftArea(${1:area})$0"
		],
		"description": "Sets the top left area of the CNavLadder.",
		"prefix": "SetTopLeftArea"
	},
	"CNavLadder:SetTopRightArea": {
		"body": [
			"SetTopRightArea(${1:area})$0"
		],
		"description": "Sets the top right area of the CNavLadder.",
		"prefix": "SetTopRightArea"
	},
	"CNewParticleEffect:AddControlPoint": {
		"body": [
			"AddControlPoint(${1:cpID}, ${2:ent}, ${3:partAttachment}, ${4:entAttachment=0}, ${5:offset=Vector( 0, 0, 0 )})$0"
		],
		"description": "Adds a control point to the particle system.\n\nThis function will not work if the CNewParticleEffect:GetOwner entity is not valid",
		"prefix": "AddControlPoint"
	},
	"CNewParticleEffect:GetAutoUpdateBBox": {
		"body": [
			"GetAutoUpdateBBox()$0"
		],
		"description": "",
		"prefix": "GetAutoUpdateBBox"
	},
	"CNewParticleEffect:GetEffectName": {
		"body": [
			"GetEffectName()$0"
		],
		"description": "Returns the name of the particle effect this system is set to emit.",
		"prefix": "GetEffectName"
	},
	"CNewParticleEffect:GetHighestControlPoint": {
		"body": [
			"GetHighestControlPoint()$0"
		],
		"description": "Returns the highest control point number for given particle system.",
		"prefix": "GetHighestControlPoint"
	},
	"CNewParticleEffect:GetOwner": {
		"body": [
			"GetOwner()$0"
		],
		"description": "Returns the owner of the particle system, the entity the particle system is attached to.",
		"prefix": "GetOwner"
	},
	"CNewParticleEffect:IsFinished": {
		"body": [
			"IsFinished()$0"
		],
		"description": "Returns whether the particle system has finished emitting particles or not.",
		"prefix": "IsFinished"
	},
	"CNewParticleEffect:IsValid": {
		"body": [
			"IsValid()$0"
		],
		"description": "Returns whether the particle system is valid or not.",
		"prefix": "IsValid"
	},
	"CNewParticleEffect:IsViewModelEffect": {
		"body": [
			"IsViewModelEffect()$0"
		],
		"description": "Returns whether the particle system is intended to be used on a view model?",
		"prefix": "IsViewModelEffect"
	},
	"CNewParticleEffect:Render": {
		"body": [
			"Render()$0"
		],
		"description": "Forces the particle system to render using current rendering context.\n\nCan be used to render the particle system in vgui panels, etc.\n\nUsed in conjunction with CNewParticleEffect:SetShouldDraw.",
		"prefix": "Render"
	},
	"CNewParticleEffect:Restart": {
		"body": [
			"Restart()$0"
		],
		"description": "Forces the particle system to restart emitting particles.",
		"prefix": "Restart"
	},
	"CNewParticleEffect:SetControlPoint": {
		"body": [
			"SetControlPoint(${1:cpID}, ${2:value})$0"
		],
		"description": "Sets a value for given control point.",
		"prefix": "SetControlPoint"
	},
	"CNewParticleEffect:SetControlPointEntity": {
		"body": [
			"SetControlPointEntity(${1:child}, ${2:parent})$0"
		],
		"description": "Essentially makes child control point follow the parent entity.",
		"prefix": "SetControlPointEntity"
	},
	"CNewParticleEffect:SetControlPointForwardVector": {
		"body": [
			"SetControlPointForwardVector(${1:cpID}, ${2:forward})$0"
		],
		"description": "Sets the forward direction for given control point.",
		"prefix": "SetControlPointForwardVector"
	},
	"CNewParticleEffect:SetControlPointOrientation": {
		"body": [
			"SetControlPointOrientation(${1:cpID}, ${2:forward}, ${3:right}, ${4:up})$0"
		],
		"description": "Sets the orientation for given control point.",
		"prefix": "SetControlPointOrientation"
	},
	"CNewParticleEffect:SetControlPointParent": {
		"body": [
			"SetControlPointParent(${1:child}, ${2:parent})$0"
		],
		"description": "Essentially makes child control point follow the parent control point.",
		"prefix": "SetControlPointParent"
	},
	"CNewParticleEffect:SetControlPointRightVector": {
		"body": [
			"SetControlPointRightVector(${1:cpID}, ${2:right})$0"
		],
		"description": "Sets the right direction for given control point.",
		"prefix": "SetControlPointRightVector"
	},
	"CNewParticleEffect:SetControlPointUpVector": {
		"body": [
			"SetControlPointUpVector(${1:cpID}, ${2:upward})$0"
		],
		"description": "Sets the upward direction for given control point.",
		"prefix": "SetControlPointUpVector"
	},
	"CNewParticleEffect:SetIsViewModelEffect": {
		"body": [
			"SetIsViewModelEffect(${1:isViewModel})$0"
		],
		"description": "",
		"prefix": "SetIsViewModelEffect"
	},
	"CNewParticleEffect:SetShouldDraw": {
		"body": [
			"SetShouldDraw(${1:should})$0"
		],
		"description": "Forces the particle system to stop automatically rendering.\n\nUsed in conjunction with CNewParticleEffect:Render.",
		"prefix": "SetShouldDraw"
	},
	"CNewParticleEffect:SetSortOrigin": {
		"body": [
			"SetSortOrigin(${1:origin})$0"
		],
		"description": "Sets the sort origin for given particle system. This is used as a helper to determine which particles are in front of which.",
		"prefix": "SetSortOrigin"
	},
	"CNewParticleEffect:StartEmission": {
		"body": [
			"StartEmission(${1:infiniteOnly=false})$0"
		],
		"description": "Starts the particle emission.",
		"prefix": "StartEmission"
	},
	"CNewParticleEffect:StopEmission": {
		"body": [
			"StopEmission(${1:infiniteOnly=false}, ${2:removeAllParticles=false}, ${3:wakeOnStop=false})$0"
		],
		"description": "Stops the particle emission.",
		"prefix": "StopEmission"
	},
	"CNewParticleEffect:StopEmissionAndDestroyImmediately": {
		"body": [
			"StopEmissionAndDestroyImmediately()$0"
		],
		"description": "Stops particle emission and destroys all particles instantly. Also detaches the particle effect from the entity it was attached to.\n\nThis function will work identically to CNewParticleEffect:StopEmission( false, true ) if  CNewParticleEffect:GetOwner entity is not valid.\n\nConsider using CNewParticleEffect:StopEmission( false, true ) instead, which has same effect, but doesn't require owner entity, and does't detach the particle system from its entity.",
		"prefix": "StopEmissionAndDestroyImmediately"
	},
	"CRecipientFilter:AddAllPlayers": {
		"body": [
			"AddAllPlayers()$0"
		],
		"description": "Adds all players to the recipient filter.",
		"prefix": "AddAllPlayers"
	},
	"CRecipientFilter:AddPAS": {
		"body": [
			"AddPAS(${1:pos})$0"
		],
		"description": "Adds all players that are in the same [PAS (Potentially Audible Set)](https://developer.valvesoftware.com/wiki/PAS \"PAS - Valve Developer Community\") as this position.",
		"prefix": "AddPAS"
	},
	"CRecipientFilter:AddPVS": {
		"body": [
			"AddPVS(${1:Position})$0"
		],
		"description": "Adds all players that are in the same [PVS(Potential Visibility Set)](https://developer.valvesoftware.com/wiki/PVS \"PVS - Valve Developer Community\") as this position.",
		"prefix": "AddPVS"
	},
	"CRecipientFilter:AddPlayer": {
		"body": [
			"AddPlayer(${1:Player})$0"
		],
		"description": "Adds a player to the recipient filter",
		"prefix": "AddPlayer"
	},
	"CRecipientFilter:AddRecipientsByTeam": {
		"body": [
			"AddRecipientsByTeam(${1:teamid})$0"
		],
		"description": "Adds all players that are on the given team to the filter.",
		"prefix": "AddRecipientsByTeam"
	},
	"CRecipientFilter:GetCount": {
		"body": [
			"GetCount()$0"
		],
		"description": "Returns the number of valid players in the recipient filter.",
		"prefix": "GetCount"
	},
	"CRecipientFilter:GetPlayers": {
		"body": [
			"GetPlayers()$0"
		],
		"description": "Returns a table of all valid players currently in the recipient filter.",
		"prefix": "GetPlayers"
	},
	"CRecipientFilter:RemoveAllPlayers": {
		"body": [
			"RemoveAllPlayers()$0"
		],
		"description": "Removes all players from the recipient filter.",
		"prefix": "RemoveAllPlayers"
	},
	"CRecipientFilter:RemovePAS": {
		"body": [
			"RemovePAS(${1:position})$0"
		],
		"description": "Removes all players from the filter that are in Potentially Audible Set for given position.",
		"prefix": "RemovePAS"
	},
	"CRecipientFilter:RemovePVS": {
		"body": [
			"RemovePVS(${1:pos})$0"
		],
		"description": "Removes all players that can see this PVS from the recipient filter.",
		"prefix": "RemovePVS"
	},
	"CRecipientFilter:RemovePlayer": {
		"body": [
			"RemovePlayer(${1:Player})$0"
		],
		"description": "Removes the player from the recipient filter.",
		"prefix": "RemovePlayer"
	},
	"CRecipientFilter:RemoveRecipientsByTeam": {
		"body": [
			"RemoveRecipientsByTeam(${1:teamid})$0"
		],
		"description": "Removes all players that are on the given team from the filter.",
		"prefix": "RemoveRecipientsByTeam"
	},
	"CRecipientFilter:RemoveRecipientsNotOnTeam": {
		"body": [
			"RemoveRecipientsNotOnTeam(${1:teamid})$0"
		],
		"description": "Removes all players that are not on the given team from the filter.",
		"prefix": "RemoveRecipientsNotOnTeam"
	},
	"CSEnt:Remove": {
		"body": [
			"Remove()$0"
		],
		"description": "Removes the clientside entity",
		"prefix": "Remove"
	},
	"CSoundPatch:ChangePitch": {
		"body": [
			"ChangePitch(${1:pitch}, ${2:deltaTime=0})$0"
		],
		"description": "Adjust the pitch, alias the speed at which the sound is being played.\n\nThis invokes the GM:EntityEmitSound.",
		"prefix": "ChangePitch"
	},
	"CSoundPatch:ChangeVolume": {
		"body": [
			"ChangeVolume(${1:volume}, ${2:deltaTime=0})$0"
		],
		"description": "Adjusts the volume of the sound played.\nAppears to only work while the sound is being played.",
		"prefix": "ChangeVolume"
	},
	"CSoundPatch:FadeOut": {
		"body": [
			"FadeOut(${1:seconds})$0"
		],
		"description": "Fades out the volume of the sound from the current volume to 0 in the given amount of seconds.",
		"prefix": "FadeOut"
	},
	"CSoundPatch:GetDSP": {
		"body": [
			"GetDSP()$0"
		],
		"description": "Returns the DSP ( Digital Signal Processor ) effect for the sound.",
		"prefix": "GetDSP"
	},
	"CSoundPatch:GetPitch": {
		"body": [
			"GetPitch()$0"
		],
		"description": "Returns the current pitch.",
		"prefix": "GetPitch"
	},
	"CSoundPatch:GetSoundLevel": {
		"body": [
			"GetSoundLevel()$0"
		],
		"description": "Returns the current sound level.",
		"prefix": "GetSoundLevel"
	},
	"CSoundPatch:GetVolume": {
		"body": [
			"GetVolume()$0"
		],
		"description": "Returns the current volume.",
		"prefix": "GetVolume"
	},
	"CSoundPatch:IsPlaying": {
		"body": [
			"IsPlaying()$0"
		],
		"description": "Returns whenever the sound is being played.",
		"prefix": "IsPlaying"
	},
	"CSoundPatch:Play": {
		"body": [
			"Play()$0"
		],
		"description": "Starts to play the sound. This will reset the sound's volume and pitch to their default values. See CSoundPatch:PlayEx",
		"prefix": "Play"
	},
	"CSoundPatch:PlayEx": {
		"body": [
			"PlayEx(${1:volume}, ${2:pitch})$0"
		],
		"description": "Same as CSoundPatch:Play but with 2 extra arguments allowing to set volume and pitch directly.",
		"prefix": "PlayEx"
	},
	"CSoundPatch:SetDSP": {
		"body": [
			"SetDSP(${1:dsp})$0"
		],
		"description": "Sets the DSP (Digital Signal Processor) effect for the sound. Similar to Player:SetDSP but for individual sounds.\n\nThis will only apply if the sound is not playing.",
		"prefix": "SetDSP"
	},
	"CSoundPatch:SetSoundLevel": {
		"body": [
			"SetSoundLevel(${1:level})$0"
		],
		"description": "Sets the sound level in decibel.",
		"prefix": "SetSoundLevel"
	},
	"CSoundPatch:Stop": {
		"body": [
			"Stop()$0"
		],
		"description": "Stops the sound from being played.\n\nThis will not work if the entity attached to this sound patch (specified by Global.CreateSound) is invalid.",
		"prefix": "Stop"
	},
	"CTakeDamageInfo:AddDamage": {
		"body": [
			"AddDamage(${1:damageIncrease})$0"
		],
		"description": "Increases the damage by damageIncrease.",
		"prefix": "AddDamage"
	},
	"CTakeDamageInfo:GetAmmoType": {
		"body": [
			"GetAmmoType()$0"
		],
		"description": "Returns the ammo type used by the weapon that inflicted the damage.",
		"prefix": "GetAmmoType"
	},
	"CTakeDamageInfo:GetAttacker": {
		"body": [
			"GetAttacker()$0"
		],
		"description": "Returns the attacker ( character who originated the attack ), for example a player or an NPC that shot the weapon.",
		"prefix": "GetAttacker"
	},
	"CTakeDamageInfo:GetBaseDamage": {
		"body": [
			"GetBaseDamage()$0"
		],
		"description": "Returns the initial unmodified by skill level ( game.GetSkillLevel ) damage.",
		"prefix": "GetBaseDamage"
	},
	"CTakeDamageInfo:GetDamage": {
		"body": [
			"GetDamage()$0"
		],
		"description": "Returns the total damage.",
		"prefix": "GetDamage"
	},
	"CTakeDamageInfo:GetDamageBonus": {
		"body": [
			"GetDamageBonus()$0"
		],
		"description": "Gets the current bonus damage.",
		"prefix": "GetDamageBonus"
	},
	"CTakeDamageInfo:GetDamageCustom": {
		"body": [
			"GetDamageCustom()$0"
		],
		"description": "Gets the custom damage type. This is used by Day of Defeat: Source and Team Fortress 2 for extended damage info, but isn't used in Garry's Mod by default.",
		"prefix": "GetDamageCustom"
	},
	"CTakeDamageInfo:GetDamageForce": {
		"body": [
			"GetDamageForce()$0"
		],
		"description": "Returns a vector representing the damage force.\n\nCan be set with CTakeDamageInfo:SetDamageForce.",
		"prefix": "GetDamageForce"
	},
	"CTakeDamageInfo:GetDamagePosition": {
		"body": [
			"GetDamagePosition()$0"
		],
		"description": "Returns the position where the damage was or is going to be applied to.\n\nCan be set using CTakeDamageInfo:SetDamagePosition.",
		"prefix": "GetDamagePosition"
	},
	"CTakeDamageInfo:GetDamageType": {
		"body": [
			"GetDamageType()$0"
		],
		"description": "Returns a bitflag which indicates the damage type(s) of the damage.\n\nConsider using CTakeDamageInfo:IsDamageType instead. Value returned by this function can contain multiple damage types.",
		"prefix": "GetDamageType"
	},
	"CTakeDamageInfo:GetInflictor": {
		"body": [
			"GetInflictor()$0"
		],
		"description": "Returns the inflictor of the damage. This is not necessarily a weapon.\n\nFor hitscan weapons this is the weapon.\n\n\nFor projectile weapons this is the projectile.\n\n\n\n\n\nFor a more reliable method of getting the weapon that damaged an entity, use CTakeDamageInfo:GetAttacker with Player:GetActiveWeapon.",
		"prefix": "GetInflictor"
	},
	"CTakeDamageInfo:GetMaxDamage": {
		"body": [
			"GetMaxDamage()$0"
		],
		"description": "Returns the maximum damage.",
		"prefix": "GetMaxDamage"
	},
	"CTakeDamageInfo:GetReportedPosition": {
		"body": [
			"GetReportedPosition()$0"
		],
		"description": "Returns the initial, unmodified position where the damage occured.",
		"prefix": "GetReportedPosition"
	},
	"CTakeDamageInfo:IsBulletDamage": {
		"body": [
			"IsBulletDamage()$0"
		],
		"description": "Returns true if the damage was caused by a bullet.",
		"prefix": "IsBulletDamage"
	},
	"CTakeDamageInfo:IsDamageType": {
		"body": [
			"IsDamageType(${1:dmgType})$0"
		],
		"description": "Returns whenever the damageinfo contains the damage type specified.",
		"prefix": "IsDamageType"
	},
	"CTakeDamageInfo:IsExplosionDamage": {
		"body": [
			"IsExplosionDamage()$0"
		],
		"description": "Returns whenever the damageinfo contains explosion damage.",
		"prefix": "IsExplosionDamage"
	},
	"CTakeDamageInfo:IsFallDamage": {
		"body": [
			"IsFallDamage()$0"
		],
		"description": "Returns whenever the damageinfo contains fall damage.",
		"prefix": "IsFallDamage"
	},
	"CTakeDamageInfo:ScaleDamage": {
		"body": [
			"ScaleDamage(${1:scale})$0"
		],
		"description": "Scales the damage by the given value.",
		"prefix": "ScaleDamage"
	},
	"CTakeDamageInfo:SetAmmoType": {
		"body": [
			"SetAmmoType(${1:ammoType})$0"
		],
		"description": "Changes the ammo type used by the weapon that inflicted the damage.",
		"prefix": "SetAmmoType"
	},
	"CTakeDamageInfo:SetAttacker": {
		"body": [
			"SetAttacker(${1:ent})$0"
		],
		"description": "Sets the attacker ( character who originated the attack ) of the damage, for example a player or an NPC.",
		"prefix": "SetAttacker"
	},
	"CTakeDamageInfo:SetBaseDamage": {
		"body": [
			"SetBaseDamage(${1:})$0"
		],
		"description": "Sets the initial unmodified by skill level ( game.GetSkillLevel ) damage. This function will not update or touch CTakeDamageInfo:GetDamage.",
		"prefix": "SetBaseDamage"
	},
	"CTakeDamageInfo:SetDamage": {
		"body": [
			"SetDamage(${1:damage})$0"
		],
		"description": "Sets the amount of damage.",
		"prefix": "SetDamage"
	},
	"CTakeDamageInfo:SetDamageBonus": {
		"body": [
			"SetDamageBonus(${1:damage})$0"
		],
		"description": "Sets the bonus damage. Bonus damage isn't automatically applied, so this will have no outer effect by default.",
		"prefix": "SetDamageBonus"
	},
	"CTakeDamageInfo:SetDamageCustom": {
		"body": [
			"SetDamageCustom(${1:DamageType})$0"
		],
		"description": "Sets the custom damage type. This is used by Day of Defeat: Source and Team Fortress 2 for extended damage info, but isn't used in Garry's Mod by default.",
		"prefix": "SetDamageCustom"
	},
	"CTakeDamageInfo:SetDamageForce": {
		"body": [
			"SetDamageForce(${1:force})$0"
		],
		"description": "Sets the directional force of the damage.",
		"prefix": "SetDamageForce"
	},
	"CTakeDamageInfo:SetDamagePosition": {
		"body": [
			"SetDamagePosition(${1:pos})$0"
		],
		"description": "Sets the position of where the damage gets applied to.",
		"prefix": "SetDamagePosition"
	},
	"CTakeDamageInfo:SetDamageType": {
		"body": [
			"SetDamageType(${1:type})$0"
		],
		"description": "Sets the damage type.",
		"prefix": "SetDamageType"
	},
	"CTakeDamageInfo:SetInflictor": {
		"body": [
			"SetInflictor(${1:inflictor})$0"
		],
		"description": "Sets the inflictor of the damage for example a weapon.\n\nFor hitscan/bullet weapons this should the weapon.\n\n\nFor projectile ( rockets, etc ) weapons this should be the projectile.",
		"prefix": "SetInflictor"
	},
	"CTakeDamageInfo:SetMaxDamage": {
		"body": [
			"SetMaxDamage(${1:maxDamage})$0"
		],
		"description": "Sets the maximum damage the object can cause.",
		"prefix": "SetMaxDamage"
	},
	"CTakeDamageInfo:SetReportedPosition": {
		"body": [
			"SetReportedPosition(${1:pos})$0"
		],
		"description": "Sets the origin of the damage.",
		"prefix": "SetReportedPosition"
	},
	"CTakeDamageInfo:SubtractDamage": {
		"body": [
			"SubtractDamage(${1:damage})$0"
		],
		"description": "Subtracts the specified amount from the damage.",
		"prefix": "SubtractDamage"
	},
	"CUserCmd:ClearButtons": {
		"body": [
			"ClearButtons()$0"
		],
		"description": "Removes all keys from the command.\n\nIf you are looking to affect player movement, you may need to use CUserCmd:ClearMovement instead of clearing the buttons.",
		"prefix": "ClearButtons"
	},
	"CUserCmd:ClearMovement": {
		"body": [
			"ClearMovement()$0"
		],
		"description": "Clears the movement from the command.\n\nSee also CUserCmd:SetForwardMove, CUserCmd:SetSideMove and  CUserCmd:SetUpMove.",
		"prefix": "ClearMovement"
	},
	"CUserCmd:CommandNumber": {
		"body": [
			"CommandNumber()$0"
		],
		"description": "Returns an increasing number representing the index of the user cmd.\n\nThe value returned is occasionally 0 inside GM:CreateMove and GM:StartCommand. It is advised to check for a non-zero value if you wish to get the correct number.",
		"prefix": "CommandNumber"
	},
	"CUserCmd:GetButtons": {
		"body": [
			"GetButtons()$0"
		],
		"description": "Returns a bitflag indicating which buttons are pressed.",
		"prefix": "GetButtons"
	},
	"CUserCmd:GetForwardMove": {
		"body": [
			"GetForwardMove()$0"
		],
		"description": "The speed the client wishes to move forward with, negative if the clients wants to move backwards.",
		"prefix": "GetForwardMove"
	},
	"CUserCmd:GetImpulse": {
		"body": [
			"GetImpulse()$0"
		],
		"description": "Gets the current impulse from the client, usually 0.",
		"prefix": "GetImpulse"
	},
	"CUserCmd:GetMouseWheel": {
		"body": [
			"GetMouseWheel()$0"
		],
		"description": "Returns the scroll delta as whole number.",
		"prefix": "GetMouseWheel"
	},
	"CUserCmd:GetMouseX": {
		"body": [
			"GetMouseX()$0"
		],
		"description": "Returns the delta of the angular horizontal mouse movement of the player.",
		"prefix": "GetMouseX"
	},
	"CUserCmd:GetMouseY": {
		"body": [
			"GetMouseY()$0"
		],
		"description": "Returns the delta of the angular vertical mouse movement of the player.",
		"prefix": "GetMouseY"
	},
	"CUserCmd:GetSideMove": {
		"body": [
			"GetSideMove()$0"
		],
		"description": "The speed the client wishes to move sideways with, positive if it wants to move right, negative if it wants to move left.",
		"prefix": "GetSideMove"
	},
	"CUserCmd:GetUpMove": {
		"body": [
			"GetUpMove()$0"
		],
		"description": "The speed the client wishes to move up with, negative if the clients wants to move down.",
		"prefix": "GetUpMove"
	},
	"CUserCmd:GetViewAngles": {
		"body": [
			"GetViewAngles()$0"
		],
		"description": "Gets the direction the player is looking in.",
		"prefix": "GetViewAngles"
	},
	"CUserCmd:IsForced": {
		"body": [
			"IsForced()$0"
		],
		"description": "When players are not sending usercommands to the server (often due to lag), their last usercommand will be executed multiple times as a backup. This function returns true if that is happening.\n\nThis will never return true clientside.",
		"prefix": "IsForced"
	},
	"CUserCmd:KeyDown": {
		"body": [
			"KeyDown(${1:key})$0"
		],
		"description": "Returns true if the specified button(s) is pressed.",
		"prefix": "KeyDown"
	},
	"CUserCmd:RemoveKey": {
		"body": [
			"RemoveKey(${1:button})$0"
		],
		"description": "Removed a key bit from the current key bitflag.",
		"prefix": "RemoveKey"
	},
	"CUserCmd:SelectWeapon": {
		"body": [
			"SelectWeapon(${1:weapon})$0"
		],
		"description": "Forces the associated player to select a weapon. This is used internally in the default HL2 weapon selection HUD.\n\nThis may not work immediately if the current command is in prediction. Use input.SelectWeapon to switch the weapon from the client when the next available command can do so.\n\nThis is the ideal function to use to create a custom weapon selection HUD, as it allows prediction to run properly for WEAPON:Deploy and GM:PlayerSwitchWeapon",
		"prefix": "SelectWeapon"
	},
	"CUserCmd:SetButtons": {
		"body": [
			"SetButtons(${1:buttons})$0"
		],
		"description": "Sets the buttons as a bitflag. See also CUserCmd:GetButtons.\n\nIf you are looking to affect player movement, you may need to use CUserCmd:SetForwardMove instead of setting the keys.",
		"prefix": "SetButtons"
	},
	"CUserCmd:SetForwardMove": {
		"body": [
			"SetForwardMove(${1:speed})$0"
		],
		"description": "Sets speed the client wishes to move forward with, negative if the clients wants to move backwards.\n\nSee also CUserCmd:ClearMovement, CUserCmd:SetSideMove and CUserCmd:SetUpMove.",
		"prefix": "SetForwardMove"
	},
	"CUserCmd:SetImpulse": {
		"body": [
			"SetImpulse(${1:speed})$0"
		],
		"description": "Sets the impulse command to be sent to the server.\n\nHere are a few examples of impulse numbers:\n- `100` toggles their flashlight\n- `101` gives the player all Half-Life 2 weapons with `sv_cheats` set to `1`\n- `200` toggles holstering / restoring the current weapon\nWhen holstered, the `EF_NODRAW` flag is set on the active weapon.",
		"prefix": "SetImpulse"
	},
	"CUserCmd:SetMouseWheel": {
		"body": [
			"SetMouseWheel(${1:speed})$0"
		],
		"description": "Sets the scroll delta.",
		"prefix": "SetMouseWheel"
	},
	"CUserCmd:SetMouseX": {
		"body": [
			"SetMouseX(${1:speed})$0"
		],
		"description": "Sets the delta of the angular horizontal mouse movement of the player.\n\nSee also CUserCmd:SetMouseY.",
		"prefix": "SetMouseX"
	},
	"CUserCmd:SetMouseY": {
		"body": [
			"SetMouseY(${1:speed})$0"
		],
		"description": "Sets the delta of the angular vertical mouse movement of the player.\n\nSee also CUserCmd:SetMouseX.",
		"prefix": "SetMouseY"
	},
	"CUserCmd:SetSideMove": {
		"body": [
			"SetSideMove(${1:speed})$0"
		],
		"description": "Sets speed the client wishes to move sidewards with, positive to move right, negative to move left.\n\nSee also CUserCmd:SetForwardMove and  CUserCmd:SetUpMove.",
		"prefix": "SetSideMove"
	},
	"CUserCmd:SetUpMove": {
		"body": [
			"SetUpMove(${1:speed})$0"
		],
		"description": "Sets speed the client wishes to move upwards with, negative to move down.\n\nSee also CUserCmd:SetSideMove and  CUserCmd:SetForwardMove.",
		"prefix": "SetUpMove"
	},
	"CUserCmd:SetViewAngles": {
		"body": [
			"SetViewAngles(${1:viewAngle})$0"
		],
		"description": "Sets the direction the client wants to move in.\n\nThe pitch (vertical) angle should be clamped to +/- 89\u00c2\u00b0 to prevent the player's view from glitching.",
		"prefix": "SetViewAngles"
	},
	"CUserCmd:TickCount": {
		"body": [
			"TickCount()$0"
		],
		"description": "Returns tick count since joining the server.\n\nThis will always return 0 for bots.\n\nReturns 0 clientside during prediction calls. If you are trying to use CUserCmd:Set*() on the client in a movement or command hook, keep doing so till TickCount returns a non-zero number to maintain prediction.",
		"prefix": "TickCount"
	},
	"Color:SetUnpacked": {
		"body": [
			"SetUnpacked(${1:r}, ${2:g}, ${3:b}, ${4:a})$0"
		],
		"description": "Sets the red, green, blue, and alpha of the color.",
		"prefix": "SetUnpacked"
	},
	"Color:ToHSL": {
		"body": [
			"ToHSL()$0"
		],
		"description": "Converts a Color into HSL color space. This calls Global.ColorToHSL internally.",
		"prefix": "ToHSL"
	},
	"Color:ToHSV": {
		"body": [
			"ToHSV()$0"
		],
		"description": "Converts a Color into HSV color space. This calls Global.ColorToHSV internally.",
		"prefix": "ToHSV"
	},
	"Color:ToTable": {
		"body": [
			"ToTable()$0"
		],
		"description": "Returns the color as a table with four elements.",
		"prefix": "ToTable"
	},
	"Color:ToVector": {
		"body": [
			"ToVector()$0"
		],
		"description": "Translates the Color into a Vector, losing the alpha channel.\nThis will also range the values from 0 - 255 to 0 - 1\n\nr / 255 -> x\ng / 255 -> y\nb / 255 -> z\n\nThis is the opposite of Vector:ToColor",
		"prefix": "ToVector"
	},
	"Color:Unpack": {
		"body": [
			"Unpack()$0"
		],
		"description": "Returns the red, green, blue, and alpha of the color.",
		"prefix": "Unpack"
	},
	"ConVar:GetBool": {
		"body": [
			"GetBool()$0"
		],
		"description": "Tries to convert the current string value of a ConVar to a boolean.",
		"prefix": "GetBool"
	},
	"ConVar:GetDefault": {
		"body": [
			"GetDefault()$0"
		],
		"description": "Returns the default value of the ConVar",
		"prefix": "GetDefault"
	},
	"ConVar:GetFlags": {
		"body": [
			"GetFlags()$0"
		],
		"description": "Returns the Enums/FCVAR flags of the ConVar",
		"prefix": "GetFlags"
	},
	"ConVar:GetFloat": {
		"body": [
			"GetFloat()$0"
		],
		"description": "Attempts to convert the ConVar value to a float",
		"prefix": "GetFloat"
	},
	"ConVar:GetHelpText": {
		"body": [
			"GetHelpText()$0"
		],
		"description": "Returns the help text assigned to that convar.",
		"prefix": "GetHelpText"
	},
	"ConVar:GetInt": {
		"body": [
			"GetInt()$0"
		],
		"description": "Attempts to convert the ConVar value to a integer.",
		"prefix": "GetInt"
	},
	"ConVar:GetMax": {
		"body": [
			"GetMax()$0"
		],
		"description": "Returns the maximum value of the ConVar",
		"prefix": "GetMax"
	},
	"ConVar:GetMin": {
		"body": [
			"GetMin()$0"
		],
		"description": "Returns the minimum value of the ConVar",
		"prefix": "GetMin"
	},
	"ConVar:GetName": {
		"body": [
			"GetName()$0"
		],
		"description": "Returns the name of the ConVar.",
		"prefix": "GetName"
	},
	"ConVar:GetString": {
		"body": [
			"GetString()$0"
		],
		"description": "Returns the current ConVar value as a string.",
		"prefix": "GetString"
	},
	"ConVar:IsFlagSet": {
		"body": [
			"IsFlagSet(${1:flag})$0"
		],
		"description": "Returns whether the specified flag is set on the ConVar",
		"prefix": "IsFlagSet"
	},
	"ConVar:Revert": {
		"body": [
			"Revert()$0"
		],
		"description": "Reverts ConVar to its default value",
		"prefix": "Revert"
	},
	"ConVar:SetBool": {
		"body": [
			"SetBool(${1:value})$0"
		],
		"description": "Sets a ConVar's value to 1 or 0 based on the input boolean. This can only be ran on ConVars created from within Lua.",
		"prefix": "SetBool"
	},
	"ConVar:SetFloat": {
		"body": [
			"SetFloat(${1:value})$0"
		],
		"description": "Sets a ConVar's value to the input number.\nThis can only be ran on ConVars created from within Lua.",
		"prefix": "SetFloat"
	},
	"ConVar:SetInt": {
		"body": [
			"SetInt(${1:value})$0"
		],
		"description": "Sets a ConVar's value to the input number after converting it to an integer.\n\nThis can only be ran on ConVars created from within Lua.",
		"prefix": "SetInt"
	},
	"ConVar:SetString": {
		"body": [
			"SetString(${1:value})$0"
		],
		"description": "Sets a ConVar's value to the input string. This can only be ran on ConVars created from within Lua.",
		"prefix": "SetString"
	},
	"Entity:Activate": {
		"body": [
			"Activate()$0"
		],
		"description": "Activates the entity. This needs to be used on some entities (like constraints) after being spawned.\n\nFor some entity types when this function is used after Entity:SetModelScale, the physics object will be recreated with the new scale. [Source-sdk-2013](https://github.com/ValveSoftware/source-sdk-2013/blob/55ed12f8d1eb6887d348be03aee5573d44177ffb/mp/src/game/server/baseanimating.cpp#L321-L327).\n\nCalling this method after Entity:SetModelScale will recreate a new scaled `SOLID_VPHYSICS` PhysObj on scripted entities. This can be a problem if you made a properly scaled PhysObj of another kind (using Entity:PhysicsInitSphere for instance) or if you edited the PhysObj's properties. This is especially the behavior of the Sandbox spawn menu.\nThis crashes the game with scaled vehicles.",
		"prefix": "Activate"
	},
	"Entity:AddCallback": {
		"body": [
			"AddCallback(${1:hook}, ${2:func})$0"
		],
		"description": "Add a callback function to a specific event. This is used instead of hooks to avoid calling empty functions unnecessarily.\n\nThis also allows you to use certain hooks in engine entities (non-scripted entities).\n\nThis method does not check if the function has already been added to this object before, so if you add the same callback twice, it will be run twice! Make sure to add your callback only once.",
		"prefix": "AddCallback"
	},
	"Entity:AddEFlags": {
		"body": [
			"AddEFlags(${1:flag})$0"
		],
		"description": "Adds engine flags.",
		"prefix": "AddEFlags"
	},
	"Entity:AddEffects": {
		"body": [
			"AddEffects(${1:effect})$0"
		],
		"description": "Applies an engine effect to an entity.\n\nSee also Entity:IsEffectActive and  Entity:RemoveEffects.",
		"prefix": "AddEffects"
	},
	"Entity:AddFlags": {
		"body": [
			"AddFlags(${1:flag})$0"
		],
		"description": "Adds flags to the entity.",
		"prefix": "AddFlags"
	},
	"Entity:AddGesture": {
		"body": [
			"AddGesture(${1:activity}, ${2:autokill=true})$0"
		],
		"description": "Adds a gesture animation to the entity and plays it.\n\n\nSee Entity:AddGestureSequence and Entity:AddLayeredSequence for functions that takes sequences instead of Enums/ACT.\n\nThis function only works on BaseAnimatingOverlay entites!",
		"prefix": "AddGesture"
	},
	"Entity:AddGestureSequence": {
		"body": [
			"AddGestureSequence(${1:sequence}, ${2:autokill=true})$0"
		],
		"description": "Adds a gesture animation to the entity and plays it.\n\n\nSee Entity:AddGesture for a function that takes Enums/ACT.\n\n\nSee also Entity:AddLayeredSequence.\n\nThis function only works on BaseAnimatingOverlay entites!",
		"prefix": "AddGestureSequence"
	},
	"Entity:AddLayeredSequence": {
		"body": [
			"AddLayeredSequence(${1:sequence}, ${2:priority})$0"
		],
		"description": "Adds a gesture animation to the entity and plays it.\n\n\nSee Entity:AddGestureSequence for a function that doesn't take priority.\n\n\nSee Entity:AddGesture for a function that takes Enums/ACT.\n\nThis function only works on BaseAnimatingOverlay entites!",
		"prefix": "AddLayeredSequence"
	},
	"Entity:AddSolidFlags": {
		"body": [
			"AddSolidFlags(${1:flags})$0"
		],
		"description": "Adds solid flag(s) to the entity.",
		"prefix": "AddSolidFlags"
	},
	"Entity:AddToMotionController": {
		"body": [
			"AddToMotionController(${1:physObj})$0"
		],
		"description": "Adds a PhysObject to the entity's motion controller so that ENTITY:PhysicsSimulate will be called for given PhysObject as well.\n\nYou must first create a motion controller with Entity:StartMotionController.\n\nYou can remove added PhysObjects by using Entity:RemoveFromMotionController.\n\nOnly works on a scripted Entity of anim type",
		"prefix": "AddToMotionController"
	},
	"Entity:AlignAngles": {
		"body": [
			"AlignAngles(${1:from}, ${2:to})$0"
		],
		"description": "Returns an angle based on the ones inputted that you can use to align an object.\n\nThis function doesn't change the angle of the entity on its own (see example).",
		"prefix": "AlignAngles"
	},
	"Entity:BecomeRagdollOnClient": {
		"body": [
			"BecomeRagdollOnClient()$0"
		],
		"description": "Spawns a clientside ragdoll for the entity, positioning it in place of the original entity, and makes the entity invisible. It doesn't preserve flex values (face posing) as CSRagdolls don't support flex.\n\nIt does not work on players. Use Player:CreateRagdoll instead.\n\nThe original entity is not removed, and neither are any ragdolls previously generated with this function.\n\nTo make the entity re-appear, run Entity:SetNoDraw( false )",
		"prefix": "BecomeRagdollOnClient"
	},
	"Entity:BeingLookedAtByLocalPlayer": {
		"body": [
			"BeingLookedAtByLocalPlayer()$0"
		],
		"description": "Returns true if the entity is being looked at by the local player and is within 256 units of distance.\n\nThis function is only available in entities that are based off of sandbox's base_gmodentity.",
		"prefix": "BeingLookedAtByLocalPlayer"
	},
	"Entity:Blocked": {
		"body": [
			"Blocked(${1:entity})$0"
		],
		"description": " Dispatches blocked events to this entity's blocked handler. This function is only useful when interacting with entities like func_movelinear.",
		"prefix": "Blocked"
	},
	"Entity:BodyTarget": {
		"body": [
			"BodyTarget(${1:origin}, ${2:noisy=false})$0"
		],
		"description": "Returns a centered vector of this entity, NPCs use this internally to aim at their targets.\n\nThis only works on players and NPCs.",
		"prefix": "BodyTarget"
	},
	"Entity:BoneHasFlag": {
		"body": [
			"BoneHasFlag(${1:boneID}, ${2:flag})$0"
		],
		"description": "Returns whether the entity's bone has the flag or not.",
		"prefix": "BoneHasFlag"
	},
	"Entity:BoneLength": {
		"body": [
			"BoneLength(${1:boneID})$0"
		],
		"description": "Returns the length between given bone's position and the position of given bone's parent.",
		"prefix": "BoneLength"
	},
	"Entity:BoundingRadius": {
		"body": [
			"BoundingRadius()$0"
		],
		"description": "Returns the distance between the center of the bounding box and the furthest bounding box corner.",
		"prefix": "BoundingRadius"
	},
	"Entity:CallOnRemove": {
		"body": [
			"CallOnRemove(${1:identifier}, ${2:removeFunc}, ${3:argn...})$0"
		],
		"description": "Causes a specified function to be run if the entity is removed by any means. This can later be undone by Entity:RemoveCallOnRemove if you need it to not run.\n\nThis hook is called during clientside full updates. See ENTITY:OnRemove#clientsidebehaviourremarks for more information.\nUsing players with this function will provide a gimped entity to the callback.",
		"prefix": "CallOnRemove"
	},
	"Entity:ClearPoseParameters": {
		"body": [
			"ClearPoseParameters()$0"
		],
		"description": "Resets all pose parameters such as aim_yaw, aim_pitch and rotation.",
		"prefix": "ClearPoseParameters"
	},
	"Entity:CollisionRulesChanged": {
		"body": [
			"CollisionRulesChanged()$0"
		],
		"description": "Declares that the collision rules of the entity have changed, and subsequent calls for GM:ShouldCollide with this entity may return a different value than they did previously.\n\nThis function must **not** be called inside of GM:ShouldCollide. Instead, it must be called in advance when the condition is known to change.\n\nFailure to use this function correctly will result in a crash of the physics engine.",
		"prefix": "CollisionRulesChanged"
	},
	"Entity:CreateParticleEffect": {
		"body": [
			"CreateParticleEffect(${1:particle}, ${2:attachment}, ${3:options=nil})$0"
		],
		"description": "Creates a clientside particle system attached to the entity. See also Global.CreateParticleSystem\n\nThe particle effect must be precached with Global.PrecacheParticleSystem and the file its from must be added via game.AddParticles before it can be used!",
		"prefix": "CreateParticleEffect"
	},
	"Entity:CreateShadow": {
		"body": [
			"CreateShadow()$0"
		],
		"description": "Draws the shadow of an entity.",
		"prefix": "CreateShadow"
	},
	"Entity:CreatedByMap": {
		"body": [
			"CreatedByMap()$0"
		],
		"description": "Returns whether the entity was created by map or not.",
		"prefix": "CreatedByMap"
	},
	"Entity:DTVar": {
		"body": [
			"DTVar(${1:Type}, ${2:ID}, ${3:Name})$0"
		],
		"description": "You should use Entity:NetworkVar instead\n\nSets up a self.dt.NAME alias for a Data Table variable.",
		"prefix": "DTVar"
	},
	"Entity:DeleteOnRemove": {
		"body": [
			"DeleteOnRemove(${1:entityToRemove})$0"
		],
		"description": "Whenever the entity is removed, entityToRemove will be removed also.",
		"prefix": "DeleteOnRemove"
	},
	"Entity:DestroyShadow": {
		"body": [
			"DestroyShadow()$0"
		],
		"description": "Removes the shadow for the entity.\n\nThe shadow will be recreated as soon as the entity wakes.\n\nDoesn't affect shadows from flashlight/lamps/env_projectedtexture.",
		"prefix": "DestroyShadow"
	},
	"Entity:DisableMatrix": {
		"body": [
			"DisableMatrix(${1:matrixType})$0"
		],
		"description": "Disables an active matrix.",
		"prefix": "DisableMatrix"
	},
	"Entity:DispatchTraceAttack": {
		"body": [
			"DispatchTraceAttack(${1:damageInfo}, ${2:traceRes}, ${3:dir=traceRes.HitNormal})$0"
		],
		"description": "Performs a trace attack.\n\nCalling this function on the victim entity in ENTITY:OnTakeDamage can cause infinite loops.",
		"prefix": "DispatchTraceAttack"
	},
	"Entity:DontDeleteOnRemove": {
		"body": [
			"DontDeleteOnRemove(${1:entityToUnremove})$0"
		],
		"description": "This removes the argument entity from an ent's list of entities to 'delete on remove'",
		"prefix": "DontDeleteOnRemove"
	},
	"Entity:DrawModel": {
		"body": [
			"DrawModel(${1:flags=STUDIO_RENDER})$0"
		],
		"description": "Draws the entity or model.\n\nIf called inside ENTITY:Draw or ENTITY:DrawTranslucent, it only draws the entity's model itself.\n\nIf called outside of those hooks, it will call both of said hooks depending on Entity:GetRenderGroup, drawing the entire entity again.\n\nWhen drawing an entity more than once per frame in different positions, you should call Entity:SetupBones before each draw; Otherwise, the entity will retain its first drawn position.\n\n\n\nCalling this on entities with Enums/EF and Enums/EF applied causes a crash.\n\nUsing this with a map model (game.GetWorld():Entity:GetModel()) crashes the game.",
		"prefix": "DrawModel"
	},
	"Entity:DrawShadow": {
		"body": [
			"DrawShadow(${1:shouldDraw})$0"
		],
		"description": "Sets whether an entity's shadow should be drawn.",
		"prefix": "DrawShadow"
	},
	"Entity:DropToFloor": {
		"body": [
			"DropToFloor()$0"
		],
		"description": "Move an entity down until it collides with something.\nThe entity needs to already have something below it within 256 units.",
		"prefix": "DropToFloor"
	},
	"Entity:EmitSound": {
		"body": [
			"EmitSound(${1:soundName}, ${2:soundLevel=75}, ${3:pitchPercent=100}, ${4:volume=1}, ${5:channel=CHAN_AUTO, CHAN_WEAPON for weapons}, ${6:soundFlags=0}, ${7:dsp=0})$0"
		],
		"description": "Plays a sound on an entity. If run clientside, the sound will only be heard locally.\n\nIf used on a player or NPC character with the mouth rigged, the character will \"lip-sync\". This does not work with all sound files.\n\nWhen using this function with weapons, use the Weapon itself as the entity, not its owner!\n\nThis does not respond to Global.SuppressHostEvents.",
		"prefix": "EmitSound"
	},
	"Entity:EnableConstraints": {
		"body": [
			"EnableConstraints(${1:toggleConstraints})$0"
		],
		"description": "Toggles the constraints of this ragdoll entity on and off.",
		"prefix": "EnableConstraints"
	},
	"Entity:EnableCustomCollisions": {
		"body": [
			"EnableCustomCollisions(${1:useCustom})$0"
		],
		"description": "Flags an entity as using custom lua defined collisions. Fixes entities having spongy player collisions or not hitting traces, such as after Entity:PhysicsFromMesh\n\nInternally identical to `Entity:AddSolidFlags( bit.bor( FSOLID_CUSTOMRAYTEST, FSOLID_CUSTOMBOXTEST ) )`\n\nDo not confuse this function with Entity:SetCustomCollisionCheck, they are not the same.",
		"prefix": "EnableCustomCollisions"
	},
	"Entity:EnableMatrix": {
		"body": [
			"EnableMatrix(${1:matrixType}, ${2:matrix})$0"
		],
		"description": "Can be used to apply a custom VMatrix to the entity, mostly used for scaling the model by a Vector.\n\nTo disable it, use Entity:DisableMatrix.\n\nIf your old scales are wrong due to a recent update, use Entity:SetLegacyTransform as a quick fix.\n\nThe matrix can also be modified to apply a custom rotation and offset via the VMatrix:SetAngles and VMatrix:SetTranslation functions.\nThis does not scale procedural bones.\nThis disables inverse kinematics of an entity.",
		"prefix": "EnableMatrix"
	},
	"Entity:EntIndex": {
		"body": [
			"EntIndex()$0"
		],
		"description": "Gets the unique entity index of an entity.\n\nEntity indices are marked as unused after deletion, and can be reused by newly-created entities",
		"prefix": "EntIndex"
	},
	"Entity:Extinguish": {
		"body": [
			"Extinguish()$0"
		],
		"description": "Extinguishes the entity if it is on fire.\n\nHas no effect if called inside GM:EntityTakeDamage (and the attacker is the flame that's hurting the entity)\n\nSee also Entity:Ignite.",
		"prefix": "Extinguish"
	},
	"Entity:EyeAngles": {
		"body": [
			"EyeAngles()$0"
		],
		"description": "Returns the direction a player/npc/ragdoll is looking as a world-oriented angle.\n\nThis can return an incorrect value in pods.\n\nThis can return an incorrect value in jeeps when used with Player:EnterVehicle.",
		"prefix": "EyeAngles"
	},
	"Entity:EyePos": {
		"body": [
			"EyePos()$0"
		],
		"description": "Returns the position of an Player/NPC's view.",
		"prefix": "EyePos"
	},
	"Entity:FindBodygroupByName": {
		"body": [
			"FindBodygroupByName(${1:name})$0"
		],
		"description": "Searches for bodygroup with given name.",
		"prefix": "FindBodygroupByName"
	},
	"Entity:FindTransitionSequence": {
		"body": [
			"FindTransitionSequence(${1:currentSequence}, ${2:goalSequence})$0"
		],
		"description": "Returns a transition from the given start and end sequence.\n\nThis function was only used by HL1 entities and NPCs, before the advent of sequence blending and gestures.",
		"prefix": "FindTransitionSequence"
	},
	"Entity:Fire": {
		"body": [
			"Fire(${1:input}, ${2:param}, ${3:delay=0})$0"
		],
		"description": "Fires an entity's input, conforming to the map IO event queue system. You can find inputs for most entities on the [Valve Developer Wiki](https://developer.valvesoftware.com/wiki/Output)\n\nSee also Entity:Input for a function that bypasses the event queue and GM:AcceptInput.",
		"prefix": "Fire"
	},
	"Entity:FireBullets": {
		"body": [
			"FireBullets(${1:bulletInfo}, ${2:suppressHostEvents=false})$0"
		],
		"description": "Fires a bullet.\n\nWhen used in a  hook such as WEAPON:Think or WEAPON:PrimaryAttack, it will use Player:LagCompensation internally.\n\nLag compensation will not work if this function is called in a timer, regardless if the timer was made in a  hook.",
		"prefix": "FireBullets"
	},
	"Entity:FollowBone": {
		"body": [
			"FollowBone(${1:parent=NULL}, ${2:boneid})$0"
		],
		"description": "Makes an entity follow another entity's bone.\n\nInternally this function calls Entity:SetParent( parent, boneid ), Entity:AddEffects( EF_FOLLOWBONE\n) and sets an internal flag to always rebuild all bones.\nIf the entity vibrates or stops following the parent, you probably need to run Entity:SetPredictable( true ) clientside.\nThis function will not work if the target bone's parent bone is invalid or if the bone is not used by VERTEX LOD0",
		"prefix": "FollowBone"
	},
	"Entity:ForcePlayerDrop": {
		"body": [
			"ForcePlayerDrop()$0"
		],
		"description": "Forces the Entity to be dropped, when it is being held by a player's gravitygun or physgun.",
		"prefix": "ForcePlayerDrop"
	},
	"Entity:FrameAdvance": {
		"body": [
			"FrameAdvance()$0"
		],
		"description": "Advances the cycle of an animated entity.\n\nAnimations that loop will automatically reset the cycle so you don't have to - ones that do not will stop animating once you reach the end of their sequence.\n\nDo not call this function multiple times a frame, as it can cause unexpected results, such as animations playing at increased rate, etc.\n\nNextBot:BodyMoveXY calls this internally, so do not call this function before or after NextBot:BodyMoveXY.",
		"prefix": "FrameAdvance"
	},
	"Entity:GetAbsVelocity": {
		"body": [
			"GetAbsVelocity()$0"
		],
		"description": "Returns the entity's velocity.\n\nActually binds to CBaseEntity::GetLocalVelocity() which retrieves the velocity of the entity due to its movement in the world from forces such as gravity. Does not include velocity from entity-on-entity collision.",
		"prefix": "GetAbsVelocity"
	},
	"Entity:GetAngles": {
		"body": [
			"GetAngles()$0"
		],
		"description": "Gets the angles of given entity.\n\nThis returns incorrect results for the local player clientside.\n\nThis will return the local player's Global.EyeAngles in Category:3D_Rendering_Hooks.\n\nThis will return Global.Angle(0,0,0) in Category:3D_Rendering_Hooks while paused in single-player.",
		"prefix": "GetAngles"
	},
	"Entity:GetAnimInfo": {
		"body": [
			"GetAnimInfo(${1:animIndex})$0"
		],
		"description": "Returns a table containing the number of frames, flags, name, and FPS of an entity's animation ID.\n\nAnimation ID is not the same as sequence ID.",
		"prefix": "GetAnimInfo"
	},
	"Entity:GetAnimTime": {
		"body": [
			"GetAnimTime()$0"
		],
		"description": "Returns the last time the entity had an animation update. Returns 0 if the entity doesn't animate.",
		"prefix": "GetAnimTime"
	},
	"Entity:GetAttachment": {
		"body": [
			"GetAttachment(${1:attachmentId})$0"
		],
		"description": "Gets the orientation and position of the attachment by its ID, returns nothing if the attachment does not exist.\n\nThe update rate of this function is limited by the setting of ENT.AutomaticFrameAdvance for Scripted Entities!\n\nThis will return improper values for viewmodels if used in GM:CalcView.",
		"prefix": "GetAttachment"
	},
	"Entity:GetAttachments": {
		"body": [
			"GetAttachments()$0"
		],
		"description": "Returns a table containing all attachments of the given entitys model.\n\nReturns an empty table or **nil** in case it's model has no attachments.\n\nThis can have inconsistent results in single-player.",
		"prefix": "GetAttachments"
	},
	"Entity:GetBaseVelocity": {
		"body": [
			"GetBaseVelocity()$0"
		],
		"description": "Returns the entity's base velocity which is their velocity due to forces applied by other entities. This includes entity-on-entity collision or riding a treadmill.",
		"prefix": "GetBaseVelocity"
	},
	"Entity:GetBloodColor": {
		"body": [
			"GetBloodColor()$0"
		],
		"description": "Returns the blood color of this entity. This can be set with Entity:SetBloodColor.",
		"prefix": "GetBloodColor"
	},
	"Entity:GetBodyGroups": {
		"body": [
			"GetBodyGroups()$0"
		],
		"description": "Returns a list of all bodygroups of the entity.",
		"prefix": "GetBodyGroups"
	},
	"Entity:GetBodygroup": {
		"body": [
			"GetBodygroup(${1:id})$0"
		],
		"description": "Gets the exact value for specific bodygroup of given entity.",
		"prefix": "GetBodygroup"
	},
	"Entity:GetBodygroupCount": {
		"body": [
			"GetBodygroupCount(${1:bodygroup})$0"
		],
		"description": "Returns the count of possible values for this bodygroup.\n\nThis is **not** the maximum value, since the bodygroups start with 0, not 1.",
		"prefix": "GetBodygroupCount"
	},
	"Entity:GetBodygroupName": {
		"body": [
			"GetBodygroupName(${1:id})$0"
		],
		"description": "Gets the name of specific bodygroup for given entity.",
		"prefix": "GetBodygroupName"
	},
	"Entity:GetBoneContents": {
		"body": [
			"GetBoneContents(${1:bone})$0"
		],
		"description": "Returns the contents of the specified bone.",
		"prefix": "GetBoneContents"
	},
	"Entity:GetBoneController": {
		"body": [
			"GetBoneController(${1:boneID})$0"
		],
		"description": "Returns the value of the bone controller with the specified ID.\n\nThis is the precursor of pose parameters, and only works for Half Life 1: Source models supporting it.",
		"prefix": "GetBoneController"
	},
	"Entity:GetBoneCount": {
		"body": [
			"GetBoneCount()$0"
		],
		"description": "Returns the amount of bones in the entity.\n\nWill return -1 for Global.ClientsideModel or undrawn entities until Entity:SetupBones is called on the entity.",
		"prefix": "GetBoneCount"
	},
	"Entity:GetBoneMatrix": {
		"body": [
			"GetBoneMatrix(${1:boneID})$0"
		],
		"description": "Returns the transformation matrix of a given bone on the entity's model. The matrix contains the transformation used to position the bone in the world. It is not relative to the parent bone.\n\nThis is equivalent to constructing a VMatrix using Entity:GetBonePosition.\n\nThis can return the server's matrix during server lag.\n\nThis can return garbage serverside or a 0,0,0 fourth column (represents position) for v49 models.",
		"prefix": "GetBoneMatrix"
	},
	"Entity:GetBoneName": {
		"body": [
			"GetBoneName(${1:index})$0"
		],
		"description": "Returns name of given bone id.",
		"prefix": "GetBoneName"
	},
	"Entity:GetBoneParent": {
		"body": [
			"GetBoneParent(${1:bone})$0"
		],
		"description": "Returns parent bone of given bone.\n\nWill return -1 for Global.ClientsideModel until Entity:SetupBones is called on the entity.",
		"prefix": "GetBoneParent"
	},
	"Entity:GetBonePosition": {
		"body": [
			"GetBonePosition(${1:boneIndex})$0"
		],
		"description": "Returns the position and angle of the given attachment, relative to the world.\n\nThis function can return entity's `GetPos()` instead if the entity doesn't have it's bone cache set up.\n\nTo ensure the bone position is correct use this:\n```lua\nlocal pos = ent:GetBonePosition(0)\nif pos == ent:GetPos() then\npos = ent:GetBoneMatrix(0):GetTranslation()\nend\n```\n\nThis can return the server's position during server lag.\n\nThis can return garbage serverside or Global.Vector(0,0,0) for v49 models.\n\nThis can return garbage if a trace passed through the target bone during bone matrix access.",
		"prefix": "GetBonePosition"
	},
	"Entity:GetBoneSurfaceProp": {
		"body": [
			"GetBoneSurfaceProp(${1:bone})$0"
		],
		"description": "Returns the surface property of the specified bone.",
		"prefix": "GetBoneSurfaceProp"
	},
	"Entity:GetBrushPlane": {
		"body": [
			"GetBrushPlane(${1:id})$0"
		],
		"description": "Returns info about given plane of non-nodraw brush model surfaces of the entity's model. Works on worldspawn as well.\n\nThis only works on entities with brush models.",
		"prefix": "GetBrushPlane"
	},
	"Entity:GetBrushPlaneCount": {
		"body": [
			"GetBrushPlaneCount()$0"
		],
		"description": "Returns the amount of planes of non-nodraw brush model surfaces of the entity's model.",
		"prefix": "GetBrushPlaneCount"
	},
	"Entity:GetBrushSurfaces": {
		"body": [
			"GetBrushSurfaces()$0"
		],
		"description": "Returns a table of brushes surfaces for brush model entities.",
		"prefix": "GetBrushSurfaces"
	},
	"Entity:GetCallbacks": {
		"body": [
			"GetCallbacks(${1:hook})$0"
		],
		"description": "Returns the specified hook callbacks for this entity added with Entity:AddCallback\n\nThe callbacks can then be removed with Entity:RemoveCallback.",
		"prefix": "GetCallbacks"
	},
	"Entity:GetChildBones": {
		"body": [
			"GetChildBones(${1:boneid})$0"
		],
		"description": "Returns ids of child bones of given bone.",
		"prefix": "GetChildBones"
	},
	"Entity:GetChildren": {
		"body": [
			"GetChildren()$0"
		],
		"description": "Gets the children of the entity - that is, every entity whose move parent is this entity.\n\nThis function returns Entity:SetMoveParent children, **NOT** Entity:SetParent!\n\nEntity:SetParent however also calls Entity:SetMoveParent.\n\n\n\nThis means that some entities in the returned list might have a NULL Entity:GetParent.\n\nThis also means that using this function on players will return their weapons on the client but not the server.",
		"prefix": "GetChildren"
	},
	"Entity:GetClass": {
		"body": [
			"GetClass()$0"
		],
		"description": "Returns the classname of a entity. This is often the name of the Lua file or folder containing the files for the entity",
		"prefix": "GetClass"
	},
	"Entity:GetCollisionBounds": {
		"body": [
			"GetCollisionBounds()$0"
		],
		"description": "Returns an entity's collision bounding box. In most cases, this will return the same bounding box as Entity:GetModelBounds unless the entity does not have a physics mesh or it has a PhysObj different from the default.\n\nThis can be out-of-sync between the client and server for weapons.",
		"prefix": "GetCollisionBounds"
	},
	"Entity:GetCollisionGroup": {
		"body": [
			"GetCollisionGroup()$0"
		],
		"description": "Returns the entity's collision group",
		"prefix": "GetCollisionGroup"
	},
	"Entity:GetColor": {
		"body": [
			"GetColor()$0"
		],
		"description": "Returns the color the entity is set to.\n\nThe returned color will not have the color metatable.",
		"prefix": "GetColor"
	},
	"Entity:GetConstrainedEntities": {
		"body": [
			"GetConstrainedEntities()$0"
		],
		"description": "Returns the two entities involved in a constraint ent, or nil if the entity is not a constraint.",
		"prefix": "GetConstrainedEntities"
	},
	"Entity:GetConstrainedPhysObjects": {
		"body": [
			"GetConstrainedPhysObjects()$0"
		],
		"description": "Returns the two entities physobjects involved in a constraint ent, or no value if the entity is not a constraint.",
		"prefix": "GetConstrainedPhysObjects"
	},
	"Entity:GetCreationID": {
		"body": [
			"GetCreationID()$0"
		],
		"description": "Returns entity's creation ID. Unlike Entity:EntIndex or  Entity:MapCreationID, it will always increase and old values won't be reused.",
		"prefix": "GetCreationID"
	},
	"Entity:GetCreationTime": {
		"body": [
			"GetCreationTime()$0"
		],
		"description": "Returns the time the entity was created on, relative to Global.CurTime.",
		"prefix": "GetCreationTime"
	},
	"Entity:GetCreator": {
		"body": [
			"GetCreator()$0"
		],
		"description": "Gets the creator of the SENT.",
		"prefix": "GetCreator"
	},
	"Entity:GetCustomCollisionCheck": {
		"body": [
			"GetCustomCollisionCheck()$0"
		],
		"description": "Returns whether this entity uses custom collision check set by Entity:SetCustomCollisionCheck.",
		"prefix": "GetCustomCollisionCheck"
	},
	"Entity:GetCycle": {
		"body": [
			"GetCycle()$0"
		],
		"description": "Returns the frame of the currently played sequence. This will be a number between 0 and 1 as a representation of sequence progress.",
		"prefix": "GetCycle"
	},
	"Entity:GetDTAngle": {
		"body": [
			"GetDTAngle(${1:key})$0"
		],
		"description": "\nThis is called internally by the Entity:NetworkVar system, you can use this in cases where using NetworkVar is not possible.\n\nGet an angle stored in the datatable of the entity.",
		"prefix": "GetDTAngle"
	},
	"Entity:GetDTBool": {
		"body": [
			"GetDTBool(${1:key})$0"
		],
		"description": "\nThis is called internally by the Entity:NetworkVar system, you can use this in cases where using NetworkVar is not possible.\n\nGet a boolean stored in the datatable of the entity.",
		"prefix": "GetDTBool"
	},
	"Entity:GetDTEntity": {
		"body": [
			"GetDTEntity(${1:key})$0"
		],
		"description": "\nThis is called internally by the Entity:NetworkVar system, you can use this in cases where using NetworkVar is not possible.\n\nReturns an entity stored in the datatable of the entity.",
		"prefix": "GetDTEntity"
	},
	"Entity:GetDTFloat": {
		"body": [
			"GetDTFloat(${1:key})$0"
		],
		"description": "\nThis is called internally by the Entity:NetworkVar system, you can use this in cases where using NetworkVar is not possible.\n\nGet a float stored in the datatable of the entity.",
		"prefix": "GetDTFloat"
	},
	"Entity:GetDTInt": {
		"body": [
			"GetDTInt(${1:key})$0"
		],
		"description": "\nThis is called internally by the Entity:NetworkVar system, you can use this in cases where using NetworkVar is not possible.\n\nGet an integer stored in the datatable of the entity.",
		"prefix": "GetDTInt"
	},
	"Entity:GetDTString": {
		"body": [
			"GetDTString(${1:key})$0"
		],
		"description": "\nThis is called internally by the Entity:NetworkVar system, you can use this in cases where using NetworkVar is not possible.\n\nGet a string stored in the datatable of the entity.",
		"prefix": "GetDTString"
	},
	"Entity:GetDTVector": {
		"body": [
			"GetDTVector(${1:key})$0"
		],
		"description": "\nThis is called internally by the Entity:NetworkVar system, you can use this in cases where using NetworkVar is not possible.\n\nGet a vector stored in the datatable of the entity.",
		"prefix": "GetDTVector"
	},
	"Entity:GetEFlags": {
		"body": [
			"GetEFlags()$0"
		],
		"description": "Returns a bit flag of all engine flags of the entity.",
		"prefix": "GetEFlags"
	},
	"Entity:GetEditingData": {
		"body": [
			"GetEditingData()$0"
		],
		"description": "Returns internal data about editable Entity:NetworkVars.\n\nThis is used internally by DEntityProperties and Editable Entities system.\n\nThis function will only work on entities which had Entity:InstallDataTable called on them, which is done automatically for players and all Scripted Entities\n",
		"prefix": "GetEditingData"
	},
	"Entity:GetEffects": {
		"body": [
			"GetEffects()$0"
		],
		"description": "Returns a bit flag of all engine effect flags of the entity.",
		"prefix": "GetEffects"
	},
	"Entity:GetElasticity": {
		"body": [
			"GetElasticity()$0"
		],
		"description": "Returns the elasticity of this entity, used by some flying entities such as the Helicopter NPC to determine how much it should bounce around when colliding.",
		"prefix": "GetElasticity"
	},
	"Entity:GetFlags": {
		"body": [
			"GetFlags()$0"
		],
		"description": "Returns all flags of given entity.",
		"prefix": "GetFlags"
	},
	"Entity:GetFlexBounds": {
		"body": [
			"GetFlexBounds(${1:flex})$0"
		],
		"description": "Returns acceptable value range for the flex.",
		"prefix": "GetFlexBounds"
	},
	"Entity:GetFlexIDByName": {
		"body": [
			"GetFlexIDByName(${1:name})$0"
		],
		"description": "Returns the ID of the flex based on given name.",
		"prefix": "GetFlexIDByName"
	},
	"Entity:GetFlexName": {
		"body": [
			"GetFlexName(${1:id})$0"
		],
		"description": "Returns flex name.",
		"prefix": "GetFlexName"
	},
	"Entity:GetFlexNum": {
		"body": [
			"GetFlexNum()$0"
		],
		"description": "Returns the number of flexes this entity has.",
		"prefix": "GetFlexNum"
	},
	"Entity:GetFlexScale": {
		"body": [
			"GetFlexScale()$0"
		],
		"description": "Returns the flex scale of the entity.",
		"prefix": "GetFlexScale"
	},
	"Entity:GetFlexWeight": {
		"body": [
			"GetFlexWeight(${1:flex})$0"
		],
		"description": "Returns current weight ( value ) of the flex.",
		"prefix": "GetFlexWeight"
	},
	"Entity:GetForward": {
		"body": [
			"GetForward()$0"
		],
		"description": "Returns the forward vector of the entity, as a normalized direction vector",
		"prefix": "GetForward"
	},
	"Entity:GetFriction": {
		"body": [
			"GetFriction()$0"
		],
		"description": "Returns how much friction an entity has. Entities default to 1 (100%) and can be higher or even negative.",
		"prefix": "GetFriction"
	},
	"Entity:GetGravity": {
		"body": [
			"GetGravity()$0"
		],
		"description": "Gets the gravity multiplier of the entity.",
		"prefix": "GetGravity"
	},
	"Entity:GetGroundEntity": {
		"body": [
			"GetGroundEntity()$0"
		],
		"description": "Returns the object the entity is standing on.",
		"prefix": "GetGroundEntity"
	},
	"Entity:GetGroundSpeedVelocity": {
		"body": [
			"GetGroundSpeedVelocity()$0"
		],
		"description": "Returns the entity's ground speed velocity, which is based on the entity's walk/run speed and/or the ground speed of their sequence ( Entity:GetSequenceGroundSpeed ). Will return an empty Vector if the entity isn't moving on the ground.",
		"prefix": "GetGroundSpeedVelocity"
	},
	"Entity:GetHitBoxBone": {
		"body": [
			"GetHitBoxBone(${1:hitbox}, ${2:hboxset})$0"
		],
		"description": "Gets the bone the hit box is attached to.",
		"prefix": "GetHitBoxBone"
	},
	"Entity:GetHitBoxBounds": {
		"body": [
			"GetHitBoxBounds(${1:hitbox}, ${2:group})$0"
		],
		"description": "Gets the bounds (min and max corners) of a hit box.",
		"prefix": "GetHitBoxBounds"
	},
	"Entity:GetHitBoxCount": {
		"body": [
			"GetHitBoxCount(${1:group})$0"
		],
		"description": "Gets how many hit boxes are in a given hit box group.",
		"prefix": "GetHitBoxCount"
	},
	"Entity:GetHitBoxGroupCount": {
		"body": [
			"GetHitBoxGroupCount()$0"
		],
		"description": "You should use Entity:GetHitboxSetCount instead.\n\nReturns the number of hit box sets that an entity has. Functionally identical to Entity:GetHitboxSetCount",
		"prefix": "GetHitBoxGroupCount"
	},
	"Entity:GetHitBoxHitGroup": {
		"body": [
			"GetHitBoxHitGroup(${1:hitbox}, ${2:hitboxset})$0"
		],
		"description": "Gets the hit group of a given hitbox in a given hitbox set.",
		"prefix": "GetHitBoxHitGroup"
	},
	"Entity:GetHitboxSet": {
		"body": [
			"GetHitboxSet()$0"
		],
		"description": "Returns entity's current hit box set",
		"prefix": "GetHitboxSet"
	},
	"Entity:GetHitboxSetCount": {
		"body": [
			"GetHitboxSetCount()$0"
		],
		"description": "Returns the amount of hitbox sets in the entity.",
		"prefix": "GetHitboxSetCount"
	},
	"Entity:GetInternalVariable": {
		"body": [
			"GetInternalVariable(${1:variableName})$0"
		],
		"description": "An interface for accessing internal key values on entities.\n\nSee Entity:GetSaveTable for a more detailed explanation. See Entity:SetSaveValue for the opposite of this function.",
		"prefix": "GetInternalVariable"
	},
	"Entity:GetKeyValues": {
		"body": [
			"GetKeyValues()$0"
		],
		"description": "Returns a table containing all key values the entity has.\n\nSingle key values can usually be retrieved with Entity:GetInternalVariable.\n\nThis only includes engine defined key values. For custom key values, use GM:EntityKeyValue or ENTITY:KeyValue to capture and store them.\n\nHere's a list of keyvalues that will not appear in this list, as they are not stored/defined as actual keyvalues internally:\n* rendercolor - Entity:GetColor (Only RGB)\n* rendercolor32 - Entity:GetColor (RGBA)\n* renderamt - Entity:GetColor (Alpha)\n* disableshadows - EF_NOSHADOW\n* mins - Entity:GetCollisionBounds\n* maxs - Entity:GetCollisionBounds\n* disablereceiveshadows - EF_NORECEIVESHADOW\n* nodamageforces - EFL_NO_DAMAGE_FORCES\n* angle - Entity:GetAngles\n* angles - Entity:GetAngles\n* origin - Entity:GetPos\n* targetname - Entity:GetName",
		"prefix": "GetKeyValues"
	},
	"Entity:GetLayerCycle": {
		"body": [
			"GetLayerCycle(${1:layerID})$0"
		],
		"description": "Returns the animation cycle/frame for given layer.\n\nThis function only works on BaseAnimatingOverlay entities.",
		"prefix": "GetLayerCycle"
	},
	"Entity:GetLayerDuration": {
		"body": [
			"GetLayerDuration(${1:layerID})$0"
		],
		"description": "Returns the duration of given layer.\n\nThis function only works on BaseAnimatingOverlay entities.",
		"prefix": "GetLayerDuration"
	},
	"Entity:GetLayerPlaybackRate": {
		"body": [
			"GetLayerPlaybackRate(${1:layerID})$0"
		],
		"description": "Returns the layer playback rate. See also Entity:GetLayerDuration.\nThis function only works on BaseAnimatingOverlay entities.",
		"prefix": "GetLayerPlaybackRate"
	},
	"Entity:GetLayerSequence": {
		"body": [
			"GetLayerSequence(${1:layerID})$0"
		],
		"description": "Returns the sequence id of given layer.\n\nThis function only works on BaseAnimatingOverlay entities.",
		"prefix": "GetLayerSequence"
	},
	"Entity:GetLayerWeight": {
		"body": [
			"GetLayerWeight(${1:layerID})$0"
		],
		"description": "Returns the current weight of the layer. See Entity:SetLayerWeight for more information.\n\nThis function only works on BaseAnimatingOverlay entities.",
		"prefix": "GetLayerWeight"
	},
	"Entity:GetLightingOriginEntity": {
		"body": [
			"GetLightingOriginEntity()$0"
		],
		"description": "Returns the entity that is being used as the light origin position for this entity.",
		"prefix": "GetLightingOriginEntity"
	},
	"Entity:GetLocalAngles": {
		"body": [
			"GetLocalAngles()$0"
		],
		"description": "Returns the rotation of the entity relative to its parent entity.",
		"prefix": "GetLocalAngles"
	},
	"Entity:GetLocalAngularVelocity": {
		"body": [
			"GetLocalAngularVelocity()$0"
		],
		"description": "Returns the non-VPhysics angular velocity of the entity relative to its parent entity.",
		"prefix": "GetLocalAngularVelocity"
	},
	"Entity:GetLocalPos": {
		"body": [
			"GetLocalPos()$0"
		],
		"description": "Returns entity's position relative to it's parent.",
		"prefix": "GetLocalPos"
	},
	"Entity:GetManipulateBoneAngles": {
		"body": [
			"GetManipulateBoneAngles(${1:boneID})$0"
		],
		"description": "Gets the entity's angle manipulation of the given bone. This is relative to the default angle, so the angle is zero when unmodified.",
		"prefix": "GetManipulateBoneAngles"
	},
	"Entity:GetManipulateBoneJiggle": {
		"body": [
			"GetManipulateBoneJiggle(${1:boneID})$0"
		],
		"description": "Returns the jiggle amount of the entity's bone.\n\nSee Entity:ManipulateBoneJiggle for more info.",
		"prefix": "GetManipulateBoneJiggle"
	},
	"Entity:GetManipulateBonePosition": {
		"body": [
			"GetManipulateBonePosition(${1:boneId})$0"
		],
		"description": "Gets the entity's position manipulation of the given bone. This is relative to the default position, so it is zero when unmodified.",
		"prefix": "GetManipulateBonePosition"
	},
	"Entity:GetManipulateBoneScale": {
		"body": [
			"GetManipulateBoneScale(${1:boneID})$0"
		],
		"description": "Gets the entity's scale manipulation of the given bone. Normal scale is Vector( 1, 1, 1 )",
		"prefix": "GetManipulateBoneScale"
	},
	"Entity:GetMaterial": {
		"body": [
			"GetMaterial()$0"
		],
		"description": "Returns the material override for this entity.\n\nReturns an empty string if no material override exists. Use Entity:GetMaterials to list it's default materials.\n\nThe server's value takes priority on the client.",
		"prefix": "GetMaterial"
	},
	"Entity:GetMaterialType": {
		"body": [
			"GetMaterialType()$0"
		],
		"description": "Returns the surface material of this entity.",
		"prefix": "GetMaterialType"
	},
	"Entity:GetMaterials": {
		"body": [
			"GetMaterials()$0"
		],
		"description": "Returns all materials of the entity's model.\n\nThis function is unaffected by Entity:SetSubMaterial as it returns the original materials.\n\nThe server's values take priority on the client.\n\nThe table returned by this function will not contain materials if they are missing from the disk/repository. This means that if you are attempting to find the ID of a material to replace with Entity:SetSubMaterial and there are missing materials on the model, all subsequent materials will be offset in the table, meaning that the ID you are trying to get will be incorrect.",
		"prefix": "GetMaterials"
	},
	"Entity:GetMaxHealth": {
		"body": [
			"GetMaxHealth()$0"
		],
		"description": "Returns the max health that the entity was given. It can be set via Entity:SetMaxHealth.",
		"prefix": "GetMaxHealth"
	},
	"Entity:GetModel": {
		"body": [
			"GetModel()$0"
		],
		"description": "Gets the model of given entity.\n\nThis does not necessarily return the model's path, as is the case for brush and virtual models. This is intentional behaviour, however, there is currently no way to retrieve the actual file path.",
		"prefix": "GetModel"
	},
	"Entity:GetModelBounds": {
		"body": [
			"GetModelBounds()$0"
		],
		"description": "Returns the entity's model bounds. This is different than the collision bounds/hull. This is not scaled with Entity:SetModelScale, and will return the model's original, unmodified mins and maxs.",
		"prefix": "GetModelBounds"
	},
	"Entity:GetModelContents": {
		"body": [
			"GetModelContents()$0"
		],
		"description": "Returns the contents of the entity's current model.",
		"prefix": "GetModelContents"
	},
	"Entity:GetModelPhysBoneCount": {
		"body": [
			"GetModelPhysBoneCount()$0"
		],
		"description": "Gets the physics bone count of the entity's model. This is only applicable to `anim` type Scripted Entities with ragdoll models.",
		"prefix": "GetModelPhysBoneCount"
	},
	"Entity:GetModelRadius": {
		"body": [
			"GetModelRadius()$0"
		],
		"description": "Gets the models radius.",
		"prefix": "GetModelRadius"
	},
	"Entity:GetModelRenderBounds": {
		"body": [
			"GetModelRenderBounds()$0"
		],
		"description": "Returns the entity's model render bounds. By default this will return the same bounds as Entity:GetModelBounds.",
		"prefix": "GetModelRenderBounds"
	},
	"Entity:GetModelScale": {
		"body": [
			"GetModelScale()$0"
		],
		"description": "Gets the selected entity's model scale.",
		"prefix": "GetModelScale"
	},
	"Entity:GetMomentaryRotButtonPos": {
		"body": [
			"GetMomentaryRotButtonPos(${1:turnAngle})$0"
		],
		"description": "Returns the amount a momentary_rot_button entity is turned based on the given angle. 0 meaning completely turned closed, 1 meaning completely turned open.\n\nThis only works on momentary_rot_button entities.",
		"prefix": "GetMomentaryRotButtonPos"
	},
	"Entity:GetMoveCollide": {
		"body": [
			"GetMoveCollide()$0"
		],
		"description": "Returns the move collide type of the entity. The move collide is the way a physics object reacts to hitting an object - will it bounce, slide?",
		"prefix": "GetMoveCollide"
	},
	"Entity:GetMoveParent": {
		"body": [
			"GetMoveParent()$0"
		],
		"description": "Returns the movement parent of this entity.\n\nSee Entity:SetMoveParent for more info.",
		"prefix": "GetMoveParent"
	},
	"Entity:GetMoveType": {
		"body": [
			"GetMoveType()$0"
		],
		"description": "Returns the entity's movetype",
		"prefix": "GetMoveType"
	},
	"Entity:GetNWAngle": {
		"body": [
			"GetNWAngle(${1:key}, ${2:fallback=Angle( 0, 0, 0 )})$0"
		],
		"description": "Retrieves a networked angle value at specified index on the entity that is set by Entity:SetNWAngle.",
		"prefix": "GetNWAngle"
	},
	"Entity:GetNWBool": {
		"body": [
			"GetNWBool(${1:key}, ${2:fallback=false})$0"
		],
		"description": "Retrieves a networked boolean value at specified index on the entity that is set by Entity:SetNWBool.",
		"prefix": "GetNWBool"
	},
	"Entity:GetNWEntity": {
		"body": [
			"GetNWEntity(${1:key}, ${2:fallback=NULL})$0"
		],
		"description": "Retrieves a networked entity value at specified index on the entity that is set by Entity:SetNWEntity.",
		"prefix": "GetNWEntity"
	},
	"Entity:GetNWFloat": {
		"body": [
			"GetNWFloat(${1:key}, ${2:fallback=0})$0"
		],
		"description": "Retrieves a networked float value at specified index on the entity that is set by Entity:SetNWFloat.",
		"prefix": "GetNWFloat"
	},
	"Entity:GetNWInt": {
		"body": [
			"GetNWInt(${1:key}, ${2:fallback=0})$0"
		],
		"description": "Retrieves a networked integer (whole number) value that was previously set by Entity:SetNWInt.\n\nThis function will not round decimal values as it actually networks a float internally.",
		"prefix": "GetNWInt"
	},
	"Entity:GetNWString": {
		"body": [
			"GetNWString(${1:key}, ${2:fallback})$0"
		],
		"description": "Retrieves a networked string value at specified index on the entity that is set by Entity:SetNWString.",
		"prefix": "GetNWString"
	},
	"Entity:GetNWVarProxy": {
		"body": [
			"GetNWVarProxy(${1:key})$0"
		],
		"description": "Returns callback function for given NWVar of this entity.",
		"prefix": "GetNWVarProxy"
	},
	"Entity:GetNWVarTable": {
		"body": [
			"GetNWVarTable()$0"
		],
		"description": "Returns all the networked variables in an entity.",
		"prefix": "GetNWVarTable"
	},
	"Entity:GetNWVector": {
		"body": [
			"GetNWVector(${1:key}, ${2:fallback=Vector( 0, 0, 0 )})$0"
		],
		"description": "Retrieves a networked vector value at specified index on the entity that is set by Entity:SetNWVector.",
		"prefix": "GetNWVector"
	},
	"Entity:GetName": {
		"body": [
			"GetName()$0"
		],
		"description": "Returns the mapping name of this entity.",
		"prefix": "GetName"
	},
	"Entity:GetNetworkAngles": {
		"body": [
			"GetNetworkAngles()$0"
		],
		"description": "Gets networked angles for entity.",
		"prefix": "GetNetworkAngles"
	},
	"Entity:GetNetworkOrigin": {
		"body": [
			"GetNetworkOrigin()$0"
		],
		"description": "Gets networked origin for entity.",
		"prefix": "GetNetworkOrigin"
	},
	"Entity:GetNetworkVars": {
		"body": [
			"GetNetworkVars()$0"
		],
		"description": "Returns all network vars created by Entity:NetworkVar and Entity:NetworkVarElement and their current values.\n\nThis is used internally by the duplicator.\n\nFor NWVars see Entity:GetNWVarTable.\n\nThis function will only work on entities which had Entity:InstallDataTable called on them, which is done automatically for players and all Scripted Entities",
		"prefix": "GetNetworkVars"
	},
	"Entity:GetNetworkedAngle": {
		"body": [
			"GetNetworkedAngle(${1:key}, ${2:fallback=Angle( 0, 0, 0 )})$0"
		],
		"description": "You should use Entity:GetNWAngle instead.\n\nRetrieves a networked angle value at specified index on the entity that is set by Entity:SetNetworkedAngle.",
		"prefix": "GetNetworkedAngle"
	},
	"Entity:GetNetworkedBool": {
		"body": [
			"GetNetworkedBool(${1:key}, ${2:fallback=false})$0"
		],
		"description": "You should use Entity:GetNWBool instead.\n\nRetrieves a networked boolean value at specified index on the entity that is set by Entity:SetNetworkedBool.",
		"prefix": "GetNetworkedBool"
	},
	"Entity:GetNetworkedEntity": {
		"body": [
			"GetNetworkedEntity(${1:key}, ${2:fallback=NULL})$0"
		],
		"description": "You should use Entity:GetNWEntity instead.\n\nRetrieves a networked float value at specified index on the entity that is set by Entity:SetNetworkedEntity.",
		"prefix": "GetNetworkedEntity"
	},
	"Entity:GetNetworkedFloat": {
		"body": [
			"GetNetworkedFloat(${1:key}, ${2:fallback=0})$0"
		],
		"description": "You should use Entity:GetNWFloat instead.\n\nRetrieves a networked float value at specified index on the entity that is set by Entity:SetNetworkedFloat.\n\nSeems to be the same as Entity:GetNetworkedInt.",
		"prefix": "GetNetworkedFloat"
	},
	"Entity:GetNetworkedInt": {
		"body": [
			"GetNetworkedInt(${1:key}, ${2:fallback=0})$0"
		],
		"description": "You should use Entity:GetNWInt instead.\n\nRetrieves a networked integer value at specified index on the entity that is set by Entity:SetNetworkedInt.",
		"prefix": "GetNetworkedInt"
	},
	"Entity:GetNetworkedString": {
		"body": [
			"GetNetworkedString(${1:key}, ${2:fallback})$0"
		],
		"description": "You should use Entity:GetNWString instead.\n\nRetrieves a networked string value at specified index on the entity that is set by Entity:SetNetworkedString.",
		"prefix": "GetNetworkedString"
	},
	"Entity:GetNetworkedVarProxy": {
		"body": [
			"GetNetworkedVarProxy(${1:name})$0"
		],
		"description": "You should be using Entity:GetNWVarProxy instead.\nReturns callback function for given NWVar of this entity.",
		"prefix": "GetNetworkedVarProxy"
	},
	"Entity:GetNetworkedVarTable": {
		"body": [
			"GetNetworkedVarTable()$0"
		],
		"description": "You should be using Entity:GetNWVarTable instead.\n\nReturns all the networked variables in an entity.",
		"prefix": "GetNetworkedVarTable"
	},
	"Entity:GetNetworkedVector": {
		"body": [
			"GetNetworkedVector(${1:key}, ${2:fallback=Vector( 0, 0, 0 )})$0"
		],
		"description": "You should use Entity:GetNWVector instead.\n\nRetrieves a networked vector value at specified index on the entity that is set by Entity:SetNetworkedVector.",
		"prefix": "GetNetworkedVector"
	},
	"Entity:GetNoDraw": {
		"body": [
			"GetNoDraw()$0"
		],
		"description": "Returns if the entity's rendering and transmitting has been disabled.\n\nThis is equivalent to calling Entity:IsEffectActive( EF_NODRAW )",
		"prefix": "GetNoDraw"
	},
	"Entity:GetNumBodyGroups": {
		"body": [
			"GetNumBodyGroups()$0"
		],
		"description": "Returns the body group count of the entity.",
		"prefix": "GetNumBodyGroups"
	},
	"Entity:GetNumPoseParameters": {
		"body": [
			"GetNumPoseParameters()$0"
		],
		"description": "Returns the number of pose parameters this entity has.",
		"prefix": "GetNumPoseParameters"
	},
	"Entity:GetOwner": {
		"body": [
			"GetOwner()$0"
		],
		"description": "Returns the owner entity of this entity. See Entity:SetOwner for more info.",
		"prefix": "GetOwner"
	},
	"Entity:GetParent": {
		"body": [
			"GetParent()$0"
		],
		"description": "Returns the parent entity of this entity.",
		"prefix": "GetParent"
	},
	"Entity:GetParentAttachment": {
		"body": [
			"GetParentAttachment()$0"
		],
		"description": "Returns the attachment index of the entity's parent. Returns 0 if the entity is not parented to a specific attachment or if it isn't parented at all.\n\nThis is set by second argument of Entity:SetParent or the **SetParentAttachment** input.",
		"prefix": "GetParentAttachment"
	},
	"Entity:GetParentPhysNum": {
		"body": [
			"GetParentPhysNum()$0"
		],
		"description": "If the entity is parented to an entity that has a model with multiple physics objects (like a ragdoll), this is used to retrieve what physics object number the entity is parented to on it's parent.",
		"prefix": "GetParentPhysNum"
	},
	"Entity:GetParentWorldTransformMatrix": {
		"body": [
			"GetParentWorldTransformMatrix()$0"
		],
		"description": "Returns the position and angle of the entity's move parent as a 3x4 matrix (VMatrix is 4x4 so the fourth row goes unused). The first three columns store the angle as a [rotation matrix](https://en.wikipedia.org/wiki/Rotation_matrix), and the fourth column stores the position vector.",
		"prefix": "GetParentWorldTransformMatrix"
	},
	"Entity:GetPersistent": {
		"body": [
			"GetPersistent()$0"
		],
		"description": "Returns whether the entity is persistent or not.\n\nSee Entity:SetPersistent for more information on persistence.",
		"prefix": "GetPersistent"
	},
	"Entity:GetPhysicsAttacker": {
		"body": [
			"GetPhysicsAttacker(${1:timeLimit})$0"
		],
		"description": "Returns player who is claiming kills of physics damage the entity deals.",
		"prefix": "GetPhysicsAttacker"
	},
	"Entity:GetPhysicsObject": {
		"body": [
			"GetPhysicsObject()$0"
		],
		"description": "Returns the entity's physics object, if the entity has physics.\n\nEntities don't have clientside physics objects by default, so this will return [NULL PHYSOBJ] on the client in most cases.",
		"prefix": "GetPhysicsObject"
	},
	"Entity:GetPhysicsObjectCount": {
		"body": [
			"GetPhysicsObjectCount()$0"
		],
		"description": "Returns the number of physics objects an entity has (usually 1 for non-ragdolls)",
		"prefix": "GetPhysicsObjectCount"
	},
	"Entity:GetPhysicsObjectNum": {
		"body": [
			"GetPhysicsObjectNum(${1:physNum})$0"
		],
		"description": "Returns a specific physics object from an entity with multiple PhysObjects (like ragdolls)\n\nSee also Entity:TranslateBoneToPhysBone.",
		"prefix": "GetPhysicsObjectNum"
	},
	"Entity:GetPlaybackRate": {
		"body": [
			"GetPlaybackRate()$0"
		],
		"description": "Returns the playback rate of the main sequence on this entity, with 1.0 being the default speed.",
		"prefix": "GetPlaybackRate"
	},
	"Entity:GetPos": {
		"body": [
			"GetPos()$0"
		],
		"description": "Gets the position of entity in world.",
		"prefix": "GetPos"
	},
	"Entity:GetPoseParameter": {
		"body": [
			"GetPoseParameter(${1:name})$0"
		],
		"description": "Returns the pose parameter value",
		"prefix": "GetPoseParameter"
	},
	"Entity:GetPoseParameterName": {
		"body": [
			"GetPoseParameterName(${1:id})$0"
		],
		"description": "Returns name of given pose parameter",
		"prefix": "GetPoseParameterName"
	},
	"Entity:GetPoseParameterRange": {
		"body": [
			"GetPoseParameterRange(${1:id})$0"
		],
		"description": "Returns pose parameter range",
		"prefix": "GetPoseParameterRange"
	},
	"Entity:GetPredictable": {
		"body": [
			"GetPredictable()$0"
		],
		"description": "Returns whether this entity is predictable or not.\n\nSee Entity:SetPredictable for more information",
		"prefix": "GetPredictable"
	},
	"Entity:GetRagdollOwner": {
		"body": [
			"GetRagdollOwner()$0"
		],
		"description": "Returns the entity which the ragdoll came from. The opposite of Player:GetRagdollEntity.",
		"prefix": "GetRagdollOwner"
	},
	"Entity:GetRenderAngles": {
		"body": [
			"GetRenderAngles()$0"
		],
		"description": "Returns the entity's render angles, set by Entity:SetRenderAngles in a drawing hook.",
		"prefix": "GetRenderAngles"
	},
	"Entity:GetRenderBounds": {
		"body": [
			"GetRenderBounds()$0"
		],
		"description": "Returns render bounds of the entity. Can be overridden by Entity:SetRenderBounds.\n\nIf the render bounds are not inside players view, the entity will not be drawn!",
		"prefix": "GetRenderBounds"
	},
	"Entity:GetRenderFX": {
		"body": [
			"GetRenderFX()$0"
		],
		"description": "Returns current render FX of the entity.",
		"prefix": "GetRenderFX"
	},
	"Entity:GetRenderGroup": {
		"body": [
			"GetRenderGroup()$0"
		],
		"description": "Returns the render group of the entity.",
		"prefix": "GetRenderGroup"
	},
	"Entity:GetRenderMode": {
		"body": [
			"GetRenderMode()$0"
		],
		"description": "Returns the render mode of the entity.",
		"prefix": "GetRenderMode"
	},
	"Entity:GetRenderOrigin": {
		"body": [
			"GetRenderOrigin()$0"
		],
		"description": "Returns the entity's render origin, set by Entity:SetRenderOrigin in a drawing hook.",
		"prefix": "GetRenderOrigin"
	},
	"Entity:GetRight": {
		"body": [
			"GetRight()$0"
		],
		"description": "Returns the rightward vector of the entity, as a normalized direction vector",
		"prefix": "GetRight"
	},
	"Entity:GetRotatedAABB": {
		"body": [
			"GetRotatedAABB(${1:min}, ${2:max})$0"
		],
		"description": "Returns the min and max of the entity's axis-aligned bounding box.",
		"prefix": "GetRotatedAABB"
	},
	"Entity:GetSaveTable": {
		"body": [
			"GetSaveTable(${1:showAll})$0"
		],
		"description": "Returns a table of save values for an entity.\n\nThese tables are not the same between the client and the server, and different entities may have different fields.\n\nYou can get the list different fields an entity has by looking at it's source code (the 2013 SDK can be found [online](https://github.com/ValveSoftware/source-sdk-2013)). Accessible fields are defined by each `DEFINE_FIELD` and `DEFINE_KEYFIELD` inside the `DATADESC` block.\n\nTake the headcrab, for example:\n\n```\nBEGIN_DATADESC( CBaseHeadcrab )\n// m_nGibCount - don't save\nDEFINE_FIELD( m_bHidden, FIELD_BOOLEAN ),\nDEFINE_FIELD( m_flTimeDrown, FIELD_TIME ),\nDEFINE_FIELD( m_bCommittedToJump, FIELD_BOOLEAN ),\nDEFINE_FIELD( m_vecCommittedJumpPos, FIELD_POSITION_VECTOR ),\nDEFINE_FIELD( m_flNextNPCThink, FIELD_TIME ),\nDEFINE_FIELD( m_flIgnoreWorldCollisionTime, FIELD_TIME ),\n\nDEFINE_KEYFIELD( m_bStartBurrowed, FIELD_BOOLEAN, \"startburrowed\" ),\nDEFINE_FIELD( m_bBurrowed, FIELD_BOOLEAN ),\nDEFINE_FIELD( m_flBurrowTime, FIELD_TIME ),\nDEFINE_FIELD( m_nContext, FIELD_INTEGER ),\nDEFINE_FIELD( m_bCrawlFromCanister, FIELD_BOOLEAN ),\nDEFINE_FIELD( m_bMidJump, FIELD_BOOLEAN ),\nDEFINE_FIELD( m_nJumpFromCanisterDir, FIELD_INTEGER ),\nDEFINE_FIELD( m_bHangingFromCeiling, FIELD_BOOLEAN ),\nDEFINE_FIELD( m_flIlluminatedTime, FIELD_TIME ),\n\nDEFINE_INPUTFUNC( FIELD_VOID, \"Burrow\", InputBurrow ),\nDEFINE_INPUTFUNC( FIELD_VOID, \"BurrowImmediate\", InputBurrowImmediate ),\nDEFINE_INPUTFUNC( FIELD_VOID, \"Unburrow\", InputUnburrow ),\nDEFINE_INPUTFUNC( FIELD_VOID, \"StartHangingFromCeiling\", InputStartHangingFromCeiling ),\nDEFINE_INPUTFUNC( FIELD_VOID, \"DropFromCeiling\", InputDropFromCeiling ),\n\n// Function Pointers\nDEFINE_THINKFUNC( EliminateRollAndPitch ),\nDEFINE_THINKFUNC( ThrowThink ),\nDEFINE_ENTITYFUNC( LeapTouch ),\nEND_DATADESC()\n```\n\n* For each **DEFINE_FIELD**, the save table will have a key with name of **first** argument.\n* For each **DEFINE_KEYFIELD**, the save table will have a key with name of the **third** argument.\n\nSee Entity:GetInternalVariable for only retrieving one key of the save table.",
		"prefix": "GetSaveTable"
	},
	"Entity:GetSequence": {
		"body": [
			"GetSequence()$0"
		],
		"description": "Return the index of the model sequence that is currently active for the entity.",
		"prefix": "GetSequence"
	},
	"Entity:GetSequenceActivity": {
		"body": [
			"GetSequenceActivity(${1:seq})$0"
		],
		"description": "Return activity id out of sequence id. Opposite of Entity:SelectWeightedSequence.",
		"prefix": "GetSequenceActivity"
	},
	"Entity:GetSequenceActivityName": {
		"body": [
			"GetSequenceActivityName(${1:sequenceId})$0"
		],
		"description": "Returns the activity name for the given sequence id.",
		"prefix": "GetSequenceActivityName"
	},
	"Entity:GetSequenceCount": {
		"body": [
			"GetSequenceCount()$0"
		],
		"description": "Returns the amount of sequences ( animations ) the entity's model has.",
		"prefix": "GetSequenceCount"
	},
	"Entity:GetSequenceGroundSpeed": {
		"body": [
			"GetSequenceGroundSpeed(${1:sequenceId})$0"
		],
		"description": "Returns the ground speed of the entity's sequence.",
		"prefix": "GetSequenceGroundSpeed"
	},
	"Entity:GetSequenceInfo": {
		"body": [
			"GetSequenceInfo(${1:sequenceId})$0"
		],
		"description": "Returns a table of information about an entity's sequence.",
		"prefix": "GetSequenceInfo"
	},
	"Entity:GetSequenceList": {
		"body": [
			"GetSequenceList()$0"
		],
		"description": "Returns a list of all sequences ( animations ) the model has.",
		"prefix": "GetSequenceList"
	},
	"Entity:GetSequenceMoveDist": {
		"body": [
			"GetSequenceMoveDist(${1:sequenceId})$0"
		],
		"description": "Returns an entity's sequence move distance (the change in position over the course of the entire sequence).",
		"prefix": "GetSequenceMoveDist"
	},
	"Entity:GetSequenceMoveYaw": {
		"body": [
			"GetSequenceMoveYaw(${1:seq})$0"
		],
		"description": "Returns the change in heading direction in between the start and the end of the sequence.",
		"prefix": "GetSequenceMoveYaw"
	},
	"Entity:GetSequenceMovement": {
		"body": [
			"GetSequenceMovement(${1:sequenceId}, ${2:startCycle=0}, ${3:endCyclnde=1})$0"
		],
		"description": "Returns the delta movement and angles of a sequence of the entity's model.",
		"prefix": "GetSequenceMovement"
	},
	"Entity:GetSequenceName": {
		"body": [
			"GetSequenceName(${1:index})$0"
		],
		"description": "Return the name of the sequence for the index provided.\nRefer to Entity:GetSequence to find the current active sequence on this entity.",
		"prefix": "GetSequenceName"
	},
	"Entity:GetShouldPlayPickupSound": {
		"body": [
			"GetShouldPlayPickupSound()$0"
		],
		"description": "Checks if the entity plays a sound when picked up by a player.\n\nThis will return nil if Entity:SetShouldPlayPickupSound has not been called.",
		"prefix": "GetShouldPlayPickupSound"
	},
	"Entity:GetShouldServerRagdoll": {
		"body": [
			"GetShouldServerRagdoll()$0"
		],
		"description": "Returns if entity should create a server ragdoll on death or a client one.",
		"prefix": "GetShouldServerRagdoll"
	},
	"Entity:GetSkin": {
		"body": [
			"GetSkin()$0"
		],
		"description": "Returns the skin index of the current skin.",
		"prefix": "GetSkin"
	},
	"Entity:GetSolid": {
		"body": [
			"GetSolid()$0"
		],
		"description": "Returns solid type of an entity.",
		"prefix": "GetSolid"
	},
	"Entity:GetSolidFlags": {
		"body": [
			"GetSolidFlags()$0"
		],
		"description": "Returns solid flag(s) of an entity.",
		"prefix": "GetSolidFlags"
	},
	"Entity:GetSpawnEffect": {
		"body": [
			"GetSpawnEffect()$0"
		],
		"description": "Returns if we should show a spawn effect on spawn on this entity.",
		"prefix": "GetSpawnEffect"
	},
	"Entity:GetSpawnFlags": {
		"body": [
			"GetSpawnFlags()$0"
		],
		"description": "Returns the bitwise spawn flags used by the entity.",
		"prefix": "GetSpawnFlags"
	},
	"Entity:GetSubMaterial": {
		"body": [
			"GetSubMaterial(${1:index})$0"
		],
		"description": "Returns the material override for the given index.\n\nReturns \"\" if no material override exists. Use Entity:GetMaterials to list it's default materials.\n\nThe server's value takes priority on the client.",
		"prefix": "GetSubMaterial"
	},
	"Entity:GetSubModels": {
		"body": [
			"GetSubModels()$0"
		],
		"description": "Returns a list of models included into the entity's model in the .qc file.",
		"prefix": "GetSubModels"
	},
	"Entity:GetTable": {
		"body": [
			"GetTable()$0"
		],
		"description": "Returns the table that contains all values saved within the entity.",
		"prefix": "GetTable"
	},
	"Entity:GetTouchTrace": {
		"body": [
			"GetTouchTrace()$0"
		],
		"description": "Returns the last trace used in the collision callbacks such as ENTITY:StartTouch, ENTITY:Touch and ENTITY:EndTouch.\n\nThis returns the last collision trace used, regardless of the entity that caused it. As such, it's only reliable when used in the hooks mentioned above",
		"prefix": "GetTouchTrace"
	},
	"Entity:GetTransmitWithParent": {
		"body": [
			"GetTransmitWithParent()$0"
		],
		"description": "Returns true if the TransmitWithParent flag is set or not.",
		"prefix": "GetTransmitWithParent"
	},
	"Entity:GetUnFreezable": {
		"body": [
			"GetUnFreezable()$0"
		],
		"description": "Returns if the entity is unfreezable, meaning it can't be frozen with the physgun. By default props are freezable, so this function will typically return false.\n\nThis will return nil if Entity:SetUnFreezable has not been called.",
		"prefix": "GetUnFreezable"
	},
	"Entity:GetUp": {
		"body": [
			"GetUp()$0"
		],
		"description": "Returns the upward vector of the entity, as a normalized direction vector",
		"prefix": "GetUp"
	},
	"Entity:GetVar": {
		"body": [
			"GetVar(${1:key}, ${2:default=nil})$0"
		],
		"description": "Retrieves a value from entity's Entity:GetTable. Set by Entity:SetVar.",
		"prefix": "GetVar"
	},
	"Entity:GetVelocity": {
		"body": [
			"GetVelocity()$0"
		],
		"description": "Returns the entity's velocity.\n\nActually binds to CBaseEntity::GetAbsVelocity() on the server and C_BaseEntity::EstimateAbsVelocity() on the client. This returns the total velocity of the entity and is equal to local velocity + base velocity.\n\nThis can become out-of-sync on the client if the server has been up for a long time.",
		"prefix": "GetVelocity"
	},
	"Entity:GetWorkshopID": {
		"body": [
			"GetWorkshopID()$0"
		],
		"description": "Returns ID of workshop addon that the entity is from.\n\nThe function **currently** does nothing and always returns nil",
		"prefix": "GetWorkshopID"
	},
	"Entity:GetWorldTransformMatrix": {
		"body": [
			"GetWorldTransformMatrix()$0"
		],
		"description": "Returns the position and angle of the entity as a 3x4 matrix (VMatrix is 4x4 so the fourth row goes unused). The first three columns store the angle as a [rotation matrix](https://en.wikipedia.org/wiki/Rotation_matrix), and the fourth column stores the position vector.\n\nThis returns incorrect results for the angular component (columns 1-3) for the local player clientside.\n\nThis will use the local player's Global.EyeAngles in Category:3D_Rendering_Hooks.\n\nColumns 1-3 will be all 0 (angular component) in Category:3D_Rendering_Hooks while paused in single-player.",
		"prefix": "GetWorldTransformMatrix"
	},
	"Entity:GibBreakClient": {
		"body": [
			"GibBreakClient(${1:force}, ${2:clr=nil})$0"
		],
		"description": "Causes the entity to break into its current models gibs, if it has any.\n\nYou must call Entity:PrecacheGibs on the entity before using this function, or it will not create any gibs.\n\nIf called on server, the gibs will be spawned on the currently connected clients and will not be synchronized. Otherwise the gibs will be spawned only for the client the function is called on.\n\nNote, that this function will not remove or hide the entity it is called on.\n\nFor more expensive version of this function see Entity:GibBreakServer.",
		"prefix": "GibBreakClient"
	},
	"Entity:GibBreakServer": {
		"body": [
			"GibBreakServer(${1:force})$0"
		],
		"description": "Causes the entity to break into its current models gibs, if it has any.\n\nYou must call Entity:PrecacheGibs on the entity before using this function, or it will not create any gibs.\n\nThe gibs will be spawned on the server and be synchronized with all clients.\n\nNote, that this function will not remove or hide the entity it is called on.\n\nThis function is affected by `props_break_max_pieces_perframe` and `props_break_max_pieces` console variables.\n\nLarge numbers of serverside gibs will cause lag.\n\nYou can avoid this cost by spawning the gibs on the client using Entity:GibBreakClient\n\nDespite existing on client, it doesn't actually do anything on client.",
		"prefix": "GibBreakServer"
	},
	"Entity:HasBoneManipulations": {
		"body": [
			"HasBoneManipulations()$0"
		],
		"description": "Returns whether or not the bone manipulation functions have ever been called on given  entity.\n\nRelated functions are Entity:ManipulateBonePosition, Entity:ManipulateBoneAngles, Entity:ManipulateBoneJiggle, and Entity:ManipulateBoneScale.\n\nThis will return true if the entity's bones have ever been manipulated. Resetting the position/angles/jiggle/scaling to 0,0,0 will not affect this function.",
		"prefix": "HasBoneManipulations"
	},
	"Entity:HasFlexManipulatior": {
		"body": [
			"HasFlexManipulatior()$0"
		],
		"description": "Returns whether or not the the entity has had flex manipulations performed with Entity:SetFlexWeight or Entity:SetFlexScale.",
		"prefix": "HasFlexManipulatior"
	},
	"Entity:HasSpawnFlags": {
		"body": [
			"HasSpawnFlags(${1:spawnFlags})$0"
		],
		"description": "Returns whether this entity has the specified spawnflags bits set.",
		"prefix": "HasSpawnFlags"
	},
	"Entity:HeadTarget": {
		"body": [
			"HeadTarget(${1:origin})$0"
		],
		"description": "Returns the position of the head of this entity, NPCs use this internally to aim at their targets.\n\nThis only works on players and NPCs.",
		"prefix": "HeadTarget"
	},
	"Entity:Health": {
		"body": [
			"Health()$0"
		],
		"description": "Returns the health of the entity.",
		"prefix": "Health"
	},
	"Entity:Ignite": {
		"body": [
			"Ignite(${1:length}, ${2:radius=0})$0"
		],
		"description": "Sets the entity on fire.\n\nSee also Entity:Extinguish.",
		"prefix": "Ignite"
	},
	"Entity:InitializeAsClientEntity": {
		"body": [
			"InitializeAsClientEntity()$0"
		],
		"description": "\n\nInitializes this entity as being clientside only.\n\nOnly works on entities fully created clientside, and as such it has currently no use due this being automatically called by ents.CreateClientProp, ents.CreateClientside, Global.ClientsideModel and Global.ClientsideScene.\n\nCalling this on a clientside entity will crash the game.",
		"prefix": "InitializeAsClientEntity"
	},
	"Entity:Input": {
		"body": [
			"Input(${1:input}, ${2:activator}, ${3:caller}, ${4:param=nil})$0"
		],
		"description": "Fires input to the entity with the ability to make another entity responsible, bypassing the event queue system.\n\nYou should only use this function over Entity:Fire if you know what you are doing.\n\nSee also Entity:Fire for a function that conforms to the internal map IO event queue and GM:AcceptInput for a hook that can intercept inputs.",
		"prefix": "Input"
	},
	"Entity:InstallDataTable": {
		"body": [
			"InstallDataTable()$0"
		],
		"description": " Sets up Data Tables from entity to use with Entity:NetworkVar.",
		"prefix": "InstallDataTable"
	},
	"Entity:InvalidateBoneCache": {
		"body": [
			"InvalidateBoneCache()$0"
		],
		"description": "Resets the entity's bone cache values in order to prepare for a model change.\n\nThis should be called after calling Entity:SetPoseParameter.",
		"prefix": "InvalidateBoneCache"
	},
	"Entity:IsConstrained": {
		"body": [
			"IsConstrained()$0"
		],
		"description": "Returns true if the entity has constraints attached to it\n\nThis will only update clientside if the server calls it first. This only checks constraints added through the constraint so this will not react to map constraints.",
		"prefix": "IsConstrained"
	},
	"Entity:IsConstraint": {
		"body": [
			"IsConstraint()$0"
		],
		"description": "Returns if entity is constraint or not",
		"prefix": "IsConstraint"
	},
	"Entity:IsDormant": {
		"body": [
			"IsDormant()$0"
		],
		"description": "Returns whether the entity is dormant or not. Client/server entities become dormant when they leave the PVS on the server. Client side entities can decide for themselves whether to become dormant. This mainly applies to PVS.",
		"prefix": "IsDormant"
	},
	"Entity:IsEFlagSet": {
		"body": [
			"IsEFlagSet(${1:flag})$0"
		],
		"description": "Checks if given flag is set or not.",
		"prefix": "IsEFlagSet"
	},
	"Entity:IsEffectActive": {
		"body": [
			"IsEffectActive(${1:effect})$0"
		],
		"description": "Returns whether an entity has engine effect applied or not.",
		"prefix": "IsEffectActive"
	},
	"Entity:IsFlagSet": {
		"body": [
			"IsFlagSet(${1:flag})$0"
		],
		"description": "Checks if given flag(s) is set or not.",
		"prefix": "IsFlagSet"
	},
	"Entity:IsInWorld": {
		"body": [
			"IsInWorld()$0"
		],
		"description": "Returns whether the entity is inside a wall or outside of the map.\n\nInternally this function uses util.IsInWorld, that means that this function only checks Entity:GetPos of the entity. If an entity is only partially inside a wall, or has a weird GetPos offset, this function may not give reliable output.",
		"prefix": "IsInWorld"
	},
	"Entity:IsLagCompensated": {
		"body": [
			"IsLagCompensated()$0"
		],
		"description": "Returns whether the entity is lag compensated or not.",
		"prefix": "IsLagCompensated"
	},
	"Entity:IsLineOfSightClear": {
		"body": [
			"IsLineOfSightClear(${1:target})$0"
		],
		"description": "Returns true if the target is in line of sight.\nThis will only work when called on CBaseCombatCharacter entities. This includes players, NPCs, grenades, RPG rockets, crossbow bolts, and physics cannisters.",
		"prefix": "IsLineOfSightClear"
	},
	"Entity:IsMarkedForDeletion": {
		"body": [
			"IsMarkedForDeletion()$0"
		],
		"description": "Returns if the entity is going to be deleted in the next frame.",
		"prefix": "IsMarkedForDeletion"
	},
	"Entity:IsNPC": {
		"body": [
			"IsNPC()$0"
		],
		"description": "Checks if the entity is an NPC or not.\n\nThis will return false for NextBots, see Entity:IsNextBot for that.",
		"prefix": "IsNPC"
	},
	"Entity:IsNextBot": {
		"body": [
			"IsNextBot()$0"
		],
		"description": "Checks if the entity is a NextBot or not.",
		"prefix": "IsNextBot"
	},
	"Entity:IsOnFire": {
		"body": [
			"IsOnFire()$0"
		],
		"description": "Returns whether the entity is on fire.",
		"prefix": "IsOnFire"
	},
	"Entity:IsOnGround": {
		"body": [
			"IsOnGround()$0"
		],
		"description": "Returns whether the entity is on ground or not.\n\nInternally, this checks if Enums/FL is set on the entity.\n\nThis function is an alias of Entity:OnGround.",
		"prefix": "IsOnGround"
	},
	"Entity:IsPlayer": {
		"body": [
			"IsPlayer()$0"
		],
		"description": "Checks if the entity is a player or not.",
		"prefix": "IsPlayer"
	},
	"Entity:IsPlayerHolding": {
		"body": [
			"IsPlayerHolding()$0"
		],
		"description": "Returns true if the entity is being held by a player. Either by physics gun, gravity gun or use-key (+use).\n\nIf multiple players are holding an object and one drops it, this will return false despite the object still being held.",
		"prefix": "IsPlayerHolding"
	},
	"Entity:IsPlayingGesture": {
		"body": [
			"IsPlayingGesture(${1:activity})$0"
		],
		"description": "Returns whether there's a gesture is given activity being played.\n\nThis function only works on BaseAnimatingOverlay entites!",
		"prefix": "IsPlayingGesture"
	},
	"Entity:IsRagdoll": {
		"body": [
			"IsRagdoll()$0"
		],
		"description": "Checks if the entity is a ragdoll.",
		"prefix": "IsRagdoll"
	},
	"Entity:IsScripted": {
		"body": [
			"IsScripted()$0"
		],
		"description": "Checks if the entity is a SENT or a built-in entity.",
		"prefix": "IsScripted"
	},
	"Entity:IsSequenceFinished": {
		"body": [
			"IsSequenceFinished()$0"
		],
		"description": "Returns whether the entity's current sequence is finished or not.",
		"prefix": "IsSequenceFinished"
	},
	"Entity:IsSolid": {
		"body": [
			"IsSolid()$0"
		],
		"description": "Returns if the entity is solid or not.\nVery useful for determining if the entity is a trigger or not.",
		"prefix": "IsSolid"
	},
	"Entity:IsValid": {
		"body": [
			"IsValid()$0"
		],
		"description": "Returns whether the entity is a valid entity or not.\n\nAn entity is valid if:\n* It is not a Global_Variables entity\n* It is not the worldspawn entity (game.GetWorld)\n\nInstead of calling this method directly, it's a good idea to call the global Global.IsValid instead, however if you're sure the variable you're using is always an entity object it's better to use this method\n\nIt will check whether the given variable contains an object (an Entity) or nothing at all for you. See examples.\n\nNULL entities can still be assigned with key/value pairs, but they will be instantly negated. See example 3\nThis might be a cause for a lot of headache. Usually happening during networking etc., when completely valid entities suddenly become invalid on the client, but are never filtered with IsValid(). See GM:InitPostEntity for more details.",
		"prefix": "IsValid"
	},
	"Entity:IsValidLayer": {
		"body": [
			"IsValidLayer(${1:layerID})$0"
		],
		"description": "Returns whether the given layer ID is valid and exists on this entity.\n\nThis function only works on BaseAnimatingOverlay entities.",
		"prefix": "IsValidLayer"
	},
	"Entity:IsVehicle": {
		"body": [
			"IsVehicle()$0"
		],
		"description": "Checks if the entity is a vehicle or not.",
		"prefix": "IsVehicle"
	},
	"Entity:IsWeapon": {
		"body": [
			"IsWeapon()$0"
		],
		"description": "Checks if the entity is a weapon or not.",
		"prefix": "IsWeapon"
	},
	"Entity:IsWidget": {
		"body": [
			"IsWidget()$0"
		],
		"description": "Returns whether the entity is a widget or not.\n\nThis is used by the \"Edit Bones\" context menu property.",
		"prefix": "IsWidget"
	},
	"Entity:IsWorld": {
		"body": [
			"IsWorld()$0"
		],
		"description": "Returns if the entity is the map's Entity[0] worldspawn",
		"prefix": "IsWorld"
	},
	"Entity:LocalToWorld": {
		"body": [
			"LocalToWorld(${1:lpos})$0"
		],
		"description": "Converts a vector local to an entity into a worldspace vector",
		"prefix": "LocalToWorld"
	},
	"Entity:LocalToWorldAngles": {
		"body": [
			"LocalToWorldAngles(${1:ang})$0"
		],
		"description": "Converts a local angle (local to the entity) to a world angle.",
		"prefix": "LocalToWorldAngles"
	},
	"Entity:LookupAttachment": {
		"body": [
			"LookupAttachment(${1:attachmentName})$0"
		],
		"description": "Returns the attachment index of the given attachment name.",
		"prefix": "LookupAttachment"
	},
	"Entity:LookupBone": {
		"body": [
			"LookupBone(${1:boneName})$0"
		],
		"description": "Gets the bone index of the given bone name, returns nothing if the bone does not exist.",
		"prefix": "LookupBone"
	},
	"Entity:LookupPoseParameter": {
		"body": [
			"LookupPoseParameter(${1:name})$0"
		],
		"description": "Returns pose parameter ID from its name.",
		"prefix": "LookupPoseParameter"
	},
	"Entity:LookupSequence": {
		"body": [
			"LookupSequence(${1:name})$0"
		],
		"description": "Returns sequence ID from its name.",
		"prefix": "LookupSequence"
	},
	"Entity:MakePhysicsObjectAShadow": {
		"body": [
			"MakePhysicsObjectAShadow(${1:allowPhysicsMovement}, ${2:allowPhysicsRotation})$0"
		],
		"description": "Turns the Entity:GetPhysicsObject into a physics shadow.\nIt's used internally for the Player's and NPC's physics object, and certain HL2 entities such as the crane.\n\nA physics shadow can be used to have static entities that never move by setting both arguments to false.\n\nUnlike Entity:PhysicsInitShadow, this function doesn't remove the current physics object.",
		"prefix": "MakePhysicsObjectAShadow"
	},
	"Entity:ManipulateBoneAngles": {
		"body": [
			"ManipulateBoneAngles(${1:boneID}, ${2:ang})$0"
		],
		"description": "Sets custom bone angles.\n\nThe repeated use of bone manipulation in multiplayer games is highly discouraged due to the huge produced network traffic.",
		"prefix": "ManipulateBoneAngles"
	},
	"Entity:ManipulateBoneJiggle": {
		"body": [
			"ManipulateBoneJiggle(${1:boneID}, ${2:enabled})$0"
		],
		"description": "Manipulates the bone's jiggle status. This allows non jiggly bones to become jiggly.",
		"prefix": "ManipulateBoneJiggle"
	},
	"Entity:ManipulateBonePosition": {
		"body": [
			"ManipulateBonePosition(${1:boneID}, ${2:pos})$0"
		],
		"description": "Sets custom bone offsets.",
		"prefix": "ManipulateBonePosition"
	},
	"Entity:ManipulateBoneScale": {
		"body": [
			"ManipulateBoneScale(${1:boneID}, ${2:scale})$0"
		],
		"description": "Sets custom bone scale.\n\nWhen used serverside, this method produces a huge network consumption!\n\nThis does not scale procedural bones.",
		"prefix": "ManipulateBoneScale"
	},
	"Entity:MapCreationID": {
		"body": [
			"MapCreationID()$0"
		],
		"description": "Returns entity's map creation ID. Unlike Entity:EntIndex or Entity:GetCreationID, it will always be the same on same map, no matter how much you clean up or restart it.\n\nTo be used in conjunction with ents.GetMapCreatedEntity.",
		"prefix": "MapCreationID"
	},
	"Entity:MarkShadowAsDirty": {
		"body": [
			"MarkShadowAsDirty()$0"
		],
		"description": "Refreshes the shadow of the entity.",
		"prefix": "MarkShadowAsDirty"
	},
	"Entity:MuzzleFlash": {
		"body": [
			"MuzzleFlash()$0"
		],
		"description": "Fires the muzzle flash effect of the weapon the entity is carrying. This only creates a light effect and is often called alongside Weapon:SendWeaponAnim",
		"prefix": "MuzzleFlash"
	},
	"Entity:NearestPoint": {
		"body": [
			"NearestPoint(${1:position})$0"
		],
		"description": "Performs a Ray-Orientated Bounding Box intersection from the given position to the origin of the OBBox with the entity and returns the hit position on the OBBox.\n\nThis relies on the entity having a collision mesh (not a physics object) and will be affected by `SOLID_NONE`",
		"prefix": "NearestPoint"
	},
	"Entity:NetworkVar": {
		"body": [
			"NetworkVar(${1:type}, ${2:slot}, ${3:name}, ${4:extended=nil})$0"
		],
		"description": "Creates a network variable on the entity and adds Set/Get functions for it. This function should only be called in ENTITY:SetupDataTables.\n\nSee Entity:NetworkVarNotify for a function to hook NetworkVar changes.\n\nMake sure to not call the SetDT* and your custom set methods on the client realm unless you know exactly what you are doing.",
		"prefix": "NetworkVar"
	},
	"Entity:NetworkVarElement": {
		"body": [
			"NetworkVarElement(${1:type}, ${2:slot}, ${3:element}, ${4:name}, ${5:extended=nil})$0"
		],
		"description": "Similarly to Entity:NetworkVar, creates a network variable on the entity and adds Set/Get functions for it. This method stores it's value as a member value of a vector or an angle. This allows to go beyond the normal variable limit of Entity:NetworkVar for `Int` and `Float` types, at the expense of `Vector` and `Angle` limit.\n\nThis function should only be called in ENTITY:SetupDataTables.\n\nMake sure to not call the SetDT* and your custom set methods on the client realm unless you know exactly what you are doing.",
		"prefix": "NetworkVarElement"
	},
	"Entity:NetworkVarNotify": {
		"body": [
			"NetworkVarNotify(${1:name}, ${2:callback})$0"
		],
		"description": "Creates a callback that will execute when the given network variable changes - that is, when the `Set()` function is run.\n\nThe callback is executed **before** the value is changed, and is called even if the new and old values are the same.\n\nThis function does not exist on entities in which Entity:InstallDataTable has not been called. By default, this means this function only exists on SENTs (both serverside and clientside) and on players with a Player_Classes (serverside and clientside Global.LocalPlayer only). It's therefore safest to only use this in ENTITY:SetupDataTables.\n\nThe callback will not be called clientside if the var is changed right after entity spawn.\n",
		"prefix": "NetworkVarNotify"
	},
	"Entity:NextThink": {
		"body": [
			"NextThink(${1:timestamp})$0"
		],
		"description": "In the case of a scripted entity, this will cause the next ENTITY:Think event to be run at the given time.\n\nDoes not work clientside! Use Entity:SetNextClientThink instead.\n\nThis does not work with SWEPs or Nextbots.",
		"prefix": "NextThink"
	},
	"Entity:OBBCenter": {
		"body": [
			"OBBCenter()$0"
		],
		"description": "Returns the center of an entity's bounding box as a local vector.",
		"prefix": "OBBCenter"
	},
	"Entity:OBBMaxs": {
		"body": [
			"OBBMaxs()$0"
		],
		"description": "Returns the highest corner of an entity's bounding box as a local vector.",
		"prefix": "OBBMaxs"
	},
	"Entity:OBBMins": {
		"body": [
			"OBBMins()$0"
		],
		"description": "Returns the lowest corner of an entity's bounding box as a local vector.",
		"prefix": "OBBMins"
	},
	"Entity:ObjectCaps": {
		"body": [
			"ObjectCaps()$0"
		],
		"description": "Returns the entity's capabilities as a bitfield.\n\nIn the engine this function is mostly used to check the use type, the save/restore system and level transitions flags.\n\nEven though the function is defined shared, it is not guaranteed to return the same value across states.\n\nThe enums for this are not currently implemented in Lua, however you can access the defines [here](https://github.com/ValveSoftware/source-sdk-2013/blob/55ed12f8d1eb6887d348be03aee5573d44177ffb/mp/src/game/shared/baseentity_shared.h#L21-L38).",
		"prefix": "ObjectCaps"
	},
	"Entity:OnGround": {
		"body": [
			"OnGround()$0"
		],
		"description": "Returns true if the entity is on the ground, and false if it isn't.\n\nInternally, this checks if Enums/FL is set on the entity. This is only updated for players and NPCs, and thus won't inherently work for other entities.",
		"prefix": "OnGround"
	},
	"Entity:PassesDamageFilter": {
		"body": [
			"PassesDamageFilter(${1:dmg})$0"
		],
		"description": "Tests whether the damage passes the entity filter.\n\nThis will call ENTITY:PassesDamageFilter on scripted entities of the type \"filter\".\n\nThis function only works on entities of the type \"filter\". ( filter_* entities, including base game filter entites )",
		"prefix": "PassesDamageFilter"
	},
	"Entity:PassesFilter": {
		"body": [
			"PassesFilter(${1:caller}, ${2:ent})$0"
		],
		"description": "Tests whether the entity passes the entity filter.\n\nThis will call ENTITY:PassesFilter on scripted entities of the type \"filter\".\n\nThis function only works on entities of the type \"filter\". ( filter_* entities, including base game filter entites )",
		"prefix": "PassesFilter"
	},
	"Entity:PhysWake": {
		"body": [
			"PhysWake()$0"
		],
		"description": "Wakes up the entity's physics object",
		"prefix": "PhysWake"
	},
	"Entity:PhysicsDestroy": {
		"body": [
			"PhysicsDestroy()$0"
		],
		"description": "Destroys the current physics object of an entity.\n\nCannot be used on a ragdoll or the world entity.",
		"prefix": "PhysicsDestroy"
	},
	"Entity:PhysicsFromMesh": {
		"body": [
			"PhysicsFromMesh(${1:vertices})$0"
		],
		"description": "Initializes the physics mesh of the entity from a triangle soup defined by a table of vertices. The resulting mesh is hollow, may contain holes, and always has a volume of 0.\n\nWhile this is very useful for static geometry such as terrain displacements, it is advised to use Entity:PhysicsInitConvex or Entity:PhysicsInitMultiConvex for moving solid objects instead.\n\nEntity:EnableCustomCollisions needs to be called if you want players to collide with the entity correctly.",
		"prefix": "PhysicsFromMesh"
	},
	"Entity:PhysicsInit": {
		"body": [
			"PhysicsInit(${1:solidType})$0"
		],
		"description": "Initializes the Entity:GetPhysicsObject of the entity using its current Entity:GetModel. Deletes the previous physics object if it existed and the new object creation was successful.\n\nIf the entity's current model has no physics mesh associated to it, no physics object will be created and the previous object will still exist, if applicable.\n\nWhen called clientside, this will not create a valid PhysObj if the model hasn't been util.PrecacheModel serverside.\n\nIf successful, this function will automatically call Entity:SetSolid( solidType ) and Entity:SetSolidFlags( 0 ).\n\nClientside physics objects are broken and do not move properly in some cases. Physics objects should only created on the server or you will experience incorrect physgun beam position, prediction issues, and other unexpected behavior.",
		"prefix": "PhysicsInit"
	},
	"Entity:PhysicsInitBox": {
		"body": [
			"PhysicsInitBox(${1:mins}, ${2:maxs})$0"
		],
		"description": "Makes the physics object of the entity a AABB.\n\nIf the volume of the resulting box is 0 (the mins and maxs are the same), the mins and maxs will be changed to Global.Vector( -1, -1, -1 ) and Global.Vector( 1, 1, 1 ), respectively.\n\nThis function will automatically destroy any previous physics objects if successful and call Entity:SetSolid( SOLID_BBOX ), Entity:SetMoveType( MOVETYPE_VPHYSICS ), and Entity:SetCollisionBounds( mins, maxs ).\n\nClientside physics objects are broken and do not move properly in some cases. Physics objects should only created on the server or you will experience incorrect physgun beam position, prediction issues, and other unexpected behavior.",
		"prefix": "PhysicsInitBox"
	},
	"Entity:PhysicsInitConvex": {
		"body": [
			"PhysicsInitConvex(${1:points})$0"
		],
		"description": "Initializes the physics mesh of the entity with a convex mesh defined by a table of points. The resulting mesh is the  of all the input points. If successful, the previous physics object will be removed.\n\nThis is the standard way of creating moving physics objects with a custom convex shape. For more complex, concave shapes, see Entity:PhysicsInitMultiConvex.\n\nThis will crash if given all Global.Vector(0,0,0)s.\n\nClientside physics objects are broken and do not move properly in some cases. Physics objects should only created on the server or you will experience incorrect physgun beam position, prediction issues, and other unexpected behavior.",
		"prefix": "PhysicsInitConvex"
	},
	"Entity:PhysicsInitMultiConvex": {
		"body": [
			"PhysicsInitMultiConvex(${1:vertices})$0"
		],
		"description": "An advanced version of Entity:PhysicsInitConvex which initializes a physics object from multiple convex meshes. This should be used for physics objects with a custom shape which cannot be represented by a single convex mesh.\n\nIf successful, the previous physics object will be removed.\n\nClientside physics objects are broken and do not move properly in some cases. Physics objects should only created on the server or you will experience incorrect physgun beam position, prediction issues, and other unexpected behavior.\n\nYou can use the following work-around for movement, though clientside collisions will still be broken.\n\n\n```\nfunction ENT:Think()\nif ( CLIENT ) then\nlocal physobj = self:GetPhysicsObject()\n\nif ( IsValid( physobj ) ) then\nphysobj:SetPos( self:GetPos() )\nphysobj:SetAngles( self:GetAngles() )\nend\nend\nend\n```\n",
		"prefix": "PhysicsInitMultiConvex"
	},
	"Entity:PhysicsInitShadow": {
		"body": [
			"PhysicsInitShadow(${1:allowPhysicsMovement=true}, ${2:allowPhysicsRotation=true})$0"
		],
		"description": "Initializes the entity's physics object as a physics shadow. Removes the previous physics object if successful. This is used internally for the Player's and NPC's physics object, and certain HL2 entities such as the crane.\n\nA physics shadow can be used to have static entities that never move by setting both arguments to false.\n\nClientside physics objects are broken and do not move properly in some cases. Physics objects should only created on the server or you will experience incorrect physgun beam position, prediction issues, and other unexpected behavior.",
		"prefix": "PhysicsInitShadow"
	},
	"Entity:PhysicsInitSphere": {
		"body": [
			"PhysicsInitSphere(${1:radius}, ${2:physmat})$0"
		],
		"description": "Makes the physics object of the entity a sphere.\n\nThis function will automatically destroy any previous physics objects and call Entity:SetSolid( SOLID_BBOX ) and Entity:SetMoveType( MOVETYPE_VPHYSICS ).\n\nClientside physics objects are broken and do not move properly in some cases. Physics objects should only created on the server or you will experience incorrect physgun beam position, prediction issues, and other unexpected behavior.",
		"prefix": "PhysicsInitSphere"
	},
	"Entity:PhysicsInitStatic": {
		"body": [
			"PhysicsInitStatic(${1:solidType})$0"
		],
		"description": "Initializes a static physics object of the entity using its Entity:GetModel. If successful, the previous physics object is removed.\n\nThis is what used by entities such as func_breakable, prop_dynamic, item_suitcharger, prop_thumper and npc_rollermine while it is in its \"buried\" state in the Half-Life 2 Campaign.\n\nIf the entity's current model has no physics mesh associated to it, no physics object will be created.\n\nThis function will automatically call Entity:SetSolid( solidType ).\n\nClientside physics objects are broken and do not move properly in some cases. Physics objects should only created on the server or you will experience incorrect physgun beam position, prediction issues, and other unexpected behavior.",
		"prefix": "PhysicsInitStatic"
	},
	"Entity:PlayScene": {
		"body": [
			"PlayScene(${1:scene}, ${2:delay=0})$0"
		],
		"description": "Makes the entity play a .vcd scene.",
		"prefix": "PlayScene"
	},
	"Entity:PointAtEntity": {
		"body": [
			"PointAtEntity(${1:target})$0"
		],
		"description": "Changes an entities angles so that it faces the target entity.",
		"prefix": "PointAtEntity"
	},
	"Entity:PrecacheGibs": {
		"body": [
			"PrecacheGibs()$0"
		],
		"description": "Precaches gibs for the entity's model.\n\nNormally this function should be ran when the entity is spawned, for example the ENTITY:Initialize, after Entity:SetModel is called.\n\nThis is required for Entity:GibBreakServer and Entity:GibBreakClient to work.",
		"prefix": "PrecacheGibs"
	},
	"Entity:RagdollSolve": {
		"body": [
			"RagdollSolve()$0"
		],
		"description": "Normalizes the ragdoll. This is used alongside Kinect in Entity:SetRagdollBuildFunction, for more info see ragdoll_motion entity.",
		"prefix": "RagdollSolve"
	},
	"Entity:RagdollStopControlling": {
		"body": [
			"RagdollStopControlling()$0"
		],
		"description": "Sets the function to build the ragdoll. This is used alongside Kinect in Entity:SetRagdollBuildFunction, for more info see ragdoll_motion entity.",
		"prefix": "RagdollStopControlling"
	},
	"Entity:RagdollUpdatePhysics": {
		"body": [
			"RagdollUpdatePhysics()$0"
		],
		"description": "Makes the physics objects follow the set bone positions. This is used alongside Kinect in Entity:SetRagdollBuildFunction, for more info see ragdoll_motion entity.",
		"prefix": "RagdollUpdatePhysics"
	},
	"Entity:Remove": {
		"body": [
			"Remove()$0"
		],
		"description": "Removes the entity it is used on. The entity will be removed at the start of next tick.",
		"prefix": "Remove"
	},
	"Entity:RemoveAllDecals": {
		"body": [
			"RemoveAllDecals()$0"
		],
		"description": "Removes all decals from the entities surface.",
		"prefix": "RemoveAllDecals"
	},
	"Entity:RemoveAllGestures": {
		"body": [
			"RemoveAllGestures()$0"
		],
		"description": "Removes and stops all gestures.\n\nThis function only works on BaseAnimatingOverlay entites!",
		"prefix": "RemoveAllGestures"
	},
	"Entity:RemoveCallOnRemove": {
		"body": [
			"RemoveCallOnRemove(${1:identifier})$0"
		],
		"description": "Removes a function previously added via Entity:CallOnRemove.",
		"prefix": "RemoveCallOnRemove"
	},
	"Entity:RemoveCallback": {
		"body": [
			"RemoveCallback(${1:hook}, ${2:callbackid})$0"
		],
		"description": "Removes a callback previously added with Entity:AddCallback",
		"prefix": "RemoveCallback"
	},
	"Entity:RemoveEFlags": {
		"body": [
			"RemoveEFlags(${1:flag})$0"
		],
		"description": "Removes specified engine flag",
		"prefix": "RemoveEFlags"
	},
	"Entity:RemoveEffects": {
		"body": [
			"RemoveEffects(${1:effect})$0"
		],
		"description": "Removes an engine effect applied to an entity.",
		"prefix": "RemoveEffects"
	},
	"Entity:RemoveFlags": {
		"body": [
			"RemoveFlags(${1:flag})$0"
		],
		"description": "Removes specified flag(s) from the entity",
		"prefix": "RemoveFlags"
	},
	"Entity:RemoveFromMotionController": {
		"body": [
			"RemoveFromMotionController(${1:physObj})$0"
		],
		"description": "Removes a PhysObject from the entity's motion controller so that ENTITY:PhysicsSimulate will no longer be called for given PhysObject.\n\nYou must first create a motion controller with Entity:StartMotionController.\n\nOnly works on a scripted Entity of anim type",
		"prefix": "RemoveFromMotionController"
	},
	"Entity:RemoveGesture": {
		"body": [
			"RemoveGesture(${1:activity})$0"
		],
		"description": "Removes and stops the gesture with given activity.\n\nThis function only works on BaseAnimatingOverlay entites!",
		"prefix": "RemoveGesture"
	},
	"Entity:RemoveInternalConstraint": {
		"body": [
			"RemoveInternalConstraint(${1:num=-1})$0"
		],
		"description": "Breaks internal Ragdoll constrains, so you can for example separate an arm from the body of a ragdoll and preserve all physics.\n\nThe visual mesh will still stretch as if it was properly connected unless the ragdoll model is specifically designed to avoid that.",
		"prefix": "RemoveInternalConstraint"
	},
	"Entity:RemoveSolidFlags": {
		"body": [
			"RemoveSolidFlags(${1:flags})$0"
		],
		"description": "Removes solid flag(s) from the entity.",
		"prefix": "RemoveSolidFlags"
	},
	"Entity:ResetSequence": {
		"body": [
			"ResetSequence(${1:sequence})$0"
		],
		"description": "Plays an animation on the entity. This may not always work on engine entities.\n\nThis will not reset the animation on viewmodels, use Entity:SendViewModelMatchingSequence instead.\n\nThis will not work properly if called directly after calling Entity:SetModel. Consider waiting until the next Tick.\n\nWill not work on players due to the animations being reset every frame by the base gamemode animation system. See GM:CalcMainActivity.\n\nFor custom scripted entities you will want to apply example from ENTITY:Think to make animations work.",
		"prefix": "ResetSequence"
	},
	"Entity:ResetSequenceInfo": {
		"body": [
			"ResetSequenceInfo()$0"
		],
		"description": "Reset entity sequence info such as playback rate, ground speed, last event check, etc.",
		"prefix": "ResetSequenceInfo"
	},
	"Entity:Respawn": {
		"body": [
			"Respawn()$0"
		],
		"description": "Makes the entity/weapon respawn.\n\nOnly usable on HL2 pickups and any weapons. Seems to be buggy with weapons.\nVery unreliable.",
		"prefix": "Respawn"
	},
	"Entity:RestartGesture": {
		"body": [
			"RestartGesture(${1:activity}, ${2:addIfMissing=true}, ${3:autokill=true})$0"
		],
		"description": "Restarts the entity's animation gesture. If the given gesture is already playing, it will reset it and play it from the beginning.\n\nThis function only works on BaseAnimatingOverlay entites.",
		"prefix": "RestartGesture"
	},
	"Entity:SelectWeightedSequence": {
		"body": [
			"SelectWeightedSequence(${1:act})$0"
		],
		"description": "Returns sequence ID corresponding to given activity ID.\n\nOpposite of Entity:GetSequenceActivity.\n\nSimilar to Entity:LookupSequence.\n\nSee also Entity:SelectWeightedSequenceSeeded.",
		"prefix": "SelectWeightedSequence"
	},
	"Entity:SelectWeightedSequenceSeeded": {
		"body": [
			"SelectWeightedSequenceSeeded(${1:act}, ${2:seed})$0"
		],
		"description": "Returns the sequence ID corresponding to given activity ID, and uses the provided seed for random selection. The seed should be the same server-side and client-side if used in a predicted environment.\n\nSee Entity:SelectWeightedSequence for a provided-seed version of this function.",
		"prefix": "SelectWeightedSequenceSeeded"
	},
	"Entity:SendViewModelMatchingSequence": {
		"body": [
			"SendViewModelMatchingSequence(${1:seq})$0"
		],
		"description": "Sends sequence animation to the view model. It is recommended to use this for view model animations, instead of Entity:ResetSequence.\n\nThis function is only usable on view models.\n\nSequences 0-6 will not be looped regardless if they're marked as a looped animation or not.",
		"prefix": "SendViewModelMatchingSequence"
	},
	"Entity:SequenceDuration": {
		"body": [
			"SequenceDuration(${1:seqid=nil})$0"
		],
		"description": "Returns length of currently played sequence.\n\nThis will return incorrect results for weapons and viewmodels clientside in thirdperson.",
		"prefix": "SequenceDuration"
	},
	"Entity:SetAbsVelocity": {
		"body": [
			"SetAbsVelocity(${1:velocity})$0"
		],
		"description": "Sets the entity's velocity.\n\nActually binds to CBaseEntity::SetLocalVelocity() which sets the entity's velocity due to movement in the world from forces such as gravity. Does not include velocity from entity-on-entity collision or other world movement.",
		"prefix": "SetAbsVelocity"
	},
	"Entity:SetAngles": {
		"body": [
			"SetAngles(${1:angles})$0"
		],
		"description": "Sets the angles of the entity.\n\nTo set a player's angles, use Player:SetEyeAngles instead.",
		"prefix": "SetAngles"
	},
	"Entity:SetAnimTime": {
		"body": [
			"SetAnimTime(${1:time})$0"
		],
		"description": "Sets the start time (relative to Global.CurTime) of the current animation, which is used to determine Entity:GetCycle. Should be less than CurTime to play an animation from the middle.",
		"prefix": "SetAnimTime"
	},
	"Entity:SetAnimation": {
		"body": [
			"SetAnimation(${1:playerAnim})$0"
		],
		"description": "Sets a player's third-person animation. Mainly used by Weapons to start the player's weapon attack and reload animations.",
		"prefix": "SetAnimation"
	},
	"Entity:SetAttachment": {
		"body": [
			"SetAttachment(${1:ent}, ${2:attachment})$0"
		],
		"description": "You should be using Entity:SetParent instead.\n\nParents the sprite to an attachment on another model.\n\nWorks only on env_sprite.\n\nDespite existing on client, it doesn't actually do anything on client.",
		"prefix": "SetAttachment"
	},
	"Entity:SetBloodColor": {
		"body": [
			"SetBloodColor(${1:bloodColor})$0"
		],
		"description": "Sets the blood color this entity uses.",
		"prefix": "SetBloodColor"
	},
	"Entity:SetBodyGroups": {
		"body": [
			"SetBodyGroups(${1:bodygroups})$0"
		],
		"description": "Sets the bodygroups from a string. A convenience function for Entity:SetBodygroup.",
		"prefix": "SetBodyGroups"
	},
	"Entity:SetBodygroup": {
		"body": [
			"SetBodygroup(${1:bodygroup}, ${2:value})$0"
		],
		"description": "Sets an entities' bodygroup.",
		"prefix": "SetBodygroup"
	},
	"Entity:SetBoneController": {
		"body": [
			"SetBoneController(${1:boneControllerID}, ${2:value})$0"
		],
		"description": "Sets the specified value on the bone controller with the given ID of this entity, it's used in HL1 to change the head rotation of NPCs, turret aiming and so on.\n\nThis is the precursor of pose parameters, and only works for Half Life 1: Source models supporting it.",
		"prefix": "SetBoneController"
	},
	"Entity:SetBoneMatrix": {
		"body": [
			"SetBoneMatrix(${1:boneid}, ${2:matrix})$0"
		],
		"description": "Sets the bone matrix of given bone to given matrix. See also Entity:GetBoneMatrix.\n\nDespite existing serverside, it does nothing.",
		"prefix": "SetBoneMatrix"
	},
	"Entity:SetBonePosition": {
		"body": [
			"SetBonePosition(${1:bone}, ${2:pos}, ${3:ang})$0"
		],
		"description": "Sets the bone position and angles.",
		"prefix": "SetBonePosition"
	},
	"Entity:SetCollisionBounds": {
		"body": [
			"SetCollisionBounds(${1:mins}, ${2:maxs})$0"
		],
		"description": "Sets the collision bounds for the entity, which are used for triggers ( Entity:SetTrigger, ENTITY:Touch ), and collision ( If Entity:SetSolid set as Enums/SOLID ).\n\nInput bounds are relative to Entity:GetPos!\nSee also Entity:SetCollisionBoundsWS.\n\nPlayer collision bounds are reset every frame to player's Player:SetHull values.",
		"prefix": "SetCollisionBounds"
	},
	"Entity:SetCollisionBoundsWS": {
		"body": [
			"SetCollisionBoundsWS(${1:vec1}, ${2:vec2})$0"
		],
		"description": "Sets the collision bounds for the entity, which are used for triggers ( Entity:SetTrigger, ENTITY:Touch ), determining if rendering is necessary clientside, and collision ( If Entity:SetSolid set as Enums/SOLID ).\n\nInput bounds are in world coordinates!\nSee also Entity:SetCollisionBounds.",
		"prefix": "SetCollisionBoundsWS"
	},
	"Entity:SetCollisionGroup": {
		"body": [
			"SetCollisionGroup(${1:group})$0"
		],
		"description": "Sets the entity's collision group.",
		"prefix": "SetCollisionGroup"
	},
	"Entity:SetColor": {
		"body": [
			"SetColor(${1:color=Color(255, 0, 255, 255)})$0"
		],
		"description": "Sets the color of an entity.\n\nSome entities may need a custom [render mode](Enums/RENDERMODE) set for transparency to work. See example 2.\nEntities also must have a proper [render group](Enums/RENDERGROUP) set for transparency to work.",
		"prefix": "SetColor"
	},
	"Entity:SetCreator": {
		"body": [
			"SetCreator(${1:ply})$0"
		],
		"description": "Sets the creator of the Entity. This is set automatically in Sandbox gamemode when spawning SENTs, but is never used/read by default.",
		"prefix": "SetCreator"
	},
	"Entity:SetCustomCollisionCheck": {
		"body": [
			"SetCustomCollisionCheck(${1:enable})$0"
		],
		"description": "Marks the entity to call GM:ShouldCollide. Not to be confused with Entity:EnableCustomCollisions.",
		"prefix": "SetCustomCollisionCheck"
	},
	"Entity:SetCycle": {
		"body": [
			"SetCycle(${1:value})$0"
		],
		"description": "Sets the progress of the current animation to a specific value between 0 and 1.\n\nThis does not work with viewmodels.",
		"prefix": "SetCycle"
	},
	"Entity:SetDTAngle": {
		"body": [
			"SetDTAngle(${1:key}, ${2:ang})$0"
		],
		"description": "\nThis is called internally by the Entity:NetworkVar system, you can use this in cases where using NetworkVar is not possible.\n\nSets the specified angle on the entity's datatable.",
		"prefix": "SetDTAngle"
	},
	"Entity:SetDTBool": {
		"body": [
			"SetDTBool(${1:key}, ${2:bool})$0"
		],
		"description": "\nThis is called internally by the Entity:NetworkVar system, you can use this in cases where using NetworkVar is not possible.\n\nSets the specified bool on the entity's datatable.",
		"prefix": "SetDTBool"
	},
	"Entity:SetDTEntity": {
		"body": [
			"SetDTEntity(${1:key}, ${2:ent})$0"
		],
		"description": "\nThis is called internally by the Entity:NetworkVar system, you can use this in cases where using NetworkVar is not possible.\n\nSets the specified entity on this entity's datatable.",
		"prefix": "SetDTEntity"
	},
	"Entity:SetDTFloat": {
		"body": [
			"SetDTFloat(${1:key}, ${2:float})$0"
		],
		"description": "\nThis is called internally by the Entity:NetworkVar system, you can use this in cases where using NetworkVar is not possible.\n\nSets the specified float on the entity's datatable.",
		"prefix": "SetDTFloat"
	},
	"Entity:SetDTInt": {
		"body": [
			"SetDTInt(${1:key}, ${2:integer})$0"
		],
		"description": "\nThis is called internally by the Entity:NetworkVar system, you can use this in cases where using NetworkVar is not possible.\n\nSets the specified integer on the entity's datatable.",
		"prefix": "SetDTInt"
	},
	"Entity:SetDTString": {
		"body": [
			"SetDTString(${1:key}, ${2:str})$0"
		],
		"description": "\nThis is called internally by the Entity:NetworkVar system, you can use this in cases where using NetworkVar is not possible.\n\nSets the specified string on the entity's datatable.\n\nThe length of these strings are capped at 512 characters.",
		"prefix": "SetDTString"
	},
	"Entity:SetDTVector": {
		"body": [
			"SetDTVector(${1:key}, ${2:vec})$0"
		],
		"description": "\nThis is called internally by the Entity:NetworkVar system, you can use this in cases where using NetworkVar is not possible.\n\nSets the specified vector on the entity's datatable.",
		"prefix": "SetDTVector"
	},
	"Entity:SetElasticity": {
		"body": [
			"SetElasticity(${1:elasticity})$0"
		],
		"description": "Sets the elasticity of this entity, used by some flying entities such as the Helicopter NPC to determine how much it should bounce around when colliding.",
		"prefix": "SetElasticity"
	},
	"Entity:SetEntity": {
		"body": [
			"SetEntity(${1:name}, ${2:entity})$0"
		],
		"description": "Allows you to set the Start or End entity attachment for the rope.",
		"prefix": "SetEntity"
	},
	"Entity:SetEyeTarget": {
		"body": [
			"SetEyeTarget(${1:pos})$0"
		],
		"description": "Sets the position an entity's eyes look toward.",
		"prefix": "SetEyeTarget"
	},
	"Entity:SetFlexScale": {
		"body": [
			"SetFlexScale(${1:scale})$0"
		],
		"description": "Sets the flex scale of the entity.\n\nThis does not work on Global.ClientsideModels or Global.ClientsideRagdolls.",
		"prefix": "SetFlexScale"
	},
	"Entity:SetFlexWeight": {
		"body": [
			"SetFlexWeight(${1:flex}, ${2:weight})$0"
		],
		"description": "Sets the flex weight.",
		"prefix": "SetFlexWeight"
	},
	"Entity:SetFriction": {
		"body": [
			"SetFriction(${1:friction})$0"
		],
		"description": "Sets how much friction an entity has when sliding against a surface. Entities default to 1 (100%) and can be higher or even negative.\nThis only multiplies the friction of the entity, to change the value itself use PhysObj:SetMaterial.\n\nWorks only for MOVETYPE_STEP entities.\n\nThis has no effect on players.",
		"prefix": "SetFriction"
	},
	"Entity:SetGravity": {
		"body": [
			"SetGravity(${1:gravityMultiplier})$0"
		],
		"description": "Sets the gravity multiplier of the entity.\n\nThis function is not predicted.",
		"prefix": "SetGravity"
	},
	"Entity:SetGroundEntity": {
		"body": [
			"SetGroundEntity(${1:ground})$0"
		],
		"description": "Sets the ground the entity is standing on.",
		"prefix": "SetGroundEntity"
	},
	"Entity:SetHealth": {
		"body": [
			"SetHealth(${1:newHealth})$0"
		],
		"description": "Sets the health of the entity.\n\nYou may want to take Entity:GetMaxHealth into account when calculating what to set health to, in case a gamemode has a different max health than 100.",
		"prefix": "SetHealth"
	},
	"Entity:SetHitboxSet": {
		"body": [
			"SetHitboxSet(${1:id})$0"
		],
		"description": "Sets the current Hitbox set for the entity.",
		"prefix": "SetHitboxSet"
	},
	"Entity:SetIK": {
		"body": [
			"SetIK(${1:useIK=false})$0"
		],
		"description": "Enables or disable the inverse kinematic usage of this entity.",
		"prefix": "SetIK"
	},
	"Entity:SetKeyValue": {
		"body": [
			"SetKeyValue(${1:key}, ${2:value})$0"
		],
		"description": "Sets Hammer key values on an entity.\n\nYou can look up which entities have what key values on the [Valve Developer Community](https://developer.valvesoftware.com/wiki/) on entity pages.\n\n\nA  list of basic entities can be found [here](https://developer.valvesoftware.com/wiki/List_of_entities).\n\nAlternatively you can look at the .fgd files shipped with Garry's Mod in the bin/ folder with a text editor to see the key values as they appear in Hammer.",
		"prefix": "SetKeyValue"
	},
	"Entity:SetLOD": {
		"body": [
			"SetLOD(${1:lod=-1})$0"
		],
		"description": "Sets the Level Of Detail model to use with this entity. This may not work for all models if the model doesn't include any LOD sub models.\n\nThis function works exactly like the clientside r_lod convar and takes priority over it.",
		"prefix": "SetLOD"
	},
	"Entity:SetLagCompensated": {
		"body": [
			"SetLagCompensated(${1:enable})$0"
		],
		"description": "This allows the entity to be lag compensated during Player:LagCompensation.\n\nPlayers are lag compensated by default and there's no need to call this function for them.\n\nIt's best to not enable lag compensation on parented entities, as the system does not handle it that well ( they will be moved back but then the entity will lag behind ).\nParented entities move back with the parent if it's lag compensated, so if you are making some kind of armor piece you shouldn't do anything.\n\nAs a side note for parented entities, if your entity can be shot at, keep in mind that its collision bounds need to be bigger than the bone's hitbox the entity is parented to, or hull/line traces ( such as the crowbar attack or bullets ) might not hit at all.",
		"prefix": "SetLagCompensated"
	},
	"Entity:SetLayerBlendIn": {
		"body": [
			"SetLayerBlendIn(${1:layerID}, ${2:blendIn})$0"
		],
		"description": "This function only works on BaseAnimatingOverlay entites!",
		"prefix": "SetLayerBlendIn"
	},
	"Entity:SetLayerBlendOut": {
		"body": [
			"SetLayerBlendOut(${1:layerID}, ${2:blendOut})$0"
		],
		"description": "This function only works on BaseAnimatingOverlay entites!",
		"prefix": "SetLayerBlendOut"
	},
	"Entity:SetLayerCycle": {
		"body": [
			"SetLayerCycle(${1:layerID}, ${2:cycle})$0"
		],
		"description": "Sets the animation cycle/frame of given layer.\n\nThis function only works on BaseAnimatingOverlay entities.",
		"prefix": "SetLayerCycle"
	},
	"Entity:SetLayerDuration": {
		"body": [
			"SetLayerDuration(${1:layerID}, ${2:duration})$0"
		],
		"description": "Sets the duration of given layer. This internally overrides the Entity:SetLayerPlaybackRate.\n\nThis function only works on BaseAnimatingOverlay entities.",
		"prefix": "SetLayerDuration"
	},
	"Entity:SetLayerLooping": {
		"body": [
			"SetLayerLooping(${1:layerID}, ${2:loop})$0"
		],
		"description": "Sets whether the layer should loop or not.\n\nThis function only works on BaseAnimatingOverlay entites!",
		"prefix": "SetLayerLooping"
	},
	"Entity:SetLayerPlaybackRate": {
		"body": [
			"SetLayerPlaybackRate(${1:layerID}, ${2:rate})$0"
		],
		"description": "Sets the layer playback rate. See also Entity:SetLayerDuration.\n\nThis function only works on BaseAnimatingOverlay entities.",
		"prefix": "SetLayerPlaybackRate"
	},
	"Entity:SetLayerPriority": {
		"body": [
			"SetLayerPriority(${1:layerID}, ${2:priority})$0"
		],
		"description": "Sets the priority of given layer.\n\nThis function only works on BaseAnimatingOverlay entites!",
		"prefix": "SetLayerPriority"
	},
	"Entity:SetLayerSequence": {
		"body": [
			"SetLayerSequence(${1:layerID}, ${2:seq})$0"
		],
		"description": "Sets the sequence of given layer.\n\nThis function only works on BaseAnimatingOverlay entities.",
		"prefix": "SetLayerSequence"
	},
	"Entity:SetLayerWeight": {
		"body": [
			"SetLayerWeight(${1:layerID}, ${2:weight})$0"
		],
		"description": "Sets the layer weight. This influences how strongly the animation should be overriding the normal animations of the entity.\n\nThis function only works on BaseAnimatingOverlay entities.",
		"prefix": "SetLayerWeight"
	},
	"Entity:SetLegacyTransform": {
		"body": [
			"SetLegacyTransform(${1:enabled})$0"
		],
		"description": "This forces an entity to use the bone transformation behaviour from versions prior to **8 July 2014**.\n\nThis behaviour affects Entity:EnableMatrix and Entity:SetModelScale and is incorrect, therefore this function be used exclusively as a quick fix for old scripts that rely on it.",
		"prefix": "SetLegacyTransform"
	},
	"Entity:SetLightingOriginEntity": {
		"body": [
			"SetLightingOriginEntity(${1:lightOrigin})$0"
		],
		"description": "Sets the entity to be used as the light origin position for this entity.",
		"prefix": "SetLightingOriginEntity"
	},
	"Entity:SetLocalAngles": {
		"body": [
			"SetLocalAngles(${1:ang})$0"
		],
		"description": "Sets angles relative to angles of Entity:GetParent",
		"prefix": "SetLocalAngles"
	},
	"Entity:SetLocalAngularVelocity": {
		"body": [
			"SetLocalAngularVelocity(${1:angVel})$0"
		],
		"description": "Sets the entity's angular velocity (rotation speed).",
		"prefix": "SetLocalAngularVelocity"
	},
	"Entity:SetLocalPos": {
		"body": [
			"SetLocalPos(${1:pos})$0"
		],
		"description": "Sets local position relative to the parented position. This is for use with Entity:SetParent to offset position.",
		"prefix": "SetLocalPos"
	},
	"Entity:SetLocalVelocity": {
		"body": [
			"SetLocalVelocity(${1:velocity})$0"
		],
		"description": "Sets the entity's local velocity which is their velocity due to movement in the world from forces such as gravity. Does not include velocity from entity-on-entity collision or other world movement.\n\nSame as Entity:SetAbsVelocity, but clamps the given velocity, and is not recommended to be used because of that.",
		"prefix": "SetLocalVelocity"
	},
	"Entity:SetMaterial": {
		"body": [
			"SetMaterial(${1:materialName})$0"
		],
		"description": "Sets the rendering material override of the entity.\n\nTo set a Lua material created with Global.CreateMaterial, just prepend a \"!\" to the material name.\n\nIf you wish to override a single material on the model, use Entity:SetSubMaterial instead.\n\nTo apply materials to models, that material **must** have **VertexLitGeneric** shader. For that reason you cannot apply map textures onto models, map textures use a different material shader - **LightmappedGeneric**, which can be used on brush entities.\n\nThe server's value takes priority on the client.",
		"prefix": "SetMaterial"
	},
	"Entity:SetMaxHealth": {
		"body": [
			"SetMaxHealth(${1:maxhealth})$0"
		],
		"description": "Sets the maximum health for entity. Note, that you can still set entity's health above this amount with Entity:SetHealth.",
		"prefix": "SetMaxHealth"
	},
	"Entity:SetModel": {
		"body": [
			"SetModel(${1:modelName})$0"
		],
		"description": "Sets the model of the entity.\n\nThis does not update the physics of the entity - see Entity:PhysicsInit.\n\nThis silently fails when given an empty string.",
		"prefix": "SetModel"
	},
	"Entity:SetModelName": {
		"body": [
			"SetModelName(${1:modelname})$0"
		],
		"description": "Alter the model name returned by Entity:GetModel. Does not affect the entity's actual model.",
		"prefix": "SetModelName"
	},
	"Entity:SetModelScale": {
		"body": [
			"SetModelScale(${1:scale}, ${2:deltaTime=0})$0"
		],
		"description": "Scales the model of the entity, if the entity is a Player or an NPC the hitboxes will be scaled as well.\n\nFor some entities, calling Entity:Activate after this will scale the collision bounds and PhysObj as well; be wary as there's no optimization being done internally and highly complex collision models might crash the server.\n\nThis is the same system used in TF2 for the Mann Vs Machine robots.\n\nTo resize the entity along any axis, use Entity:EnableMatrix instead.\n\nIf your old scales are wrong, use Entity:SetLegacyTransform as a quick fix.\n\nIf you do not want the physics to be affected by Entity:Activate, you can use Entity:ManipulateBoneScale`( 0, Vector( scale, scale, scale ) )` instead.\n\nThis does not scale procedural bones and disables IK.",
		"prefix": "SetModelScale"
	},
	"Entity:SetMoveCollide": {
		"body": [
			"SetMoveCollide(${1:moveCollideType})$0"
		],
		"description": "Sets the move collide type of the entity. The move collide is the way a physics object reacts to hitting an object - will it bounce, slide?",
		"prefix": "SetMoveCollide"
	},
	"Entity:SetMoveParent": {
		"body": [
			"SetMoveParent(${1:Parent})$0"
		],
		"description": "Sets the Movement Parent of an entity to another entity.\n\nSimilar to Entity:SetParent, except the object's coordinates are not translated automatically before parenting.",
		"prefix": "SetMoveParent"
	},
	"Entity:SetMoveType": {
		"body": [
			"SetMoveType(${1:movetype})$0"
		],
		"description": "Sets the entity's move type. This should be called before initializing the physics object on the entity, unless it will override SetMoveType such as Entity:PhysicsInitBox.\n\nDespite existing on client, it doesn't actually do anything on client.",
		"prefix": "SetMoveType"
	},
	"Entity:SetNWAngle": {
		"body": [
			"SetNWAngle(${1:key}, ${2:value})$0"
		],
		"description": "Sets a networked angle value on the entity.\n\nThe value can then be accessed with Entity:GetNWAngle both from client and server.\n\nRunning this function clientside will only set it for the client it is called on.",
		"prefix": "SetNWAngle"
	},
	"Entity:SetNWBool": {
		"body": [
			"SetNWBool(${1:key}, ${2:value})$0"
		],
		"description": "Sets a networked boolean value on the entity.\n\nThe value can then be accessed with Entity:GetNWBool both from client and server.\n\nRunning this function clientside will only set it for the client it is called on.",
		"prefix": "SetNWBool"
	},
	"Entity:SetNWEntity": {
		"body": [
			"SetNWEntity(${1:key}, ${2:value})$0"
		],
		"description": "Sets a networked entity value on the entity.\n\nThe value can then be accessed with Entity:GetNWEntity both from client and server.\n\nRunning this function clientside will only set it for the client it is called on.",
		"prefix": "SetNWEntity"
	},
	"Entity:SetNWFloat": {
		"body": [
			"SetNWFloat(${1:key}, ${2:value})$0"
		],
		"description": "Sets a networked float (number) value on the entity.\n\nThe value can then be accessed with Entity:GetNWFloat both from client and server.\n\nUnlike Entity:SetNWInt, floats don't have to be whole numbers.\n\nRunning this function clientside will only set it for the client it is called on.",
		"prefix": "SetNWFloat"
	},
	"Entity:SetNWInt": {
		"body": [
			"SetNWInt(${1:key}, ${2:value})$0"
		],
		"description": "Sets a networked integer (whole number) value on the entity.\n\nThe value can then be accessed with Entity:GetNWInt both from client and server.\n\nSee Entity:SetNWFloat for numbers that aren't integers.\n\nRunning this function clientside will only set it for the client it is called on.\nThis function will not round decimal values as it actually networks a float internally.",
		"prefix": "SetNWInt"
	},
	"Entity:SetNWString": {
		"body": [
			"SetNWString(${1:key}, ${2:value})$0"
		],
		"description": "Sets a networked string value on the entity.\n\nThe value can then be accessed with Entity:GetNWString both from client and server.\n\nRunning this function clientside will only set it for the client it is called on.",
		"prefix": "SetNWString"
	},
	"Entity:SetNWVarProxy": {
		"body": [
			"SetNWVarProxy(${1:key}, ${2:callback})$0"
		],
		"description": "Sets a function to be called when the NWVar changes.",
		"prefix": "SetNWVarProxy"
	},
	"Entity:SetNWVector": {
		"body": [
			"SetNWVector(${1:key}, ${2:value})$0"
		],
		"description": "Sets a networked vector value on the entity.\n\nThe value can then be accessed with Entity:GetNWVector both from client and server.\n\nRunning this function clientside will only set it for the client it is called on.",
		"prefix": "SetNWVector"
	},
	"Entity:SetName": {
		"body": [
			"SetName(${1:mappingName})$0"
		],
		"description": "Sets the mapping name of the entity.",
		"prefix": "SetName"
	},
	"Entity:SetNetworkAngles": {
		"body": [
			"SetNetworkAngles(${1:angle})$0"
		],
		"description": "Alters the entity's perceived serverside angle on the client.",
		"prefix": "SetNetworkAngles"
	},
	"Entity:SetNetworkOrigin": {
		"body": [
			"SetNetworkOrigin(${1:origin})$0"
		],
		"description": "Virtually changes entity position for clients. Does the same thing as Entity:SetPos when used serverside.",
		"prefix": "SetNetworkOrigin"
	},
	"Entity:SetNetworkedAngle": {
		"body": [
			"SetNetworkedAngle(${1:key}, ${2:value=Angle( 0, 0, 0 )})$0"
		],
		"description": "You should use Entity:SetNWAngle instead.\n\nSets a networked angle value at specified index on the entity.\n\nThe value then can be accessed with Entity:GetNetworkedAngle both from client and server.\n\nRunning this function clientside will only set it clientside for the client it is called on.",
		"prefix": "SetNetworkedAngle"
	},
	"Entity:SetNetworkedBool": {
		"body": [
			"SetNetworkedBool(${1:key}, ${2:value=false})$0"
		],
		"description": "You should use Entity:SetNWBool instead.\n\nSets a networked boolean value at specified index on the entity.\n\nThe value then can be accessed with Entity:GetNetworkedBool both from client and server.\n\nRunning this function clientside will only set it clientside for the client it is called on.",
		"prefix": "SetNetworkedBool"
	},
	"Entity:SetNetworkedEntity": {
		"body": [
			"SetNetworkedEntity(${1:key}, ${2:value=NULL})$0"
		],
		"description": "You should use Entity:SetNWEntity instead.\n\nSets a networked entity value at specified index on the entity.\n\nThe value then can be accessed with Entity:GetNetworkedEntity both from client and server.\n\nRunning this function clientside will only set it clientside for the client it is called on.",
		"prefix": "SetNetworkedEntity"
	},
	"Entity:SetNetworkedFloat": {
		"body": [
			"SetNetworkedFloat(${1:key}, ${2:value=0})$0"
		],
		"description": "You should use Entity:SetNWFloat instead.\n\nSets a networked float value at specified index on the entity.\n\nThe value then can be accessed with Entity:GetNetworkedFloat both from client and server.\n\nSeems to be the same as Entity:GetNetworkedInt.\n\nRunning this function clientside will only set it clientside for the client it is called on.",
		"prefix": "SetNetworkedFloat"
	},
	"Entity:SetNetworkedInt": {
		"body": [
			"SetNetworkedInt(${1:key}, ${2:value=0})$0"
		],
		"description": "You should use Entity:SetNWInt instead.\n\nSets a networked integer value at specified index on the entity.\n\nThe value then can be accessed with Entity:GetNetworkedInt both from client and server.\n\nRunning this function clientside will only set it clientside for the client it is called on.",
		"prefix": "SetNetworkedInt"
	},
	"Entity:SetNetworkedNumber": {
		"body": [
			"SetNetworkedNumber(${1:index}, ${2:number})$0"
		],
		"description": "Sets a networked number at the specified index on the entity.",
		"prefix": "SetNetworkedNumber"
	},
	"Entity:SetNetworkedString": {
		"body": [
			"SetNetworkedString(${1:key}, ${2:value})$0"
		],
		"description": "You should use Entity:SetNWString instead.\n\nSets a networked string value at specified index on the entity.\n\nThe value then can be accessed with Entity:GetNetworkedString both from client and server.\n\nRunning this function clientside will only set it clientside for the client it is called on.",
		"prefix": "SetNetworkedString"
	},
	"Entity:SetNetworkedVarProxy": {
		"body": [
			"SetNetworkedVarProxy(${1:name}, ${2:callback})$0"
		],
		"description": "You should be using Entity:SetNWVarProxy instead.\nSets callback function to be called when given NWVar changes.",
		"prefix": "SetNetworkedVarProxy"
	},
	"Entity:SetNetworkedVector": {
		"body": [
			"SetNetworkedVector(${1:key}, ${2:value=Vector( 0, 0, 0 )})$0"
		],
		"description": "You should use Entity:SetNWVector instead.\n\nSets a networked vector value at specified index on the entity.\n\nThe value then can be accessed with Entity:GetNetworkedVector both from client and server.\n\nRunning this function clientside will only set it clientside for the client it is called on.",
		"prefix": "SetNetworkedVector"
	},
	"Entity:SetNextClientThink": {
		"body": [
			"SetNextClientThink(${1:nextthink})$0"
		],
		"description": "Sets the next time the clientside ENTITY:Think is called.",
		"prefix": "SetNextClientThink"
	},
	"Entity:SetNoDraw": {
		"body": [
			"SetNoDraw(${1:shouldNotDraw})$0"
		],
		"description": "Sets if the entity's model should render at all.\n\nIf set on the server, this entity will no longer network to clients, and for all intents and purposes cease to exist clientside.",
		"prefix": "SetNoDraw"
	},
	"Entity:SetNotSolid": {
		"body": [
			"SetNotSolid(${1:IsNotSolid})$0"
		],
		"description": "Sets whether the entity is solid or not.",
		"prefix": "SetNotSolid"
	},
	"Entity:SetOwner": {
		"body": [
			"SetOwner(${1:owner=NULL})$0"
		],
		"description": "Sets the owner of this entity, disabling all physics interaction with it.\n\nThis function is generally used to disable physics interactions on projectiles being fired by their owner, but can also be used for normal ownership in case physics interactions are not involved at all. The Gravity gun will be able to pick up the entity even if the owner can't collide with it, the Physics gun however will not.",
		"prefix": "SetOwner"
	},
	"Entity:SetParent": {
		"body": [
			"SetParent(${1:parent=NULL}, ${2:attachmentId=-1})$0"
		],
		"description": "Sets the parent of this entity, making it move with its parent. This will make the child entity non solid, nothing can interact with them, including traces.\n\nThis does not work on game.GetWorld.\nThis can cause undefined physics behaviour when used on entities that don't support parenting. See the [Valve developer wiki](https://developer.valvesoftware.com/wiki/Entity_Hierarchy_(parenting)) for more information.",
		"prefix": "SetParent"
	},
	"Entity:SetParentPhysNum": {
		"body": [
			"SetParentPhysNum(${1:bone})$0"
		],
		"description": "Sets the parent of an entity to another entity with the given physics bone number. Similar to Entity:SetParent, except it is parented to a physbone. This function is useful mainly for ragdolls.\n\nDespite this function being available server side, it doesn't actually do anything server side.",
		"prefix": "SetParentPhysNum"
	},
	"Entity:SetPersistent": {
		"body": [
			"SetPersistent(${1:persist})$0"
		],
		"description": "Sets whether or not the given entity is persistent. A persistent entity will be saved on server shutdown and loaded back when the server starts up. Additionally, by default persistent entities cannot be grabbed with the physgun and tools cannot be used on them.\n\nIn sandbox, this can be set on an entity by opening the context menu, right clicking the entity, and choosing \"Make Persistent\".\n\nPersistence can only be enabled with the sbox_persist convar, which works as an identifier for the current set of persistent entities. An empty identifier (which is the default value) disables this feature.",
		"prefix": "SetPersistent"
	},
	"Entity:SetPhysConstraintObjects": {
		"body": [
			"SetPhysConstraintObjects(${1:Phys1}, ${2:Phys2})$0"
		],
		"description": "When called on a constraint entity, sets the two physics objects to be constrained.\n\nUsage is not recommended as the Constraint library provides easier ways to deal with constraints.",
		"prefix": "SetPhysConstraintObjects"
	},
	"Entity:SetPhysicsAttacker": {
		"body": [
			"SetPhysicsAttacker(${1:ent}, ${2:timeLimit=5})$0"
		],
		"description": "Sets the player who gets credit if this entity kills something with physics damage within the time limit.\n\nThis can only be called on props, \"anim\" type SENTs and vehicles.",
		"prefix": "SetPhysicsAttacker"
	},
	"Entity:SetPlaybackRate": {
		"body": [
			"SetPlaybackRate(${1:fSpeed})$0"
		],
		"description": "Allows you to set how fast an entity's animation will play, with 1.0 being the default speed.",
		"prefix": "SetPlaybackRate"
	},
	"Entity:SetPos": {
		"body": [
			"SetPos(${1:position})$0"
		],
		"description": "Moves the entity to the specified position.\n\nIf the new position doesn't take effect right away, you can use Entity:SetupBones to force it to do so. This issue is especially common when trying to render the same entity twice or more in a single frame at different positions.\n\nEntities with Entity:GetSolid of SOLID_BBOX will have their angles reset!\n\nThis will fail inside of predicted functions called during player movement processing. This includes WEAPON:PrimaryAttack and WEAPON:Think.\n\nSome entities, such as ragdolls, will appear unaffected by this function in the next frame. Consider PhysObj:SetPos if necessary.",
		"prefix": "SetPos"
	},
	"Entity:SetPoseParameter": {
		"body": [
			"SetPoseParameter(${1:poseName}, ${2:poseValue})$0"
		],
		"description": "Sets the specified pose parameter to the specified value.\n\nYou should call Entity:InvalidateBoneCache after calling this function.\n\nAvoid calling this in draw hooks, especially when animating things, as it might cause visual artifacts.",
		"prefix": "SetPoseParameter"
	},
	"Entity:SetPredictable": {
		"body": [
			"SetPredictable(${1:setPredictable})$0"
		],
		"description": "Sets whether an entity should be predictable or not.\nWhen an entity is set as predictable, its DT vars can be changed during predicted hooks. This is useful for entities which can be controlled by player input.\n\nAny datatable value that mismatches from the server will be overridden and a prediction error will be spewed.\n\nWeapons are predictable by default, and the drive system uses this function to make the controlled prop predictable as well.\n\nVisit  for a list of all predicted hooks, and the Prediction page.\nFor further technical information on the subject, visit [valve's wiki](https://developer.valvesoftware.com/wiki/Prediction).\n\nThis function resets the datatable variables everytime it's called, it should ideally be called when a player starts using the entity and when he stops\nEntities set as predictable with this function will be unmarked when the user lags and receives a full packet update, to handle such case visit GM:NotifyShouldTransmit",
		"prefix": "SetPredictable"
	},
	"Entity:SetPreventTransmit": {
		"body": [
			"SetPreventTransmit(${1:player}, ${2:stopTransmitting})$0"
		],
		"description": "Prevents the server from sending any further information about the entity to a player.\n\nYou must also call this function on a player's children if you would like to prevent transmission for players. See Entity:GetChildren.\n\nThis does not work for nextbots.\n\n\n\nWhen using this function, Entity:SetFlexScale will conflict with this function. Instead, consider using Entity:SetFlexScale on the client.",
		"prefix": "SetPreventTransmit"
	},
	"Entity:SetRagdollAng": {
		"body": [
			"SetRagdollAng(${1:boneid}, ${2:pos})$0"
		],
		"description": "Sets the bone angles. This is used alongside Kinect in Entity:SetRagdollBuildFunction, for more info see ragdoll_motion entity.",
		"prefix": "SetRagdollAng"
	},
	"Entity:SetRagdollBuildFunction": {
		"body": [
			"SetRagdollBuildFunction(${1:func})$0"
		],
		"description": "Sets the function to build the ragdoll. This is used alongside Kinect, for more info see ragdoll_motion entity.",
		"prefix": "SetRagdollBuildFunction"
	},
	"Entity:SetRagdollPos": {
		"body": [
			"SetRagdollPos(${1:boneid}, ${2:pos})$0"
		],
		"description": "Sets the bone position. This is used alongside Kinect in Entity:SetRagdollBuildFunction, for more info see ragdoll_motion entity.",
		"prefix": "SetRagdollPos"
	},
	"Entity:SetRenderAngles": {
		"body": [
			"SetRenderAngles(${1:newAngles})$0"
		],
		"description": "Sets the render angles of the Entity.",
		"prefix": "SetRenderAngles"
	},
	"Entity:SetRenderBounds": {
		"body": [
			"SetRenderBounds(${1:mins}, ${2:maxs}, ${3:add=Vector( 0, 0, 0 )})$0"
		],
		"description": "Sets the render bounds for the entity. For world space coordinates see Entity:SetRenderBoundsWS.",
		"prefix": "SetRenderBounds"
	},
	"Entity:SetRenderBoundsWS": {
		"body": [
			"SetRenderBoundsWS(${1:mins}, ${2:maxs}, ${3:add=Vector( 0, 0, 0 )})$0"
		],
		"description": "Sets the render bounds for the entity in world space coordinates. For relative coordinates see Entity:SetRenderBounds.",
		"prefix": "SetRenderBoundsWS"
	},
	"Entity:SetRenderClipPlane": {
		"body": [
			"SetRenderClipPlane(${1:planeNormal}, ${2:planePosition})$0"
		],
		"description": "Used to specify a plane, past which an object will be visually clipped.",
		"prefix": "SetRenderClipPlane"
	},
	"Entity:SetRenderClipPlaneEnabled": {
		"body": [
			"SetRenderClipPlaneEnabled(${1:enabled})$0"
		],
		"description": "Enables the use of clipping planes to \"cut\" objects.",
		"prefix": "SetRenderClipPlaneEnabled"
	},
	"Entity:SetRenderFX": {
		"body": [
			"SetRenderFX(${1:renderFX})$0"
		],
		"description": "Sets entity's render FX.",
		"prefix": "SetRenderFX"
	},
	"Entity:SetRenderMode": {
		"body": [
			"SetRenderMode(${1:renderMode})$0"
		],
		"description": "Sets the render mode of the entity.",
		"prefix": "SetRenderMode"
	},
	"Entity:SetRenderOrigin": {
		"body": [
			"SetRenderOrigin(${1:newOrigin})$0"
		],
		"description": "Set the origin in which the Entity will be drawn from.",
		"prefix": "SetRenderOrigin"
	},
	"Entity:SetSaveValue": {
		"body": [
			"SetSaveValue(${1:name}, ${2:value})$0"
		],
		"description": "Sets a save value for an entity. You can see a full list of an entity's save values by creating it and printing Entity:GetSaveTable().\n\nSee Entity:GetInternalVariable for the opposite of this function.\n\nThis does not type-check entity keys. Setting an entity key to a non-entity value will treat it as NULL.",
		"prefix": "SetSaveValue"
	},
	"Entity:SetSequence": {
		"body": [
			"SetSequence(${1:sequenceId})$0"
		],
		"description": "Sets the entity's model sequence.\n\nIf the specified sequence is already active, the animation will not be restarted. See Entity:ResetSequence for a function that restarts the animation even if it is already playing.\n\nIn some cases you want to run Entity:ResetSequenceInfo to make this function run.\n\nThis will not work properly if called directly after calling Entity:SetModel. Consider waiting until the next Tick.\n\nWill not work on players due to the animations being reset every frame by the base gamemode animation system. See GM:CalcMainActivity.\n\nFor custom scripted entities you will want to apply example from ENTITY:Think to make animations work.",
		"prefix": "SetSequence"
	},
	"Entity:SetShouldPlayPickupSound": {
		"body": [
			"SetShouldPlayPickupSound(${1:playsound=false})$0"
		],
		"description": "Sets whether or not the entity should make a physics contact sound when it's been picked up by a player.",
		"prefix": "SetShouldPlayPickupSound"
	},
	"Entity:SetShouldServerRagdoll": {
		"body": [
			"SetShouldServerRagdoll(${1:serverragdoll})$0"
		],
		"description": "Sets if entity should create a server ragdoll on death or a client one.\n\nPlayer ragdolls created with this enabled will have an owner set, see Entity:SetOwner for more information on what effects this has.\n\nThis is reset for players when they respawn (Entity:Spawn).",
		"prefix": "SetShouldServerRagdoll"
	},
	"Entity:SetSkin": {
		"body": [
			"SetSkin(${1:skinIndex})$0"
		],
		"description": "Sets the skin of the entity.",
		"prefix": "SetSkin"
	},
	"Entity:SetSolid": {
		"body": [
			"SetSolid(${1:solid_type})$0"
		],
		"description": "Sets the solidity of an entity.",
		"prefix": "SetSolid"
	},
	"Entity:SetSolidFlags": {
		"body": [
			"SetSolidFlags(${1:flags})$0"
		],
		"description": "Sets solid flag(s) for the entity.\n\nThis overrides any other flags the entity might have had. See Entity:AddSolidFlags for adding flags.",
		"prefix": "SetSolidFlags"
	},
	"Entity:SetSpawnEffect": {
		"body": [
			"SetSpawnEffect(${1:spawnEffect})$0"
		],
		"description": "Sets whether the entity should use a spawn effect when it is created on the client.\n\nSee Entity:GetSpawnEffect for more information on how the effect is applied.\n\nThis function will only have an effect when the entity spawns. After that it will do nothing even is set to true.",
		"prefix": "SetSpawnEffect"
	},
	"Entity:SetSubMaterial": {
		"body": [
			"SetSubMaterial(${1:index=nil}, ${2:material=nil})$0"
		],
		"description": "Overrides a single material on the model of this entity.\n\nTo set a Lua material created with Global.CreateMaterial, just prepend a \"!\" to the material name.\n\nThe server's value takes priority on the client.",
		"prefix": "SetSubMaterial"
	},
	"Entity:SetTable": {
		"body": [
			"SetTable(${1:tab})$0"
		],
		"description": "Changes the table that can be accessed by indexing an entity. Each entity starts with its own table by default.",
		"prefix": "SetTable"
	},
	"Entity:SetTransmitWithParent": {
		"body": [
			"SetTransmitWithParent(${1:onoff})$0"
		],
		"description": "When this flag is set the entity will only transmit to the player when its parent is transmitted. This is useful for things like viewmodel attachments since without this flag they will transmit to everyone (and cause the viewmodels to transmit to everyone too).\n\nIn the case of scripted entities, this will override ENTITY:UpdateTransmitState",
		"prefix": "SetTransmitWithParent"
	},
	"Entity:SetTrigger": {
		"body": [
			"SetTrigger(${1:maketrigger})$0"
		],
		"description": "Marks the entity as a trigger, so it will generate ENTITY:StartTouch, ENTITY:Touch and ENTITY:EndTouch callbacks.\n\nInternally this is stored as Enums/FSOLID flag.",
		"prefix": "SetTrigger"
	},
	"Entity:SetUnFreezable": {
		"body": [
			"SetUnFreezable(${1:freezable=false})$0"
		],
		"description": "Sets whether an entity can be unfrozen, meaning that it cannot be unfrozen using the physgun.",
		"prefix": "SetUnFreezable"
	},
	"Entity:SetUseType": {
		"body": [
			"SetUseType(${1:useType})$0"
		],
		"description": "Sets the use type of an entity, affecting how often ENTITY:Use will be called for Lua entities.",
		"prefix": "SetUseType"
	},
	"Entity:SetVar": {
		"body": [
			"SetVar(${1:key}, ${2:value})$0"
		],
		"description": "Allows to quickly set variable to entity's Entity:GetTable.\n\nThis will not network the variable to client(s). You want Entity:SetNWString and similar functions for that",
		"prefix": "SetVar"
	},
	"Entity:SetVelocity": {
		"body": [
			"SetVelocity(${1:velocity})$0"
		],
		"description": "Sets the entity's velocity. For entities with physics, consider using PhysObj:SetVelocity on the PhysObj of the entity.\n\nActually binds to CBaseEntity::SetBaseVelocity() which sets the entity's velocity due to forces applied by other entities.\n\nIf applied to a player, this will actually **ADD** velocity, not set it.",
		"prefix": "SetVelocity"
	},
	"Entity:SetWeaponModel": {
		"body": [
			"SetWeaponModel(${1:viewModel}, ${2:weapon=NULL})$0"
		],
		"description": "Sets the model and associated weapon to this viewmodel entity.\n\nThis is used internally when the player switches weapon.\n\nView models are not drawn without a weapons associated to them.\nThis will silently fail if the entity is not a viewmodel.",
		"prefix": "SetWeaponModel"
	},
	"Entity:SetupBones": {
		"body": [
			"SetupBones()$0"
		],
		"description": "Forces the entity to reconfigure its bones. You might need to call this after changing your model's scales or when manually drawing the entity multiple times at different positions.\n\nThis calls the BuildBonePositions callback added via Entity:AddCallback, so avoid calling this function inside it to prevent an infinite loop.",
		"prefix": "SetupBones"
	},
	"Entity:SetupPhonemeMappings": {
		"body": [
			"SetupPhonemeMappings(${1:fileRoot})$0"
		],
		"description": "Initializes the class names of an entity's phoneme mappings (mouth movement data). This is called by default with argument \"phonemes\" when a flex-based entity (such as an NPC) is created.\n\nTF2 phonemes can be accessed by using a path such as \"player/scout/phonemes/phonemes\" , check TF2's \"tf2_misc_dir.vpk\" with GCFScape for other paths, however it seems that TF2 sounds don't contain phoneme definitions anymore after being converted to mp3 and only rely on VCD animations, this needs to be further investigated",
		"prefix": "SetupPhonemeMappings"
	},
	"Entity:SkinCount": {
		"body": [
			"SkinCount()$0"
		],
		"description": "Returns the amount of skins the entity has.",
		"prefix": "SkinCount"
	},
	"Entity:SnatchModelInstance": {
		"body": [
			"SnatchModelInstance(${1:srcEntity})$0"
		],
		"description": "Moves the model instance from the source entity to this entity. This can be used to transfer decals that have been applied on one entity to another.\n\nBoth entities must have the same model.",
		"prefix": "SnatchModelInstance"
	},
	"Entity:Spawn": {
		"body": [
			"Spawn()$0"
		],
		"description": "Initializes the entity and starts its networking. If called on a player, it will respawn them.\n\nThis calls ENTITY:Initialize on Lua-defined entities.",
		"prefix": "Spawn"
	},
	"Entity:StartLoopingSound": {
		"body": [
			"StartLoopingSound(${1:sound})$0"
		],
		"description": "Starts a \"looping\" sound. As with any other sound playing methods, this function expects the sound file to be looping itself and will not automatically loop a non looping sound file as one might expect.\n\nThis function is almost identical to Global.CreateSound, with the exception of the sound being created in the STATIC channel and with normal attenuation.\n\nSee also Entity:StopLoopingSound",
		"prefix": "StartLoopingSound"
	},
	"Entity:StartMotionController": {
		"body": [
			"StartMotionController()$0"
		],
		"description": "Starts a motion controller in the physics engine tied to this entity's PhysObj, which enables the use of ENTITY:PhysicsSimulate.\n\nThe motion controller can later be destroyed via Entity:StopMotionController.\n\nMotion controllers are used internally to control other Entities' PhysObjects, such as the Gravity Gun, +use pickup and the Physics Gun.\n\nThis function should be called every time you recreate the Entity's PhysObj. Or alternatively you should call Entity:AddToMotionController on the new PhysObj.\n\nAlso see Entity:AddToMotionController and Entity:RemoveFromMotionController.\n\nOnly works on a scripted Entity of anim type.",
		"prefix": "StartMotionController"
	},
	"Entity:StopAndDestroyParticles": {
		"body": [
			"StopAndDestroyParticles()$0"
		],
		"description": "Stops all particle effects parented to the entity and immediately destroys them.",
		"prefix": "StopAndDestroyParticles"
	},
	"Entity:StopLoopingSound": {
		"body": [
			"StopLoopingSound(${1:id})$0"
		],
		"description": "Stops a sound created by Entity:StartLoopingSound.",
		"prefix": "StopLoopingSound"
	},
	"Entity:StopMotionController": {
		"body": [
			"StopMotionController()$0"
		],
		"description": "Stops the motion controller created with Entity:StartMotionController.",
		"prefix": "StopMotionController"
	},
	"Entity:StopParticleEmission": {
		"body": [
			"StopParticleEmission()$0"
		],
		"description": "Stops all particle effects parented to the entity.\n\nThis is ran automatically on every client by Entity:StopParticles if called on the server.",
		"prefix": "StopParticleEmission"
	},
	"Entity:StopParticles": {
		"body": [
			"StopParticles()$0"
		],
		"description": "Stops any attached to the entity .pcf particles using Global.ParticleEffectAttach.\n\nOn client, this is the same as Entity:StopParticleEmission. ( and you should use StopParticleEmission instead )\n\n\nOn server, this is the same as running Entity:StopParticleEmission on every client.",
		"prefix": "StopParticles"
	},
	"Entity:StopParticlesNamed": {
		"body": [
			"StopParticlesNamed(${1:name})$0"
		],
		"description": "Stops all particle effects parented to the entity with given name.",
		"prefix": "StopParticlesNamed"
	},
	"Entity:StopParticlesWithNameAndAttachment": {
		"body": [
			"StopParticlesWithNameAndAttachment(${1:name}, ${2:attachment})$0"
		],
		"description": "Stops all particle effects parented to the entity with given name on given attachment.",
		"prefix": "StopParticlesWithNameAndAttachment"
	},
	"Entity:StopSound": {
		"body": [
			"StopSound(${1:sound})$0"
		],
		"description": "Stops emitting the given sound from the entity, especially useful for looping sounds.",
		"prefix": "StopSound"
	},
	"Entity:TakeDamage": {
		"body": [
			"TakeDamage(${1:damageAmount}, ${2:attacker}, ${3:inflictor})$0"
		],
		"description": "Applies the specified amount of damage to the entity with Enums/DMG flag.\n\nCalling this function on the victim entity in ENTITY:OnTakeDamage can cause infinite loops.",
		"prefix": "TakeDamage"
	},
	"Entity:TakeDamageInfo": {
		"body": [
			"TakeDamageInfo(${1:damageInfo})$0"
		],
		"description": "Applies the damage specified by the damage info to the entity.\n\nCalling this function on the victim entity in ENTITY:OnTakeDamage can cause infinite loops.",
		"prefix": "TakeDamageInfo"
	},
	"Entity:TakePhysicsDamage": {
		"body": [
			"TakePhysicsDamage(${1:dmginfo})$0"
		],
		"description": "Applies forces to our physics object in response to damage.",
		"prefix": "TakePhysicsDamage"
	},
	"Entity:TestPVS": {
		"body": [
			"TestPVS(${1:testPoint})$0"
		],
		"description": "Check if the given position or entity is within this entity's PVS.\n\nSee also Entity:IsDormant.\n\nThe function won't take in to account Global.AddOriginToPVS and the like.",
		"prefix": "TestPVS"
	},
	"Entity:TranslateBoneToPhysBone": {
		"body": [
			"TranslateBoneToPhysBone(${1:boneID})$0"
		],
		"description": "Returns the ID of a PhysObj attached to the given bone. To be used with Entity:GetPhysicsObjectNum.\n\nSee Entity:TranslatePhysBoneToBone for reverse function.",
		"prefix": "TranslateBoneToPhysBone"
	},
	"Entity:TranslatePhysBoneToBone": {
		"body": [
			"TranslatePhysBoneToBone(${1:physNum})$0"
		],
		"description": "Returns the boneID of the bone the given PhysObj is attached to.\n\nSee Entity:TranslateBoneToPhysBone for reverse function.",
		"prefix": "TranslatePhysBoneToBone"
	},
	"Entity:Use": {
		"body": [
			"Use(${1:activator}, ${2:caller=NULL}, ${3:useType=USE_ON}, ${4:value=0})$0"
		],
		"description": "Simulates a `+use` action on an entity.",
		"prefix": "Use"
	},
	"Entity:UseClientSideAnimation": {
		"body": [
			"UseClientSideAnimation()$0"
		],
		"description": "Does nothing on server.\n\nAnimations will be handled purely clientside instead of a fixed animtime, enabling interpolation. This does not affect layers and gestures.",
		"prefix": "UseClientSideAnimation"
	},
	"Entity:UseTriggerBounds": {
		"body": [
			"UseTriggerBounds(${1:enable}, ${2:boundSize=0})$0"
		],
		"description": "Enables or disables trigger bounds.\n\nThis will give the entity a \"trigger box\" that extends around its bounding box by boundSize units in X/Y and (boundSize / 2) in +Z (-Z remains the same).\nThe trigger box is world aligned and will work regardless of the object's solidity and collision group.\n\nValve use trigger boxes for all pickup items. Their bloat size is 24, a surprisingly large figure.\n\nThe trigger boxes can be made visible as a light blue box by using the **ent_bbox** console command while looking at the entity. Alternatively a classname or entity index can be used as the first argument.\n\nThis requires **developer** to be set to **1**.",
		"prefix": "UseTriggerBounds"
	},
	"Entity:ViewModelIndex": {
		"body": [
			"ViewModelIndex()$0"
		],
		"description": "Returns the index of this view model, it can be used to identify which one of the player's view models this entity is.",
		"prefix": "ViewModelIndex"
	},
	"Entity:Visible": {
		"body": [
			"Visible(${1:target})$0"
		],
		"description": "Returns whether the target/given entity is visible from the this entity.\n\nThis is meant to be used only with NPCs.\n\nDifferences from a simple trace include:\n* If target has **FL_NOTARGET**, returns false\n* If **ai_ignoreplayers** is turned on and target is a player, returns false\n* Reacts to **ai_LOS_mode**:\n* * If 1, does a simple trace with **COLLISION_GROUP_NONE** and **MASK_BLOCKLOS**\n* * If not, does a trace with **MASK_BLOCKLOS_AND_NPCS** ( - **CONTENTS_BLOCKLOS** is target is player ) and a custom LOS filter ( **CTraceFilterLOS** )\n* Returns true if hits a vehicle the target is driving",
		"prefix": "Visible"
	},
	"Entity:VisibleVec": {
		"body": [
			"VisibleVec(${1:pos})$0"
		],
		"description": "Returns true if supplied vector is visible from the entity's line of sight.\n\nThis is achieved similarly to a trace.",
		"prefix": "VisibleVec"
	},
	"Entity:WaterLevel": {
		"body": [
			"WaterLevel()$0"
		],
		"description": "Returns an integer that represents how deep in water the entity is.\n\n\n* **0** - The entity isn't in water.\n\n* **1** - Slightly submerged (at least to the feet).\n\n* **2** - The majority of the entity is submerged (at least to the waist).\n\n* **3** - Completely submerged.",
		"prefix": "WaterLevel"
	},
	"Entity:Weapon_SetActivity": {
		"body": [
			"Weapon_SetActivity(${1:act}, ${2:duration})$0"
		],
		"description": "Sets the activity of the entity's active weapon.\n\nThis does nothing on the client.\nOnly works for CBaseCombatCharacter entities, which includes players and NPCs.",
		"prefix": "Weapon_SetActivity"
	},
	"Entity:Weapon_TranslateActivity": {
		"body": [
			"Weapon_TranslateActivity(${1:act})$0"
		],
		"description": "Calls and returns WEAPON:TranslateActivity on the weapon the entity ( player or NPC ) carries.\n\nDespite existing on client, it doesn't actually do anything on client.",
		"prefix": "Weapon_TranslateActivity"
	},
	"Entity:WorldSpaceAABB": {
		"body": [
			"WorldSpaceAABB()$0"
		],
		"description": "Returns two vectors representing the minimum and maximum extent of the entity's bounding box.",
		"prefix": "WorldSpaceAABB"
	},
	"Entity:WorldSpaceCenter": {
		"body": [
			"WorldSpaceCenter()$0"
		],
		"description": "Returns the center of the entity according to its collision model.",
		"prefix": "WorldSpaceCenter"
	},
	"Entity:WorldToLocal": {
		"body": [
			"WorldToLocal(${1:wpos})$0"
		],
		"description": "Converts a worldspace vector into a vector local to an entity",
		"prefix": "WorldToLocal"
	},
	"Entity:WorldToLocalAngles": {
		"body": [
			"WorldToLocalAngles(${1:ang})$0"
		],
		"description": "Converts world angles to local angles ( local to the entity )",
		"prefix": "WorldToLocalAngles"
	},
	"File:Close": {
		"body": [
			"Close()$0"
		],
		"description": "Dumps the file changes to disk and closes the file handle which makes the handle useless.",
		"prefix": "Close"
	},
	"File:EndOfFile": {
		"body": [
			"EndOfFile()$0"
		],
		"description": "Returns whether the File object has reached the end of file or not.",
		"prefix": "EndOfFile"
	},
	"File:Flush": {
		"body": [
			"Flush()$0"
		],
		"description": "Dumps the file changes to disk and saves the file.",
		"prefix": "Flush"
	},
	"File:Read": {
		"body": [
			"Read(${1:length})$0"
		],
		"description": "Reads the specified amount of chars and returns them as a binary string.",
		"prefix": "Read"
	},
	"File:ReadBool": {
		"body": [
			"ReadBool()$0"
		],
		"description": "Reads one byte of the file and returns whether that byte was not 0.",
		"prefix": "ReadBool"
	},
	"File:ReadByte": {
		"body": [
			"ReadByte()$0"
		],
		"description": "Reads one unsigned 8-bit integer from the file.",
		"prefix": "ReadByte"
	},
	"File:ReadDouble": {
		"body": [
			"ReadDouble()$0"
		],
		"description": "Reads 8 bytes from the file converts them to a double and returns them.",
		"prefix": "ReadDouble"
	},
	"File:ReadFloat": {
		"body": [
			"ReadFloat()$0"
		],
		"description": "Reads 4 bytes from the file converts them to a float and returns them.",
		"prefix": "ReadFloat"
	},
	"File:ReadLine": {
		"body": [
			"ReadLine()$0"
		],
		"description": "Returns the contents of the file from the current position up until the end of the current line.\n\nThis function will look specifically for `Line Feed` characters `\\n` and will **completely ignore `Carriage Return` characters** `\\r`.\nThis function will not return more than 8192 characters.",
		"prefix": "ReadLine"
	},
	"File:ReadLong": {
		"body": [
			"ReadLong()$0"
		],
		"description": "Reads a signed 32-bit integer from the file.",
		"prefix": "ReadLong"
	},
	"File:ReadShort": {
		"body": [
			"ReadShort()$0"
		],
		"description": "Reads a signed 16-bit integer from the file.",
		"prefix": "ReadShort"
	},
	"File:ReadULong": {
		"body": [
			"ReadULong()$0"
		],
		"description": "Reads a unsigned 32-bit integer from the file.",
		"prefix": "ReadULong"
	},
	"File:ReadUShort": {
		"body": [
			"ReadUShort()$0"
		],
		"description": "Reads a unsigned 16-bit integer from the file.",
		"prefix": "ReadUShort"
	},
	"File:Seek": {
		"body": [
			"Seek(${1:pos})$0"
		],
		"description": "Sets the file pointer to the specified position.",
		"prefix": "Seek"
	},
	"File:Size": {
		"body": [
			"Size()$0"
		],
		"description": "Returns the size of the file in bytes.",
		"prefix": "Size"
	},
	"File:Skip": {
		"body": [
			"Skip(${1:amount})$0"
		],
		"description": "Moves the file pointer by the specified amount of chars.",
		"prefix": "Skip"
	},
	"File:Tell": {
		"body": [
			"Tell()$0"
		],
		"description": "Returns the current position of the file pointer.",
		"prefix": "Tell"
	},
	"File:Write": {
		"body": [
			"Write(${1:data})$0"
		],
		"description": "Writes the given string into the file.",
		"prefix": "Write"
	},
	"File:WriteBool": {
		"body": [
			"WriteBool(${1:bool})$0"
		],
		"description": "Writes a boolean value to the file as one **byte**.",
		"prefix": "WriteBool"
	},
	"File:WriteByte": {
		"body": [
			"WriteByte(${1:uint8})$0"
		],
		"description": "Write an 8-bit unsigned integer to the file.",
		"prefix": "WriteByte"
	},
	"File:WriteDouble": {
		"body": [
			"WriteDouble(${1:double})$0"
		],
		"description": "Writes a 8byte floating point double to the file.",
		"prefix": "WriteDouble"
	},
	"File:WriteFloat": {
		"body": [
			"WriteFloat(${1:float})$0"
		],
		"description": "Writes a 4byte float to the file.",
		"prefix": "WriteFloat"
	},
	"File:WriteLong": {
		"body": [
			"WriteLong(${1:int32})$0"
		],
		"description": "Writes a 32-bit signed integer to the file.",
		"prefix": "WriteLong"
	},
	"File:WriteShort": {
		"body": [
			"WriteShort(${1:int16})$0"
		],
		"description": "Writes a 16-bit signed integer to the file.",
		"prefix": "WriteShort"
	},
	"File:WriteULong": {
		"body": [
			"WriteULong(${1:uint32})$0"
		],
		"description": "Writes an unsigned 32-bit integer to the file.",
		"prefix": "WriteULong"
	},
	"File:WriteUShort": {
		"body": [
			"WriteUShort(${1:uint16})$0"
		],
		"description": "Writes an unsigned 16-bit integer to the file.",
		"prefix": "WriteUShort"
	},
	"IGModAudioChannel:EnableLooping": {
		"body": [
			"EnableLooping(${1:enable})$0"
		],
		"description": "Enables or disables looping of audio channel, requires noblock flag.",
		"prefix": "EnableLooping"
	},
	"IGModAudioChannel:FFT": {
		"body": [
			"FFT(${1:tbl}, ${2:size})$0"
		],
		"description": "Computes the [DFT (discrete Fourier transform)](https://en.wikipedia.org/wiki/Discrete_Fourier_transform) of the sound channel.\n\nThe size parameter specifies the number of consecutive audio samples to use as the input to the DFT and is restricted to a power of two. A [Hann window](https://en.wikipedia.org/wiki/Hann_function) is applied to the input data.\n\nThe computed DFT has the same number of frequency bins as the number of samples. Only half of this DFT is returned, since [the DFT magnitudes are symmetric for real input data](https://en.wikipedia.org/wiki/Discrete_Fourier_transform#The_real-input_DFT). The magnitudes of the DFT (values from 0 to 1) are used to fill the output table, starting at index 1.\n\n**Visualization protip:** For a size N DFT, bin k (1-indexed) corresponds to a frequency of (k - 1) / N * sampleRate.\n\n**Visualization protip:** Sound energy is proportional to the square of the magnitudes. Adding magnitudes together makes no sense physically, but adding energies does.\n\n**Visualization protip:** The human ear works on a logarithmic amplitude scale. You can convert to [decibels](https://en.wikipedia.org/wiki/Decibel) by taking 20 * math.log10 of frequency magnitudes, or 10 * math.log10 of energy. The decibel values will range from -infinity to 0.",
		"prefix": "FFT"
	},
	"IGModAudioChannel:Get3DCone": {
		"body": [
			"Get3DCone()$0"
		],
		"description": "Returns 3D cone of the sound channel. See IGModAudioChannel:Set3DCone.",
		"prefix": "Get3DCone"
	},
	"IGModAudioChannel:Get3DEnabled": {
		"body": [
			"Get3DEnabled()$0"
		],
		"description": "Returns if the sound channel is currently in 3D mode or not. This value will be affected by IGModAudioChannel:Set3DEnabled.",
		"prefix": "Get3DEnabled"
	},
	"IGModAudioChannel:Get3DFadeDistance": {
		"body": [
			"Get3DFadeDistance()$0"
		],
		"description": "Returns 3D fade distances of a sound channel.",
		"prefix": "Get3DFadeDistance"
	},
	"IGModAudioChannel:GetAverageBitRate": {
		"body": [
			"GetAverageBitRate()$0"
		],
		"description": "Returns the average bit rate of the sound channel.",
		"prefix": "GetAverageBitRate"
	},
	"IGModAudioChannel:GetBitsPerSample": {
		"body": [
			"GetBitsPerSample()$0"
		],
		"description": "Retrieves the number of bits per sample of the sound channel.\n\nDoesn't work for mp3 and ogg files.",
		"prefix": "GetBitsPerSample"
	},
	"IGModAudioChannel:GetFileName": {
		"body": [
			"GetFileName()$0"
		],
		"description": "Returns the filename for the sound channel.",
		"prefix": "GetFileName"
	},
	"IGModAudioChannel:GetLength": {
		"body": [
			"GetLength()$0"
		],
		"description": "Returns the length of sound played by the sound channel.",
		"prefix": "GetLength"
	},
	"IGModAudioChannel:GetLevel": {
		"body": [
			"GetLevel()$0"
		],
		"description": "Returns the right and left levels of sound played by the sound channel.",
		"prefix": "GetLevel"
	},
	"IGModAudioChannel:GetPan": {
		"body": [
			"GetPan()$0"
		],
		"description": "Gets the relative volume of the left and right channels.",
		"prefix": "GetPan"
	},
	"IGModAudioChannel:GetPlaybackRate": {
		"body": [
			"GetPlaybackRate()$0"
		],
		"description": "Returns the playback rate of the sound channel.",
		"prefix": "GetPlaybackRate"
	},
	"IGModAudioChannel:GetPos": {
		"body": [
			"GetPos()$0"
		],
		"description": "Returns position of the sound channel",
		"prefix": "GetPos"
	},
	"IGModAudioChannel:GetSamplingRate": {
		"body": [
			"GetSamplingRate()$0"
		],
		"description": "Returns the sample rate for currently playing sound.",
		"prefix": "GetSamplingRate"
	},
	"IGModAudioChannel:GetState": {
		"body": [
			"GetState()$0"
		],
		"description": "Returns the state of a sound channel",
		"prefix": "GetState"
	},
	"IGModAudioChannel:GetTagsHTTP": {
		"body": [
			"GetTagsHTTP()$0"
		],
		"description": "Retrieves HTTP headers from a bass stream channel created by sound.PlayURL, if available.",
		"prefix": "GetTagsHTTP"
	},
	"IGModAudioChannel:GetTagsID3": {
		"body": [
			"GetTagsID3()$0"
		],
		"description": "Retrieves the ID3 version 1 info from a bass channel created by sound.PlayFile or sound.PlayURL, if available.\n\nID3v2 is not supported.",
		"prefix": "GetTagsID3"
	},
	"IGModAudioChannel:GetTagsMeta": {
		"body": [
			"GetTagsMeta()$0"
		],
		"description": "Retrieves meta stream info from a bass stream channel created by sound.PlayURL, if available.",
		"prefix": "GetTagsMeta"
	},
	"IGModAudioChannel:GetTagsOGG": {
		"body": [
			"GetTagsOGG()$0"
		],
		"description": "Retrieves OGG media info tag, from a bass channel created by sound.PlayURL or sound.PlayFile, if available.",
		"prefix": "GetTagsOGG"
	},
	"IGModAudioChannel:GetTagsVendor": {
		"body": [
			"GetTagsVendor()$0"
		],
		"description": "Retrieves OGG Vendor tag, usually containing the application that created the file, from a bass channel created by sound.PlayURL or sound.PlayFile, if available.",
		"prefix": "GetTagsVendor"
	},
	"IGModAudioChannel:GetTime": {
		"body": [
			"GetTime()$0"
		],
		"description": "Returns the current time of the sound channel",
		"prefix": "GetTime"
	},
	"IGModAudioChannel:GetVolume": {
		"body": [
			"GetVolume()$0"
		],
		"description": "Returns volume of a sound channel",
		"prefix": "GetVolume"
	},
	"IGModAudioChannel:Is3D": {
		"body": [
			"Is3D()$0"
		],
		"description": "Returns if the sound channel is in 3D mode or not.",
		"prefix": "Is3D"
	},
	"IGModAudioChannel:IsBlockStreamed": {
		"body": [
			"IsBlockStreamed()$0"
		],
		"description": "Returns whether the audio stream is block streamed or not.",
		"prefix": "IsBlockStreamed"
	},
	"IGModAudioChannel:IsLooping": {
		"body": [
			"IsLooping()$0"
		],
		"description": "Returns if the sound channel is looping or not.",
		"prefix": "IsLooping"
	},
	"IGModAudioChannel:IsOnline": {
		"body": [
			"IsOnline()$0"
		],
		"description": "Returns if the sound channel is streamed from the Internet or not.",
		"prefix": "IsOnline"
	},
	"IGModAudioChannel:IsValid": {
		"body": [
			"IsValid()$0"
		],
		"description": "Returns if the sound channel is valid or not.",
		"prefix": "IsValid"
	},
	"IGModAudioChannel:Pause": {
		"body": [
			"Pause()$0"
		],
		"description": "Pauses the stream. It can be started again using IGModAudioChannel:Play",
		"prefix": "Pause"
	},
	"IGModAudioChannel:Play": {
		"body": [
			"Play()$0"
		],
		"description": "Starts playing the stream.",
		"prefix": "Play"
	},
	"IGModAudioChannel:Set3DCone": {
		"body": [
			"Set3DCone(${1:innerAngle}, ${2:outerAngle}, ${3:outerVolume})$0"
		],
		"description": "Sets 3D cone of the sound channel.",
		"prefix": "Set3DCone"
	},
	"IGModAudioChannel:Set3DEnabled": {
		"body": [
			"Set3DEnabled(${1:enable})$0"
		],
		"description": "Sets the 3D mode of the channel. This will affect IGModAudioChannel:Get3DEnabled but not IGModAudioChannel:Is3D.\n\nThis feature **requires** the channel to be initially created in 3D mode, i.e. IGModAudioChannel:Is3D should return true or this function will do nothing.",
		"prefix": "Set3DEnabled"
	},
	"IGModAudioChannel:Set3DFadeDistance": {
		"body": [
			"Set3DFadeDistance(${1:min}, ${2:max})$0"
		],
		"description": "Sets 3D fade distances of a sound channel.",
		"prefix": "Set3DFadeDistance"
	},
	"IGModAudioChannel:SetPan": {
		"body": [
			"SetPan(${1:pan})$0"
		],
		"description": "Sets the relative volume of the left and right channels.",
		"prefix": "SetPan"
	},
	"IGModAudioChannel:SetPlaybackRate": {
		"body": [
			"SetPlaybackRate(${1:rate})$0"
		],
		"description": "Sets the playback rate of the sound channel. May not work with high values for radio streams.",
		"prefix": "SetPlaybackRate"
	},
	"IGModAudioChannel:SetPos": {
		"body": [
			"SetPos(${1:pos}, ${2:dir=Vector( 0, 0, 0 )})$0"
		],
		"description": "Sets position of sound channel in case the sound channel has a 3d option set.",
		"prefix": "SetPos"
	},
	"IGModAudioChannel:SetTime": {
		"body": [
			"SetTime(${1:secs})$0"
		],
		"description": "Sets the sound channel to specified time ( Rewind to that position of the song ). Does not work on online radio streams.\n\nStreamed sounds must have \"noblock\" parameter for this to work and IGModAudioChannel:IsBlockStreamed must return false.",
		"prefix": "SetTime"
	},
	"IGModAudioChannel:SetVolume": {
		"body": [
			"SetVolume(${1:volume})$0"
		],
		"description": "Sets the volume of a sound channel",
		"prefix": "SetVolume"
	},
	"IGModAudioChannel:Stop": {
		"body": [
			"Stop()$0"
		],
		"description": "Stop the stream. It can be started again using IGModAudioChannel:Play.\n\nCalling this invalidates the IGModAudioChannel object rendering it unusable for further functions.",
		"prefix": "Stop"
	},
	"IMaterial:GetColor": {
		"body": [
			"GetColor(${1:x}, ${2:y})$0"
		],
		"description": "Returns the color of the specified pixel of the $basetexture, only works for materials created from PNG files.\n\nBasically identical to ITexture:GetColor used on IMaterial:GetTexture( \"$basetexture\" ).\n\nThe returned color will not have the color metatable.",
		"prefix": "GetColor"
	},
	"IMaterial:GetFloat": {
		"body": [
			"GetFloat(${1:materialFloat})$0"
		],
		"description": "Returns the specified material value as a float, or nil if the value is not set.",
		"prefix": "GetFloat"
	},
	"IMaterial:GetInt": {
		"body": [
			"GetInt(${1:materialInt})$0"
		],
		"description": "Returns the specified material value as a int, rounds the value if its a float, or nil if the value is not set.\n\nPlease note that certain material flags such as `$model` are stored in the `$flags` variable and cannot be directly retrieved with this function. See the full list here: Material Flags",
		"prefix": "GetInt"
	},
	"IMaterial:GetKeyValues": {
		"body": [
			"GetKeyValues()$0"
		],
		"description": "Gets all the key values defined for the material.",
		"prefix": "GetKeyValues"
	},
	"IMaterial:GetMatrix": {
		"body": [
			"GetMatrix(${1:materialMatrix})$0"
		],
		"description": "Returns the specified material matrix as a int, or nil if the value is not set or is not a matrix.",
		"prefix": "GetMatrix"
	},
	"IMaterial:GetName": {
		"body": [
			"GetName()$0"
		],
		"description": "Returns the name of the material, in most cases the path.",
		"prefix": "GetName"
	},
	"IMaterial:GetShader": {
		"body": [
			"GetShader()$0"
		],
		"description": "Returns the name of the materials shader.\n\nThis function does not work serverside on Linux SRCDS.",
		"prefix": "GetShader"
	},
	"IMaterial:GetString": {
		"body": [
			"GetString(${1:materialString})$0"
		],
		"description": "Returns the specified material string, or nil if the value is not set or if the value can not be converted to a string.",
		"prefix": "GetString"
	},
	"IMaterial:GetTexture": {
		"body": [
			"GetTexture(${1:param})$0"
		],
		"description": "Returns an ITexture based on the passed shader parameter.",
		"prefix": "GetTexture"
	},
	"IMaterial:GetVector": {
		"body": [
			"GetVector(${1:materialVector})$0"
		],
		"description": "Returns the specified material vector, or nil if the value is not set.\n\nSee also IMaterial:GetVectorLinear",
		"prefix": "GetVector"
	},
	"IMaterial:GetVector4D": {
		"body": [
			"GetVector4D(${1:name})$0"
		],
		"description": "Returns the specified material vector as a 4 component vector.",
		"prefix": "GetVector4D"
	},
	"IMaterial:GetVectorLinear": {
		"body": [
			"GetVectorLinear(${1:materialVector})$0"
		],
		"description": "Returns the specified material linear color vector, or nil if the value is not set.\n\nSee https://en.wikipedia.org/wiki/Gamma_correction\n\nSee also IMaterial:GetVector",
		"prefix": "GetVectorLinear"
	},
	"IMaterial:Height": {
		"body": [
			"Height()$0"
		],
		"description": "Returns the height of the member texture set for $basetexture.",
		"prefix": "Height"
	},
	"IMaterial:IsError": {
		"body": [
			"IsError()$0"
		],
		"description": "Returns whenever the material is valid, i.e. whether it was not loaded successfully from disk or not.",
		"prefix": "IsError"
	},
	"IMaterial:Recompute": {
		"body": [
			"Recompute()$0"
		],
		"description": "Recomputes the material's snapshot. This needs to be called if you have changed variables on your material and it isn't changing.\n\nBe careful though - this function is slow - so try to call it only when needed!",
		"prefix": "Recompute"
	},
	"IMaterial:SetFloat": {
		"body": [
			"SetFloat(${1:materialFloat}, ${2:float})$0"
		],
		"description": "Sets the specified material float to the specified float, does nothing on a type mismatch.",
		"prefix": "SetFloat"
	},
	"IMaterial:SetInt": {
		"body": [
			"SetInt(${1:materialInt}, ${2:int})$0"
		],
		"description": "Sets the specified material value to the specified int, does nothing on a type mismatch.\n\nPlease note that certain material flags such as `$model` are stored in the `$flags` variable and cannot be directly set with this function. See the full list here: Material Flags",
		"prefix": "SetInt"
	},
	"IMaterial:SetMatrix": {
		"body": [
			"SetMatrix(${1:materialMatrix}, ${2:matrix})$0"
		],
		"description": "Sets the specified material value to the specified matrix, does nothing on a type mismatch.",
		"prefix": "SetMatrix"
	},
	"IMaterial:SetShader": {
		"body": [
			"SetShader(${1:shaderName})$0"
		],
		"description": "This function does nothingThe functionality of this function was removed due to the amount of crashes it caused.",
		"prefix": "SetShader"
	},
	"IMaterial:SetString": {
		"body": [
			"SetString(${1:materialString}, ${2:string})$0"
		],
		"description": "Sets the specified material value to the specified string, does nothing on a type mismatch.",
		"prefix": "SetString"
	},
	"IMaterial:SetTexture": {
		"body": [
			"SetTexture(${1:materialTexture}, ${2:texture})$0"
		],
		"description": "Sets the specified material texture to the specified texture, does nothing on a type mismatch.",
		"prefix": "SetTexture"
	},
	"IMaterial:SetUndefined": {
		"body": [
			"SetUndefined(${1:materialValueName})$0"
		],
		"description": "Unsets the value for the specified material value.",
		"prefix": "SetUndefined"
	},
	"IMaterial:SetVector": {
		"body": [
			"SetVector(${1:MaterialVector}, ${2:vec})$0"
		],
		"description": "Sets the specified material vector to the specified vector, does nothing on a type mismatch.",
		"prefix": "SetVector"
	},
	"IMaterial:SetVector4D": {
		"body": [
			"SetVector4D(${1:name}, ${2:x}, ${3:y}, ${4:z}, ${5:w})$0"
		],
		"description": "Sets the specified material vector to the specified 4 component vector, does nothing on a type mismatch.",
		"prefix": "SetVector4D"
	},
	"IMaterial:Width": {
		"body": [
			"Width()$0"
		],
		"description": "Returns the width of the member texture set for $basetexture.",
		"prefix": "Width"
	},
	"IMesh:BuildFromTriangles": {
		"body": [
			"BuildFromTriangles(${1:vertexes})$0"
		],
		"description": "Builds the mesh from a table mesh vertexes.\n\nSee Global.Mesh and util.GetModelMeshes for examples.",
		"prefix": "BuildFromTriangles"
	},
	"IMesh:Destroy": {
		"body": [
			"Destroy()$0"
		],
		"description": "Deletes the mesh and frees the memory used by it.",
		"prefix": "Destroy"
	},
	"IMesh:Draw": {
		"body": [
			"Draw()$0"
		],
		"description": "Renders the mesh with the active matrix.",
		"prefix": "Draw"
	},
	"IMesh:IsValid": {
		"body": [
			"IsValid()$0"
		],
		"description": "Returns whether this IMesh is valid or not.",
		"prefix": "IsValid"
	},
	"IRestore:EndBlock": {
		"body": [
			"EndBlock()$0"
		],
		"description": "Ends current data block started with IRestore:StartBlock and returns to the parent block.\n\nTo avoid all sorts of errors, you **must** end all blocks you start.",
		"prefix": "EndBlock"
	},
	"IRestore:ReadAngle": {
		"body": [
			"ReadAngle()$0"
		],
		"description": "Reads next bytes from the restore object as an Angle.",
		"prefix": "ReadAngle"
	},
	"IRestore:ReadBool": {
		"body": [
			"ReadBool()$0"
		],
		"description": "Reads next bytes from the restore object as a boolean.",
		"prefix": "ReadBool"
	},
	"IRestore:ReadEntity": {
		"body": [
			"ReadEntity()$0"
		],
		"description": "Reads next bytes from the restore object as an Entity.",
		"prefix": "ReadEntity"
	},
	"IRestore:ReadFloat": {
		"body": [
			"ReadFloat()$0"
		],
		"description": "Reads next bytes from the restore object as a floating point number.",
		"prefix": "ReadFloat"
	},
	"IRestore:ReadInt": {
		"body": [
			"ReadInt()$0"
		],
		"description": "Reads next bytes from the restore object as an integer number.",
		"prefix": "ReadInt"
	},
	"IRestore:ReadString": {
		"body": [
			"ReadString()$0"
		],
		"description": "Reads next bytes from the restore object as a string.",
		"prefix": "ReadString"
	},
	"IRestore:ReadVector": {
		"body": [
			"ReadVector()$0"
		],
		"description": "Reads next bytes from the restore object as a Vector.",
		"prefix": "ReadVector"
	},
	"IRestore:StartBlock": {
		"body": [
			"StartBlock()$0"
		],
		"description": "Loads next block of data to be read inside current block. Blocks **must** be ended with IRestore:EndBlock.",
		"prefix": "StartBlock"
	},
	"ISave:EndBlock": {
		"body": [
			"EndBlock()$0"
		],
		"description": "Ends current data block started with ISave:StartBlock and returns to the parent block.\n\nTo avoid all sorts of errors, you **must** end all blocks you start.",
		"prefix": "EndBlock"
	},
	"ISave:StartBlock": {
		"body": [
			"StartBlock(${1:name})$0"
		],
		"description": "Starts a new block of data that you can write to inside current block. Blocks **must** be ended with ISave:EndBlock.",
		"prefix": "StartBlock"
	},
	"ISave:WriteAngle": {
		"body": [
			"WriteAngle(${1:ang})$0"
		],
		"description": "Writes an Angle to the save object.",
		"prefix": "WriteAngle"
	},
	"ISave:WriteBool": {
		"body": [
			"WriteBool(${1:bool})$0"
		],
		"description": "Writes a boolean to the save object.",
		"prefix": "WriteBool"
	},
	"ISave:WriteEntity": {
		"body": [
			"WriteEntity(${1:ent})$0"
		],
		"description": "Writes an Entity to the save object.",
		"prefix": "WriteEntity"
	},
	"ISave:WriteFloat": {
		"body": [
			"WriteFloat(${1:float})$0"
		],
		"description": "Writes a floating point number to the save object.",
		"prefix": "WriteFloat"
	},
	"ISave:WriteInt": {
		"body": [
			"WriteInt(${1:int})$0"
		],
		"description": "Writes an integer number to the save object.",
		"prefix": "WriteInt"
	},
	"ISave:WriteString": {
		"body": [
			"WriteString(${1:str})$0"
		],
		"description": "Writes a string to the save object.",
		"prefix": "WriteString"
	},
	"ISave:WriteVector": {
		"body": [
			"WriteVector(${1:vec})$0"
		],
		"description": "Writes a Vector to the save object.",
		"prefix": "WriteVector"
	},
	"ITexture:Download": {
		"body": [
			"Download()$0"
		],
		"description": "Invokes the generator of the texture. Reloads file based textures from disk and clears render target textures.",
		"prefix": "Download"
	},
	"ITexture:GetColor": {
		"body": [
			"GetColor(${1:x}, ${2:y})$0"
		],
		"description": "Returns the color of the specified pixel, only works for textures created from PNG files.\n\nThe returned color will not have the color metatable.",
		"prefix": "GetColor"
	},
	"ITexture:GetMappingHeight": {
		"body": [
			"GetMappingHeight()$0"
		],
		"description": "Returns the true unmodified height of the texture.",
		"prefix": "GetMappingHeight"
	},
	"ITexture:GetMappingWidth": {
		"body": [
			"GetMappingWidth()$0"
		],
		"description": "Returns the true unmodified width of the texture.",
		"prefix": "GetMappingWidth"
	},
	"ITexture:GetName": {
		"body": [
			"GetName()$0"
		],
		"description": "Returns the name of the texture, in most cases the path.",
		"prefix": "GetName"
	},
	"ITexture:GetNumAnimationFrames": {
		"body": [
			"GetNumAnimationFrames()$0"
		],
		"description": "Returns the number of animation frames in this texture.",
		"prefix": "GetNumAnimationFrames"
	},
	"ITexture:Height": {
		"body": [
			"Height()$0"
		],
		"description": "Returns the modified height of the texture, this value may be affected by mipmapping and other factors.",
		"prefix": "Height"
	},
	"ITexture:IsError": {
		"body": [
			"IsError()$0"
		],
		"description": "Returns whenever the texture is valid. (i.e. was loaded successfully or not)\n\nThe \"error\" texture is a valid texture, and therefore this function will return false when used on it. Use ITexture:IsErrorTexture, instead.",
		"prefix": "IsError"
	},
	"ITexture:IsErrorTexture": {
		"body": [
			"IsErrorTexture()$0"
		],
		"description": "Returns whenever the texture is the error texture (pink and black checkerboard pattern).",
		"prefix": "IsErrorTexture"
	},
	"ITexture:Width": {
		"body": [
			"Width()$0"
		],
		"description": "Returns the modified width of the texture, this value may be affected by mipmapping and other factors.",
		"prefix": "Width"
	},
	"IVideoWriter:AddFrame": {
		"body": [
			"AddFrame(${1:frameTime}, ${2:downsample})$0"
		],
		"description": "Adds the current framebuffer to the video stream.",
		"prefix": "AddFrame"
	},
	"IVideoWriter:Finish": {
		"body": [
			"Finish()$0"
		],
		"description": "Ends the video recording and dumps it to disk.",
		"prefix": "Finish"
	},
	"IVideoWriter:Height": {
		"body": [
			"Height()$0"
		],
		"description": "Returns the height of the video stream.",
		"prefix": "Height"
	},
	"IVideoWriter:SetRecordSound": {
		"body": [
			"SetRecordSound(${1:record})$0"
		],
		"description": "Sets whether to record sound or not.",
		"prefix": "SetRecordSound"
	},
	"IVideoWriter:Width": {
		"body": [
			"Width()$0"
		],
		"description": "Returns the width of the video stream.",
		"prefix": "Width"
	},
	"MarkupObject:Draw": {
		"body": [
			"Draw(${1:xOffset}, ${2:yOffset}, ${3:xAlign}, ${4:yAlign}, ${5:alphaoverride=255})$0"
		],
		"description": "Draws the computed markupobject to the screen.",
		"prefix": "Draw"
	},
	"MarkupObject:GetHeight": {
		"body": [
			"GetHeight()$0"
		],
		"description": "Gets computed the height of the markupobject.",
		"prefix": "GetHeight"
	},
	"MarkupObject:GetWidth": {
		"body": [
			"GetWidth()$0"
		],
		"description": "Gets computed the width of the markupobject.",
		"prefix": "GetWidth"
	},
	"MarkupObject:Size": {
		"body": [
			"Size()$0"
		],
		"description": "Gets computed the width and height of the markupobject.",
		"prefix": "Size"
	},
	"NPC:AddEntityRelationship": {
		"body": [
			"AddEntityRelationship(${1:target}, ${2:disposition}, ${3:priority})$0"
		],
		"description": "Makes the NPC like, hate, feel neutral towards, or fear the entity in question. If you want to setup relationship towards a certain entity `class`, use NPC:AddRelationship.\n\nNPCs do not see NextBots by default. This can be fixed by adding the Enums/FL flag to the NextBot.",
		"prefix": "AddEntityRelationship"
	},
	"NPC:AddRelationship": {
		"body": [
			"AddRelationship(${1:relationstring})$0"
		],
		"description": "Changes how an NPC feels towards another NPC.  If you want to setup relationship towards a certain `entity`, use NPC:AddEntityRelationship.",
		"prefix": "AddRelationship"
	},
	"NPC:AlertSound": {
		"body": [
			"AlertSound()$0"
		],
		"description": "Force an NPC to play his Alert sound.",
		"prefix": "AlertSound"
	},
	"NPC:CapabilitiesAdd": {
		"body": [
			"CapabilitiesAdd(${1:capabilities})$0"
		],
		"description": "Adds a capability to the NPC.",
		"prefix": "CapabilitiesAdd"
	},
	"NPC:CapabilitiesClear": {
		"body": [
			"CapabilitiesClear()$0"
		],
		"description": "Removes all of Capabilities the NPC has.",
		"prefix": "CapabilitiesClear"
	},
	"NPC:CapabilitiesGet": {
		"body": [
			"CapabilitiesGet()$0"
		],
		"description": "Returns the NPC's capabilities along the ones defined on its weapon.",
		"prefix": "CapabilitiesGet"
	},
	"NPC:CapabilitiesRemove": {
		"body": [
			"CapabilitiesRemove(${1:capabilities})$0"
		],
		"description": "Remove a certain capability.",
		"prefix": "CapabilitiesRemove"
	},
	"NPC:Classify": {
		"body": [
			"Classify()$0"
		],
		"description": "Returns the NPC class. Do not confuse with Entity:GetClass!",
		"prefix": "Classify"
	},
	"NPC:ClearCondition": {
		"body": [
			"ClearCondition(${1:condition})$0"
		],
		"description": "Clears out the specified Enums/COND on this NPC.",
		"prefix": "ClearCondition"
	},
	"NPC:ClearEnemyMemory": {
		"body": [
			"ClearEnemyMemory(${1:enemy=GetEnemy()})$0"
		],
		"description": "Clears the Enemy from the NPC's memory, effectively forgetting it until met again with either the NPC vision or with NPC:UpdateEnemyMemory.",
		"prefix": "ClearEnemyMemory"
	},
	"NPC:ClearExpression": {
		"body": [
			"ClearExpression()$0"
		],
		"description": "Clears the NPC's current expression which can be set with NPC:SetExpression.",
		"prefix": "ClearExpression"
	},
	"NPC:ClearGoal": {
		"body": [
			"ClearGoal()$0"
		],
		"description": "Clears the current NPC goal or target.",
		"prefix": "ClearGoal"
	},
	"NPC:ClearSchedule": {
		"body": [
			"ClearSchedule()$0"
		],
		"description": "Stops the current schedule that the NPC is doing.",
		"prefix": "ClearSchedule"
	},
	"NPC:ConditionName": {
		"body": [
			"ConditionName(${1:cond})$0"
		],
		"description": "Translates condition ID to a string.",
		"prefix": "ConditionName"
	},
	"NPC:Disposition": {
		"body": [
			"Disposition(${1:ent})$0"
		],
		"description": "Returns the way the NPC \"feels\" about the entity.",
		"prefix": "Disposition"
	},
	"NPC:DropWeapon": {
		"body": [
			"DropWeapon(${1:weapon=nil}, ${2:target=nil}, ${3:velocity=nil})$0"
		],
		"description": "Forces the NPC to drop the specified weapon.",
		"prefix": "DropWeapon"
	},
	"NPC:ExitScriptedSequence": {
		"body": [
			"ExitScriptedSequence()$0"
		],
		"description": "Makes an NPC exit a scripted sequence, if one is playing.",
		"prefix": "ExitScriptedSequence"
	},
	"NPC:FearSound": {
		"body": [
			"FearSound()$0"
		],
		"description": "Force an NPC to play his Fear sound.",
		"prefix": "FearSound"
	},
	"NPC:FoundEnemySound": {
		"body": [
			"FoundEnemySound()$0"
		],
		"description": "Force an NPC to play its FoundEnemy sound.",
		"prefix": "FoundEnemySound"
	},
	"NPC:GetActiveWeapon": {
		"body": [
			"GetActiveWeapon()$0"
		],
		"description": "Returns the weapon the NPC is currently carrying, or Global_Variables.",
		"prefix": "GetActiveWeapon"
	},
	"NPC:GetActivity": {
		"body": [
			"GetActivity()$0"
		],
		"description": "Returns the NPC's current activity.",
		"prefix": "GetActivity"
	},
	"NPC:GetAimVector": {
		"body": [
			"GetAimVector()$0"
		],
		"description": "Returns the aim vector of the NPC. NPC alternative of Player:GetAimVector.",
		"prefix": "GetAimVector"
	},
	"NPC:GetArrivalActivity": {
		"body": [
			"GetArrivalActivity()$0"
		],
		"description": "Returns the activity to be played when the NPC arrives at its goal",
		"prefix": "GetArrivalActivity"
	},
	"NPC:GetArrivalSequence": {
		"body": [
			"GetArrivalSequence()$0"
		],
		"description": "Returns the sequence to be played when the NPC arrives at its goal.",
		"prefix": "GetArrivalSequence"
	},
	"NPC:GetBlockingEntity": {
		"body": [
			"GetBlockingEntity()$0"
		],
		"description": "Returns the entity blocking the NPC along its path.",
		"prefix": "GetBlockingEntity"
	},
	"NPC:GetCurWaypointPos": {
		"body": [
			"GetCurWaypointPos()$0"
		],
		"description": "Gets the NPC's current waypoint position (where NPC is currently moving towards), if any is available.",
		"prefix": "GetCurWaypointPos"
	},
	"NPC:GetCurrentSchedule": {
		"body": [
			"GetCurrentSchedule()$0"
		],
		"description": "Returns the NPC's current schedule.",
		"prefix": "GetCurrentSchedule"
	},
	"NPC:GetCurrentWeaponProficiency": {
		"body": [
			"GetCurrentWeaponProficiency()$0"
		],
		"description": "Returns how proficient (skilled) an NPC is with its current weapon.",
		"prefix": "GetCurrentWeaponProficiency"
	},
	"NPC:GetEnemy": {
		"body": [
			"GetEnemy()$0"
		],
		"description": "Returns the entity that this NPC is trying to fight.\n\nThis returns nil if the NPC has no enemy. You should use Global.IsValid (which accounts for nil and NULL) on the return to verify validity of the enemy.",
		"prefix": "GetEnemy"
	},
	"NPC:GetEnemyFirstTimeSeen": {
		"body": [
			"GetEnemyFirstTimeSeen(${1:enemy=GetEnemy()})$0"
		],
		"description": "Returns the first time an NPC's enemy was seen by the NPC.",
		"prefix": "GetEnemyFirstTimeSeen"
	},
	"NPC:GetEnemyLastKnownPos": {
		"body": [
			"GetEnemyLastKnownPos(${1:enemy=GetEnemy()})$0"
		],
		"description": "Returns the last known position of an NPC's enemy.",
		"prefix": "GetEnemyLastKnownPos"
	},
	"NPC:GetEnemyLastSeenPos": {
		"body": [
			"GetEnemyLastSeenPos(${1:enemy=GetEnemy()})$0"
		],
		"description": "Returns the last seen position of an NPC's enemy.",
		"prefix": "GetEnemyLastSeenPos"
	},
	"NPC:GetEnemyLastTimeSeen": {
		"body": [
			"GetEnemyLastTimeSeen(${1:enemy=GetEnemy()})$0"
		],
		"description": "Returns the last time an NPC's enemy was seen by the NPC.",
		"prefix": "GetEnemyLastTimeSeen"
	},
	"NPC:GetExpression": {
		"body": [
			"GetExpression()$0"
		],
		"description": "Returns the expression file the NPC is currently playing.",
		"prefix": "GetExpression"
	},
	"NPC:GetHullType": {
		"body": [
			"GetHullType()$0"
		],
		"description": "Returns NPCs hull type set by NPC:SetHullType.",
		"prefix": "GetHullType"
	},
	"NPC:GetMovementActivity": {
		"body": [
			"GetMovementActivity()$0"
		],
		"description": "Returns the NPC's current movement activity.",
		"prefix": "GetMovementActivity"
	},
	"NPC:GetMovementSequence": {
		"body": [
			"GetMovementSequence()$0"
		],
		"description": "Returns the index of the sequence the NPC uses to move.",
		"prefix": "GetMovementSequence"
	},
	"NPC:GetNPCState": {
		"body": [
			"GetNPCState()$0"
		],
		"description": "Returns the NPC's state.",
		"prefix": "GetNPCState"
	},
	"NPC:GetNextWaypointPos": {
		"body": [
			"GetNextWaypointPos()$0"
		],
		"description": "Gets the NPC's next waypoint position, where NPC will be moving after reaching current waypoint, if any is available.",
		"prefix": "GetNextWaypointPos"
	},
	"NPC:GetPathDistanceToGoal": {
		"body": [
			"GetPathDistanceToGoal()$0"
		],
		"description": "Returns the distance the NPC is from Target Goal.",
		"prefix": "GetPathDistanceToGoal"
	},
	"NPC:GetPathTimeToGoal": {
		"body": [
			"GetPathTimeToGoal()$0"
		],
		"description": "Returns the amount of time it will take for the NPC to get to its Target Goal.",
		"prefix": "GetPathTimeToGoal"
	},
	"NPC:GetShootPos": {
		"body": [
			"GetShootPos()$0"
		],
		"description": "Returns the shooting position of the NPC.\n\nThis only works properly when called on an NPC that can hold weapons, otherwise it will return the same value as Entity:GetPos.",
		"prefix": "GetShootPos"
	},
	"NPC:GetTarget": {
		"body": [
			"GetTarget()$0"
		],
		"description": "Returns the NPC's current target set by NPC:SetTarget.\n\nThis returns nil if the NPC has no target. You should use Global.IsValid (which accounts for nil and NULL) on the return to verify validity of the target.",
		"prefix": "GetTarget"
	},
	"NPC:GetWeapon": {
		"body": [
			"GetWeapon(${1:class})$0"
		],
		"description": "Returns a specific weapon the NPC owns.",
		"prefix": "GetWeapon"
	},
	"NPC:GetWeapons": {
		"body": [
			"GetWeapons()$0"
		],
		"description": "Returns a table of the NPC's weapons.",
		"prefix": "GetWeapons"
	},
	"NPC:Give": {
		"body": [
			"Give(${1:weapon})$0"
		],
		"description": "Used to give a weapon to an already spawned NPC.",
		"prefix": "Give"
	},
	"NPC:HasCondition": {
		"body": [
			"HasCondition(${1:condition})$0"
		],
		"description": "Returns whether or not the NPC has the given condition.",
		"prefix": "HasCondition"
	},
	"NPC:HasEnemyEluded": {
		"body": [
			"HasEnemyEluded(${1:enemy=GetEnemy()})$0"
		],
		"description": "Polls the enemy memory to check if the given entity has eluded us or not.",
		"prefix": "HasEnemyEluded"
	},
	"NPC:HasEnemyMemory": {
		"body": [
			"HasEnemyMemory(${1:enemy=GetEnemy()})$0"
		],
		"description": "Polls the enemy memory to check if the NPC has any memory of given enemy.",
		"prefix": "HasEnemyMemory"
	},
	"NPC:IdleSound": {
		"body": [
			"IdleSound()$0"
		],
		"description": "Force an NPC to play his Idle sound.",
		"prefix": "IdleSound"
	},
	"NPC:IsCurrentSchedule": {
		"body": [
			"IsCurrentSchedule(${1:schedule})$0"
		],
		"description": "Returns whether or not the NPC is performing the given schedule.",
		"prefix": "IsCurrentSchedule"
	},
	"NPC:IsMoving": {
		"body": [
			"IsMoving()$0"
		],
		"description": "Returns whether the NPC is moving or not.",
		"prefix": "IsMoving"
	},
	"NPC:IsRunningBehavior": {
		"body": [
			"IsRunningBehavior()$0"
		],
		"description": "Checks if the NPC is running an **ai_goal**. ( e.g. An npc_citizen NPC following the Player. )",
		"prefix": "IsRunningBehavior"
	},
	"NPC:IsUnreachable": {
		"body": [
			"IsUnreachable(${1:testEntity})$0"
		],
		"description": "Returns true if the entity was remembered as unreachable. The memory is updated automatically from following engine tasks if they failed:\n* TASK_GET_CHASE_PATH_TO_ENEMY\n* TASK_GET_PATH_TO_ENEMY_LKP\n* TASK_GET_PATH_TO_INTERACTION_PARTNER\n* TASK_ANTLIONGUARD_GET_CHASE_PATH_ENEMY_TOLERANCE\n* SCHED_FAIL_ESTABLISH_LINE_OF_FIRE - Combine NPCs, also when failing to change their enemy",
		"prefix": "IsUnreachable"
	},
	"NPC:LostEnemySound": {
		"body": [
			"LostEnemySound()$0"
		],
		"description": "Force an NPC to play his LostEnemy sound.",
		"prefix": "LostEnemySound"
	},
	"NPC:MaintainActivity": {
		"body": [
			"MaintainActivity()$0"
		],
		"description": "Tries to achieve our ideal animation state, playing any transition sequences that we need to play to get there.",
		"prefix": "MaintainActivity"
	},
	"NPC:MarkEnemyAsEluded": {
		"body": [
			"MarkEnemyAsEluded(${1:enemy=GetEnemy()})$0"
		],
		"description": "Causes the NPC to temporarily forget the current enemy and switch on to a better one.",
		"prefix": "MarkEnemyAsEluded"
	},
	"NPC:MoveOrder": {
		"body": [
			"MoveOrder(${1:position})$0"
		],
		"description": "Makes the NPC walk toward the given position. The NPC will return to the player after amount of time set by **player_squad_autosummon_time** ConVar.\n\nOnly works on Citizens (npc_citizen) and is a part of the Half-Life 2 squad system.\n\nThe NPC **must** be in the player's squad for this to work.",
		"prefix": "MoveOrder"
	},
	"NPC:NavSetGoal": {
		"body": [
			"NavSetGoal(${1:pos}, ${2:length}, ${3:dir})$0"
		],
		"description": "Works similarly to NPC:NavSetRandomGoal.",
		"prefix": "NavSetGoal"
	},
	"NPC:NavSetGoalTarget": {
		"body": [
			"NavSetGoalTarget(${1:target}, ${2:offset})$0"
		],
		"description": "Set the goal target for an NPC.",
		"prefix": "NavSetGoalTarget"
	},
	"NPC:NavSetRandomGoal": {
		"body": [
			"NavSetRandomGoal(${1:minPathLength}, ${2:dir})$0"
		],
		"description": "Creates a random path of specified minimum length between a closest start node and random node in the specified direction. This won't actually force the NPC to move.",
		"prefix": "NavSetRandomGoal"
	},
	"NPC:NavSetWanderGoal": {
		"body": [
			"NavSetWanderGoal(${1:xOffset}, ${2:yOffset})$0"
		],
		"description": "Sets a goal in x, y offsets for the NPC to wander to",
		"prefix": "NavSetWanderGoal"
	},
	"NPC:PickupWeapon": {
		"body": [
			"PickupWeapon(${1:wep})$0"
		],
		"description": "Forces the NPC to pickup an existing weapon entity. The NPC will not pick up the weapon if they already own a weapon of given type, or if the NPC could not normally have this weapon in their inventory.",
		"prefix": "PickupWeapon"
	},
	"NPC:PlaySentence": {
		"body": [
			"PlaySentence(${1:sentence}, ${2:delay}, ${3:volume})$0"
		],
		"description": "Forces the NPC to play a sentence from scripts/sentences.txt",
		"prefix": "PlaySentence"
	},
	"NPC:RememberUnreachable": {
		"body": [
			"RememberUnreachable(${1:ent}, ${2:time=3})$0"
		],
		"description": "Makes the NPC remember an entity or an enemy as unreachable, for a specified amount of time. Use NPC:IsUnreachable to check if an entity is still unreachable.",
		"prefix": "RememberUnreachable"
	},
	"NPC:RemoveMemory": {
		"body": [
			"RemoveMemory()$0"
		],
		"description": "\n\nThis function crashes the game no matter how it is used and will be removed in a future update.\n\nUse NPC:ClearEnemyMemory instead.",
		"prefix": "RemoveMemory"
	},
	"NPC:RunEngineTask": {
		"body": [
			"RunEngineTask(${1:taskID}, ${2:taskData})$0"
		],
		"description": "Starts an engine task.\n\nUsed internally by the ai_task.",
		"prefix": "RunEngineTask"
	},
	"NPC:SelectWeapon": {
		"body": [
			"SelectWeapon(${1:class})$0"
		],
		"description": "Forces the NPC to switch to a specific weapon the NPC owns. See NPC:GetWeapons.",
		"prefix": "SelectWeapon"
	},
	"NPC:SentenceStop": {
		"body": [
			"SentenceStop()$0"
		],
		"description": "Stops any sounds (speech) the NPC is currently palying.\n\nEquivalent to `Entity:EmitSound( \"AI_BaseNPC.SentenceStop\" )`",
		"prefix": "SentenceStop"
	},
	"NPC:SetArrivalActivity": {
		"body": [
			"SetArrivalActivity(${1:act})$0"
		],
		"description": "",
		"prefix": "SetArrivalActivity"
	},
	"NPC:SetArrivalDirection": {
		"body": [
			"SetArrivalDirection()$0"
		],
		"description": "",
		"prefix": "SetArrivalDirection"
	},
	"NPC:SetArrivalDistance": {
		"body": [
			"SetArrivalDistance(${1:dist})$0"
		],
		"description": "Sets the distance to goal at which the NPC should stop moving and continue to other business such as doing the rest of their tasks in a schedule.",
		"prefix": "SetArrivalDistance"
	},
	"NPC:SetArrivalSequence": {
		"body": [
			"SetArrivalSequence()$0"
		],
		"description": "",
		"prefix": "SetArrivalSequence"
	},
	"NPC:SetArrivalSpeed": {
		"body": [
			"SetArrivalSpeed()$0"
		],
		"description": "",
		"prefix": "SetArrivalSpeed"
	},
	"NPC:SetCondition": {
		"body": [
			"SetCondition(${1:condition})$0"
		],
		"description": "Sets an NPC condition.",
		"prefix": "SetCondition"
	},
	"NPC:SetCurrentWeaponProficiency": {
		"body": [
			"SetCurrentWeaponProficiency(${1:proficiency})$0"
		],
		"description": "Sets the weapon proficiency of an NPC (how skilled an NPC is with its current weapon).",
		"prefix": "SetCurrentWeaponProficiency"
	},
	"NPC:SetEnemy": {
		"body": [
			"SetEnemy(${1:enemy}, ${2:newenemy=true})$0"
		],
		"description": "Sets the target for an NPC.",
		"prefix": "SetEnemy"
	},
	"NPC:SetExpression": {
		"body": [
			"SetExpression(${1:expression})$0"
		],
		"description": "Sets the NPC's .vcd expression. Similar to Entity:PlayScene except the scene is looped until it's interrupted by default NPC behavior or NPC:ClearExpression.",
		"prefix": "SetExpression"
	},
	"NPC:SetHullSizeNormal": {
		"body": [
			"SetHullSizeNormal()$0"
		],
		"description": "Updates the NPC's hull and physics hull in order to match its model scale. Entity:SetModelScale seems to take care of this regardless.",
		"prefix": "SetHullSizeNormal"
	},
	"NPC:SetHullType": {
		"body": [
			"SetHullType(${1:hullType})$0"
		],
		"description": "Sets the hull type for the NPC.",
		"prefix": "SetHullType"
	},
	"NPC:SetIdealYawAndUpdate": {
		"body": [
			"SetIdealYawAndUpdate(${1:angle}, ${2:speed=-1})$0"
		],
		"description": "Sets the ideal yaw angle (left-right rotation) for the NPC and forces them to turn to that angle.",
		"prefix": "SetIdealYawAndUpdate"
	},
	"NPC:SetLastPosition": {
		"body": [
			"SetLastPosition(${1:Position})$0"
		],
		"description": "Sets the last registered or memorized position for an npc. When using scheduling, the NPC will focus on navigating to the last position via nodes.\n\nThe navigation requires ground nodes to function properly, otherwise the NPC could only navigate in a small area. (https://developer.valvesoftware.com/wiki/Info_node)",
		"prefix": "SetLastPosition"
	},
	"NPC:SetMaxRouteRebuildTime": {
		"body": [
			"SetMaxRouteRebuildTime(${1:time})$0"
		],
		"description": "Sets how long to try rebuilding path before failing task.",
		"prefix": "SetMaxRouteRebuildTime"
	},
	"NPC:SetMovementActivity": {
		"body": [
			"SetMovementActivity(${1:activity})$0"
		],
		"description": "Sets the activity the NPC uses when it moves.",
		"prefix": "SetMovementActivity"
	},
	"NPC:SetMovementSequence": {
		"body": [
			"SetMovementSequence(${1:sequenceId})$0"
		],
		"description": "Sets the sequence the NPC navigation path uses for speed calculation. Doesn't seem to have any visible effect on NPC movement.",
		"prefix": "SetMovementSequence"
	},
	"NPC:SetNPCState": {
		"body": [
			"SetNPCState(${1:state})$0"
		],
		"description": "Sets the state the NPC is in to help it decide on a ideal schedule.",
		"prefix": "SetNPCState"
	},
	"NPC:SetSchedule": {
		"body": [
			"SetSchedule(${1:schedule})$0"
		],
		"description": "Sets the NPC's current schedule.",
		"prefix": "SetSchedule"
	},
	"NPC:SetTarget": {
		"body": [
			"SetTarget(${1:entity})$0"
		],
		"description": "Sets the NPC's target. This is used in some engine schedules.",
		"prefix": "SetTarget"
	},
	"NPC:StartEngineTask": {
		"body": [
			"StartEngineTask(${1:task}, ${2:taskData})$0"
		],
		"description": "Forces the NPC to start an engine task, this has different results for every NPC.",
		"prefix": "StartEngineTask"
	},
	"NPC:StopMoving": {
		"body": [
			"StopMoving()$0"
		],
		"description": "Resets the NPC's movement animation and velocity. Does not actually stop the NPC from moving.",
		"prefix": "StopMoving"
	},
	"NPC:TargetOrder": {
		"body": [
			"TargetOrder(${1:target})$0"
		],
		"description": "Cancels NPC:MoveOrder basically.\n\nOnly works on Citizens (npc_citizen) and is a part of the Half-Life 2 squad system.\n\nThe NPC **must** be in the player's squad for this to work.",
		"prefix": "TargetOrder"
	},
	"NPC:TaskComplete": {
		"body": [
			"TaskComplete()$0"
		],
		"description": "Marks the current NPC task as completed.\n\nThis is meant to be used alongside NPC:TaskFail to complete or fail custom Lua defined tasks. (Schedule:AddTask)",
		"prefix": "TaskComplete"
	},
	"NPC:TaskFail": {
		"body": [
			"TaskFail(${1:task})$0"
		],
		"description": "Marks the current NPC task as failed.\n\nThis is meant to be used alongside NPC:TaskComplete to complete or fail custom Lua defined tasks. (Schedule:AddTask)",
		"prefix": "TaskFail"
	},
	"NPC:UpdateEnemyMemory": {
		"body": [
			"UpdateEnemyMemory(${1:enemy}, ${2:pos})$0"
		],
		"description": "Force the NPC to update information on the supplied enemy, as if it had line of sight to it.",
		"prefix": "UpdateEnemyMemory"
	},
	"NPC:UseActBusyBehavior": {
		"body": [
			"UseActBusyBehavior()$0"
		],
		"description": "Only usable on \"ai\" base entities.",
		"prefix": "UseActBusyBehavior"
	},
	"NPC:UseAssaultBehavior": {
		"body": [
			"UseAssaultBehavior()$0"
		],
		"description": "",
		"prefix": "UseAssaultBehavior"
	},
	"NPC:UseFollowBehavior": {
		"body": [
			"UseFollowBehavior()$0"
		],
		"description": "Only usable on \"ai\" base entities.",
		"prefix": "UseFollowBehavior"
	},
	"NPC:UseFuncTankBehavior": {
		"body": [
			"UseFuncTankBehavior()$0"
		],
		"description": "",
		"prefix": "UseFuncTankBehavior"
	},
	"NPC:UseLeadBehavior": {
		"body": [
			"UseLeadBehavior()$0"
		],
		"description": "",
		"prefix": "UseLeadBehavior"
	},
	"NPC:UseNoBehavior": {
		"body": [
			"UseNoBehavior()$0"
		],
		"description": "Undoes the other Use*Behavior functions.\n\nOnly usable on \"ai\" base entities.",
		"prefix": "UseNoBehavior"
	},
	"NextBot:BecomeRagdoll": {
		"body": [
			"BecomeRagdoll(${1:info})$0"
		],
		"description": "Become a ragdoll and remove the entity.",
		"prefix": "BecomeRagdoll"
	},
	"NextBot:BodyMoveXY": {
		"body": [
			"BodyMoveXY()$0"
		],
		"description": "Should only be called in NEXTBOT:BodyUpdate. This sets the `move_x` and `move_y` pose parameters of the bot to fit how they're currently moving, sets the animation speed (Entity:GetPlaybackRate) to suit the ground speed, and calls Entity:FrameAdvance.\n\nThis function might cause crashes with some activities.",
		"prefix": "BodyMoveXY"
	},
	"NextBot:FindSpot": {
		"body": [
			"FindSpot(${1:type}, ${2:options})$0"
		],
		"description": "Like NextBot:FindSpots but only returns a vector.",
		"prefix": "FindSpot"
	},
	"NextBot:FindSpots": {
		"body": [
			"FindSpots(${1:specs})$0"
		],
		"description": "Returns a table of hiding spots.",
		"prefix": "FindSpots"
	},
	"NextBot:GetActivity": {
		"body": [
			"GetActivity()$0"
		],
		"description": "Returns the currently running activity",
		"prefix": "GetActivity"
	},
	"NextBot:GetFOV": {
		"body": [
			"GetFOV()$0"
		],
		"description": "Returns the Field of View of the Nextbot NPC, used for its vision functionality, such as NextBot:IsAbleToSee.",
		"prefix": "GetFOV"
	},
	"NextBot:GetMaxVisionRange": {
		"body": [
			"GetMaxVisionRange()$0"
		],
		"description": "Returns the maximum range the nextbot can see other nextbots/players at. See NextBot:IsAbleToSee.",
		"prefix": "GetMaxVisionRange"
	},
	"NextBot:GetRangeSquaredTo": {
		"body": [
			"GetRangeSquaredTo(${1:to})$0"
		],
		"description": "Returns squared distance to an entity or a position.\n\nSee also NextBot:GetRangeTo.",
		"prefix": "GetRangeSquaredTo"
	},
	"NextBot:GetRangeTo": {
		"body": [
			"GetRangeTo(${1:to})$0"
		],
		"description": "Returns the distance to an entity or position.\n\nSee also NextBot:GetRangeSquaredTo.",
		"prefix": "GetRangeTo"
	},
	"NextBot:GetSolidMask": {
		"body": [
			"GetSolidMask()$0"
		],
		"description": "Returns the solid mask for given NextBot.",
		"prefix": "GetSolidMask"
	},
	"NextBot:HandleStuck": {
		"body": [
			"HandleStuck()$0"
		],
		"description": "Called from Lua when the NPC is stuck. This should only be called from the behaviour coroutine - so if you want to override this function and do something special that yields - then go for it.\n\nYou should always call self.loco:ClearStuck() in this function to reset the stuck status - so it knows it's unstuck. See CLuaLocomotion:ClearStuck.",
		"prefix": "HandleStuck"
	},
	"NextBot:IsAbleToSee": {
		"body": [
			"IsAbleToSee(${1:ent}, ${2:useFOV=true})$0"
		],
		"description": "Returns if the Nextbot NPC can see the give entity or not.\n\nUsing this function creates the nextbot vision interface which will cause a significant performance hit!",
		"prefix": "IsAbleToSee"
	},
	"NextBot:MoveToPos": {
		"body": [
			"MoveToPos(${1:pos}, ${2:options})$0"
		],
		"description": "To be called in the behaviour coroutine only! Will yield until the bot has reached the goal or is stuck",
		"prefix": "MoveToPos"
	},
	"NextBot:PlaySequenceAndWait": {
		"body": [
			"PlaySequenceAndWait(${1:name}, ${2:speed=1})$0"
		],
		"description": "To be called in the behaviour coroutine only! Plays an animation sequence and waits for it to end before returning.",
		"prefix": "PlaySequenceAndWait"
	},
	"NextBot:SetFOV": {
		"body": [
			"SetFOV(${1:fov})$0"
		],
		"description": "Sets the Field of View for the Nextbot NPC, used for its vision functionality, such as NextBot:IsAbleToSee.",
		"prefix": "SetFOV"
	},
	"NextBot:SetMaxVisionRange": {
		"body": [
			"SetMaxVisionRange(${1:range})$0"
		],
		"description": "Sets the maximum range the nextbot can see other nextbots/players at. See NextBot:IsAbleToSee.",
		"prefix": "SetMaxVisionRange"
	},
	"NextBot:SetSolidMask": {
		"body": [
			"SetSolidMask(${1:mask})$0"
		],
		"description": "Sets the solid mask for given NextBot.\n\nThe default solid mask of a NextBot is Enums/MASK.",
		"prefix": "SetSolidMask"
	},
	"NextBot:StartActivity": {
		"body": [
			"StartActivity(${1:activity})$0"
		],
		"description": "Start doing an activity (animation)",
		"prefix": "StartActivity"
	},
	"Panel:Add": {
		"body": [
			"Add(${1:object})$0"
		],
		"description": "Adds the specified object to the panel.",
		"prefix": "Add"
	},
	"Panel:AddText": {
		"body": [
			"AddText()$0"
		],
		"description": "Does nothing\nThis function does nothing.",
		"prefix": "AddText"
	},
	"Panel:AlignBottom": {
		"body": [
			"AlignBottom(${1:offset=0})$0"
		],
		"description": "Aligns the panel on the bottom of its parent with the specified offset.",
		"prefix": "AlignBottom"
	},
	"Panel:AlignLeft": {
		"body": [
			"AlignLeft(${1:offset=0})$0"
		],
		"description": "Aligns the panel on the left of its parent with the specified offset.",
		"prefix": "AlignLeft"
	},
	"Panel:AlignRight": {
		"body": [
			"AlignRight(${1:offset=0})$0"
		],
		"description": "Aligns the panel on the right of its parent with the specified offset.",
		"prefix": "AlignRight"
	},
	"Panel:AlignTop": {
		"body": [
			"AlignTop(${1:offset=0})$0"
		],
		"description": "Aligns the panel on the top of its parent with the specified offset.",
		"prefix": "AlignTop"
	},
	"Panel:AlphaTo": {
		"body": [
			"AlphaTo(${1:alpha}, ${2:duration}, ${3:delay=0}, ${4:callback})$0"
		],
		"description": "Uses animation to transition the current alpha value of a panel to a new alpha, over a set period of time and after a specified delay.",
		"prefix": "AlphaTo"
	},
	"Panel:AnimTail": {
		"body": [
			"AnimTail()$0"
		],
		"description": "Returns the Global.SysTime value when all animations for this panel object will end.",
		"prefix": "AnimTail"
	},
	"Panel:AnimationThinkInternal": {
		"body": [
			"AnimationThinkInternal()$0"
		],
		"description": " Performs the per-frame operations required for panel animations.\n\nThis is called every frame by PANEL:AnimationThink.",
		"prefix": "AnimationThinkInternal"
	},
	"Panel:AppendText": {
		"body": [
			"AppendText(${1:txt})$0"
		],
		"description": "Appends text to a RichText element. This does not automatically add a new line.",
		"prefix": "AppendText"
	},
	"Panel:ApplyGWEN": {
		"body": [
			"ApplyGWEN(${1:GWENTable})$0"
		],
		"description": "Used by Panel:LoadGWENFile and Panel:LoadGWENString to apply a GWEN controls table to a panel object.\n\nYou can do this manually using file.Read and util.JSONToTable to import and create a GWEN table structure from a `.gwen` file. This method can then be called, passing the GWEN table's `Controls` member.",
		"prefix": "ApplyGWEN"
	},
	"Panel:Center": {
		"body": [
			"Center()$0"
		],
		"description": "Centers the panel on its parent.",
		"prefix": "Center"
	},
	"Panel:CenterHorizontal": {
		"body": [
			"CenterHorizontal(${1:fraction=0.5})$0"
		],
		"description": "Centers the panel horizontally with specified fraction.",
		"prefix": "CenterHorizontal"
	},
	"Panel:CenterVertical": {
		"body": [
			"CenterVertical(${1:fraction=0.5})$0"
		],
		"description": "Centers the panel vertically with specified fraction.",
		"prefix": "CenterVertical"
	},
	"Panel:ChildCount": {
		"body": [
			"ChildCount()$0"
		],
		"description": "Returns the amount of children of the of panel.",
		"prefix": "ChildCount"
	},
	"Panel:ChildrenSize": {
		"body": [
			"ChildrenSize()$0"
		],
		"description": "Returns the width and height of the space between the position of the panel (upper-left corner) and the max bound of the children panels (farthest reaching lower-right corner).",
		"prefix": "ChildrenSize"
	},
	"Panel:Clear": {
		"body": [
			"Clear()$0"
		],
		"description": "Marks all of the panel's children for deletion.",
		"prefix": "Clear"
	},
	"Panel:ColorTo": {
		"body": [
			"ColorTo(${1:color}, ${2:length}, ${3:delay}, ${4:callback})$0"
		],
		"description": "Fades panels color to specified one. It won't work unless panel has SetColor function.",
		"prefix": "ColorTo"
	},
	"Panel:Command": {
		"body": [
			"Command(${1:command})$0"
		],
		"description": "Sends an action command signal to the panel. The response is handled by PANEL:ActionSignal.",
		"prefix": "Command"
	},
	"Panel:ConVarChanged": {
		"body": [
			"ConVarChanged(${1:newValue})$0"
		],
		"description": "Updates a panel object's associated console variable. This must first be set up with Global.Derma_Install_Convar_Functions, and have a ConVar set using Panel:SetConVar.",
		"prefix": "ConVarChanged"
	},
	"Panel:ConVarNumberThink": {
		"body": [
			"ConVarNumberThink()$0"
		],
		"description": "A think hook for Panels using ConVars as a value. Call it in the Think hook. Sets the panel's value should the convar change.\n\nThis function is best for: checkboxes, sliders, number wangs\n\nFor a string alternative, see Panel:ConVarStringThink.\n\n`Important`: Make sure your Panel has a SetValue function, else you may get errors.",
		"prefix": "ConVarNumberThink"
	},
	"Panel:ConVarStringThink": {
		"body": [
			"ConVarStringThink()$0"
		],
		"description": "A think hook for Panel using ConVars as a value. Call it in the Think hook. Sets the panel's value should the convar change.\n\nThis function is best for: text inputs, read-only inputs, dropdown selects\n\nFor a number alternative, see Panel:ConVarNumberThink.\n\n`Important`: Make sure your Panel has a SetValue function, else you may get errors.",
		"prefix": "ConVarStringThink"
	},
	"Panel:CopyBase": {
		"body": [
			"CopyBase(${1:srcPanel})$0"
		],
		"description": "Gets the size, position and dock state of the passed panel object, and applies it to this one.",
		"prefix": "CopyBase"
	},
	"Panel:CopyBounds": {
		"body": [
			"CopyBounds(${1:base})$0"
		],
		"description": "Copies position and size of the panel.",
		"prefix": "CopyBounds"
	},
	"Panel:CopyHeight": {
		"body": [
			"CopyHeight(${1:base})$0"
		],
		"description": "Copies the height of the panel.",
		"prefix": "CopyHeight"
	},
	"Panel:CopyPos": {
		"body": [
			"CopyPos(${1:base})$0"
		],
		"description": "Copies the position of the panel.",
		"prefix": "CopyPos"
	},
	"Panel:CopySelected": {
		"body": [
			"CopySelected()$0"
		],
		"description": "Performs the \"CONTROL + C\" key combination effect ( Copy selection to clipboard ) on selected text.",
		"prefix": "CopySelected"
	},
	"Panel:CopyWidth": {
		"body": [
			"CopyWidth(${1:base})$0"
		],
		"description": "Copies the width of the panel.",
		"prefix": "CopyWidth"
	},
	"Panel:CursorPos": {
		"body": [
			"CursorPos()$0"
		],
		"description": "Returns the cursor position relative to the top left of the panel.\n\nThis is equivalent to calling gui.MousePos and then Panel:ScreenToLocal.\n\nThis function uses a cached value for the screen position of the panel, computed at the end of the last VGUI Think/Layout pass.\n\nie. inaccurate results may be returned if the panel or any of its ancestors have been repositioned outside of PANEL:Think or PANEL:PerformLayout within the last frame.",
		"prefix": "CursorPos"
	},
	"Panel:CutSelected": {
		"body": [
			"CutSelected()$0"
		],
		"description": "Performs the \"CONTROL + X\" ( delete text and copy it to clipboard buffer ) action on selected text.",
		"prefix": "CutSelected"
	},
	"Panel:DeleteCookie": {
		"body": [
			"DeleteCookie(${1:cookieName})$0"
		],
		"description": "Deletes a cookie value using the panel's cookie name ( Panel:GetCookieName ) and the passed extension.",
		"prefix": "DeleteCookie"
	},
	"Panel:DisableLerp": {
		"body": [
			"DisableLerp()$0"
		],
		"description": "Resets the panel object's Panel:SetPos method and removes its animation table (`Panel.LerpAnim`). This effectively undoes the changes made by Panel:LerpPositions.\n\nIn order to use Lerp animation again, you must call Panel:Stop before setting its `SetPosReal` property to 'nil'. See the example below.",
		"prefix": "DisableLerp"
	},
	"Panel:Distance": {
		"body": [
			"Distance(${1:tgtPanel})$0"
		],
		"description": "Returns the linear distance from the center of this panel object and another. **Both panels must have the same parent for this function to work properly.**",
		"prefix": "Distance"
	},
	"Panel:DistanceFrom": {
		"body": [
			"DistanceFrom(${1:posX}, ${2:posY})$0"
		],
		"description": "Returns the distance between the center of this panel object and a specified point **local to the parent panel**.",
		"prefix": "DistanceFrom"
	},
	"Panel:DoModal": {
		"body": [
			"DoModal()$0"
		],
		"description": "Makes the panel \"lock\" the screen until it is removed. All input will be directed to the given panel.\n\nIt will silently fail if used while cursor is not visible.\nCall Panel:MakePopup before calling this function.\nThis must be called on a panel derived from EditablePanel.\n\n\nYou can still click in the world even if locked.",
		"prefix": "DoModal"
	},
	"Panel:Dock": {
		"body": [
			"Dock(${1:dockType})$0"
		],
		"description": "Sets the dock type for the panel, making the panel \"dock\" in a certain direction, modifying it's position and size.\n\nYou can set the inner spacing of a panel's docking using Panel:DockPadding, which will affect docked child panels, and you can set the outer spacing of a panel's docking using Panel:DockMargin, which affects how docked siblings are positioned/sized.\n\nAfter using this function, if you want to get the correct panel's bounds (position, size), use Panel:InvalidateParent (use `true` as argument if you need to update immediately)",
		"prefix": "Dock"
	},
	"Panel:DockMargin": {
		"body": [
			"DockMargin(${1:marginLeft}, ${2:marginTop}, ${3:marginRight}, ${4:marginBottom})$0"
		],
		"description": "Sets the dock margin of the panel.\n\nThe dock margin is the extra space that will be left around the edge when this element is docked inside its parent element.",
		"prefix": "DockMargin"
	},
	"Panel:DockPadding": {
		"body": [
			"DockPadding(${1:paddingLeft}, ${2:paddingTop}, ${3:paddingRight}, ${4:paddingBottom})$0"
		],
		"description": "Sets the dock padding of the panel.\n\nThe dock padding is the extra space that will be left around the edge when child elements are docked inside this element.",
		"prefix": "DockPadding"
	},
	"Panel:DragClick": {
		"body": [
			"DragClick()$0"
		],
		"description": " Called by Panel:DragMouseRelease when a user clicks one mouse button whilst dragging with another.",
		"prefix": "DragClick"
	},
	"Panel:DragHover": {
		"body": [
			"DragHover(${1:HoverTime})$0"
		],
		"description": " Called by dragndrop.HoverThink to perform actions on an object that is dragged and hovered over another.",
		"prefix": "DragHover"
	},
	"Panel:DragHoverEnd": {
		"body": [
			"DragHoverEnd()$0"
		],
		"description": " Called to end a drag and hover action. This resets the panel's PANEL:PaintOver method, and is primarily used by dragndrop.StopDragging.",
		"prefix": "DragHoverEnd"
	},
	"Panel:DragMousePress": {
		"body": [
			"DragMousePress(${1:mouseCode})$0"
		],
		"description": "Called to inform the dragndrop that a mouse button is being held down on a panel object.",
		"prefix": "DragMousePress"
	},
	"Panel:DragMouseRelease": {
		"body": [
			"DragMouseRelease(${1:mouseCode})$0"
		],
		"description": "Called to inform the dragndrop that a mouse button has been depressed on a panel object.",
		"prefix": "DragMouseRelease"
	},
	"Panel:DrawDragHover": {
		"body": [
			"DrawDragHover(${1:x}, ${2:y}, ${3:width}, ${4:height})$0"
		],
		"description": " Called to draw the drop target when an object is being dragged across another. See Panel:SetDropTarget.",
		"prefix": "DrawDragHover"
	},
	"Panel:DrawFilledRect": {
		"body": [
			"DrawFilledRect()$0"
		],
		"description": "Draws a coloured rectangle to fill the panel object this method is called on. The colour is set using surface.SetDrawColor. This should only be called within the object's PANEL:Paint or PANEL:PaintOver hooks, as a shortcut for surface.DrawRect.",
		"prefix": "DrawFilledRect"
	},
	"Panel:DrawOutlinedRect": {
		"body": [
			"DrawOutlinedRect()$0"
		],
		"description": "Draws a hollow rectangle the size of the panel object this method is called on, with a border width of 1 px. The border colour is set using surface.SetDrawColor. This should only be called within the object's PANEL:Paint or PANEL:PaintOver hooks, as a shortcut for surface.DrawOutlinedRect.",
		"prefix": "DrawOutlinedRect"
	},
	"Panel:DrawSelections": {
		"body": [
			"DrawSelections()$0"
		],
		"description": "Used to draw the magenta highlight colour of a panel object when it is selected. This should be called in the object's PANEL:PaintOver hook. Once this is implemented, the highlight colour will be displayed only when the object is selectable and selected. This is achieved using Panel:SetSelectable and Panel:SetSelected respectively.",
		"prefix": "DrawSelections"
	},
	"Panel:DrawTextEntryText": {
		"body": [
			"DrawTextEntryText(${1:textCol}, ${2:highlightCol}, ${3:cursorCol})$0"
		],
		"description": "Used to draw the text in a DTextEntry within a derma skin. This should be called within the SKIN:PaintTextEntry skin hook.\nWill silently fail if any of arguments are not Color.",
		"prefix": "DrawTextEntryText"
	},
	"Panel:DrawTexturedRect": {
		"body": [
			"DrawTexturedRect()$0"
		],
		"description": "Draws a textured rectangle to fill the panel object this method is called on. The texture is set using surface.SetTexture or surface.SetMaterial. This should only be called within the object's PANEL:Paint or PANEL:PaintOver hooks, as a shortcut for surface.DrawTexturedRect.",
		"prefix": "DrawTexturedRect"
	},
	"Panel:Droppable": {
		"body": [
			"Droppable(${1:name})$0"
		],
		"description": "Makes this panel droppable. This is used with Panel:Receiver to create drag and drop events.\n\nCan be called multiple times with different names allowing to be dropped onto different receivers.",
		"prefix": "Droppable"
	},
	"Panel:EndBoxSelection": {
		"body": [
			"EndBoxSelection()$0"
		],
		"description": "Completes a box selection. If the end point of the selection box is within the selection canvas, mouse capture is disabled for the panel object, and the selected state of each child object within the selection box is toggled.",
		"prefix": "EndBoxSelection"
	},
	"Panel:Exec": {
		"body": [
			"Exec(${1:cmd})$0"
		],
		"description": " Used to run commands within a DHTML window.",
		"prefix": "Exec"
	},
	"Panel:Find": {
		"body": [
			"Find(${1:panelName})$0"
		],
		"description": "Finds a panel in its children(and sub children) with the given name.",
		"prefix": "Find"
	},
	"Panel:FocusNext": {
		"body": [
			"FocusNext()$0"
		],
		"description": "Focuses the next panel in the focus queue.",
		"prefix": "FocusNext"
	},
	"Panel:FocusPrevious": {
		"body": [
			"FocusPrevious()$0"
		],
		"description": "Focuses the previous panel in the focus queue.",
		"prefix": "FocusPrevious"
	},
	"Panel:GWEN_SetCheckboxText": {
		"body": [
			"GWEN_SetCheckboxText(${1:txt})$0"
		],
		"description": " Used by Panel:ApplyGWEN to apply the `CheckboxText` property to a DCheckBoxLabel. This does exactly the same as Panel:GWEN_SetText, but exists to cater for the seperate GWEN properties.",
		"prefix": "GWEN_SetCheckboxText"
	},
	"Panel:GWEN_SetControlName": {
		"body": [
			"GWEN_SetControlName(${1:name})$0"
		],
		"description": " Used by Panel:ApplyGWEN to apply the `ControlName` property to a panel. This calls Panel:SetName.",
		"prefix": "GWEN_SetControlName"
	},
	"Panel:GWEN_SetDock": {
		"body": [
			"GWEN_SetDock(${1:dockState})$0"
		],
		"description": " Used by Panel:ApplyGWEN to apply the `Dock` property to a  panel object. This calls Panel:Dock.",
		"prefix": "GWEN_SetDock"
	},
	"Panel:GWEN_SetHorizontalAlign": {
		"body": [
			"GWEN_SetHorizontalAlign(${1:hAlign})$0"
		],
		"description": " Used by Panel:ApplyGWEN to apply the `HorizontalAlign` property to a  panel object. This calls Panel:SetContentAlignment.",
		"prefix": "GWEN_SetHorizontalAlign"
	},
	"Panel:GWEN_SetMargin": {
		"body": [
			"GWEN_SetMargin(${1:margins})$0"
		],
		"description": " Used by Panel:ApplyGWEN to apply the `Margin` property to a  panel object. This calls Panel:DockMargin.",
		"prefix": "GWEN_SetMargin"
	},
	"Panel:GWEN_SetMax": {
		"body": [
			"GWEN_SetMax(${1:maxValue})$0"
		],
		"description": " Used by Panel:ApplyGWEN to apply the `Max` property to a  DNumberWang, Slider, DNumSlider or DNumberScratch. This calls `SetMax` on one of the previously listed methods.",
		"prefix": "GWEN_SetMax"
	},
	"Panel:GWEN_SetMin": {
		"body": [
			"GWEN_SetMin(${1:minValue})$0"
		],
		"description": " Used by Panel:ApplyGWEN to apply the `Min` property to a  DNumberWang, Slider, DNumSlider or DNumberScratch. This calls `SetMin` on one of the previously listed methods.",
		"prefix": "GWEN_SetMin"
	},
	"Panel:GWEN_SetPosition": {
		"body": [
			"GWEN_SetPosition(${1:pos})$0"
		],
		"description": " Used by Panel:ApplyGWEN to apply the `Position` property to a  panel object. This calls Panel:SetPos.",
		"prefix": "GWEN_SetPosition"
	},
	"Panel:GWEN_SetSize": {
		"body": [
			"GWEN_SetSize(${1:size})$0"
		],
		"description": " Used by Panel:ApplyGWEN to apply the `Size` property to a  panel object. This calls Panel:SetSize.",
		"prefix": "GWEN_SetSize"
	},
	"Panel:GWEN_SetText": {
		"body": [
			"GWEN_SetText(${1:txt})$0"
		],
		"description": " Used by Panel:ApplyGWEN to apply the `Text` property to a panel.",
		"prefix": "GWEN_SetText"
	},
	"Panel:GetAlpha": {
		"body": [
			"GetAlpha()$0"
		],
		"description": "Returns the alpha multiplier for this panel.",
		"prefix": "GetAlpha"
	},
	"Panel:GetBGColor": {
		"body": [
			"GetBGColor()$0"
		],
		"description": "Returns the background color of a panel such as a RichText, Label or DColorCube.\n\nThis doesn't apply to all VGUI elements and its function varies between them",
		"prefix": "GetBGColor"
	},
	"Panel:GetBounds": {
		"body": [
			"GetBounds()$0"
		],
		"description": "Returns the position and size of the panel.\n\nThis is equivalent to calling Panel:GetPos and Panel:GetSize together.",
		"prefix": "GetBounds"
	},
	"Panel:GetCaretPos": {
		"body": [
			"GetCaretPos()$0"
		],
		"description": "Returns the position/offset of the caret (or text cursor) in a text-based panel object.",
		"prefix": "GetCaretPos"
	},
	"Panel:GetChild": {
		"body": [
			"GetChild(${1:childIndex})$0"
		],
		"description": "Gets a child by its index.",
		"prefix": "GetChild"
	},
	"Panel:GetChildPosition": {
		"body": [
			"GetChildPosition(${1:pnl})$0"
		],
		"description": "Gets a child object's position relative to this panel object. The number of levels is not relevant; the child may have many parents between itself and the object on which the method is called.",
		"prefix": "GetChildPosition"
	},
	"Panel:GetChildren": {
		"body": [
			"GetChildren()$0"
		],
		"description": "Returns a table with all the child panels of the panel.",
		"prefix": "GetChildren"
	},
	"Panel:GetChildrenInRect": {
		"body": [
			"GetChildrenInRect(${1:x}, ${2:y}, ${3:w}, ${4:h})$0"
		],
		"description": "Returns a table of all visible, selectable children of the panel object that lie at least partially within the specified rectangle.",
		"prefix": "GetChildrenInRect"
	},
	"Panel:GetClassName": {
		"body": [
			"GetClassName()$0"
		],
		"description": "Returns the class name of the panel.",
		"prefix": "GetClassName"
	},
	"Panel:GetClosestChild": {
		"body": [
			"GetClosestChild(${1:x}, ${2:y})$0"
		],
		"description": "Returns the child of this panel object that is closest to the specified point. The point is relative to the object on which the method is called. The distance the child is from this point is also returned.",
		"prefix": "GetClosestChild"
	},
	"Panel:GetContentSize": {
		"body": [
			"GetContentSize()$0"
		],
		"description": "Gets the size of the content/children within a panel object.\n\nOnly works with Label derived panels by default such as DLabel.\n\n\nWill also work on any panel that manually implements this method.",
		"prefix": "GetContentSize"
	},
	"Panel:GetCookie": {
		"body": [
			"GetCookie(${1:cookieName}, ${2:default})$0"
		],
		"description": "Gets the value of a cookie stored by the panel object. This can also be done with cookie.GetString, using the panel's cookie name, a fullstop, and then the actual name of the cookie.\n\nMake sure the panel's cookie name has not changed since writing, or the cookie will not be accessible. This can be done with Panel:GetCookieName and Panel:SetCookieName.",
		"prefix": "GetCookie"
	},
	"Panel:GetCookieName": {
		"body": [
			"GetCookieName()$0"
		],
		"description": "Gets the name the panel uses to store cookies. This is set with Panel:SetCookieName.",
		"prefix": "GetCookieName"
	},
	"Panel:GetCookieNumber": {
		"body": [
			"GetCookieNumber(${1:cookieName}, ${2:default})$0"
		],
		"description": "Gets the value of a cookie stored by the panel object, as a number. This can also be done with cookie.GetNumber, using the panel's cookie name, a fullstop, and then the actual name of the cookie.\n\nMake sure the panel's cookie name has not changed since writing, or the cookie will not be accessible. This can be done with Panel:GetCookieName and Panel:SetCookieName.",
		"prefix": "GetCookieNumber"
	},
	"Panel:GetDock": {
		"body": [
			"GetDock()$0"
		],
		"description": "Returns a dock enum for the panel's current docking type.",
		"prefix": "GetDock"
	},
	"Panel:GetDockMargin": {
		"body": [
			"GetDockMargin()$0"
		],
		"description": "Returns the docked margins of the panel. (set by Panel:DockMargin)",
		"prefix": "GetDockMargin"
	},
	"Panel:GetDockPadding": {
		"body": [
			"GetDockPadding()$0"
		],
		"description": "Returns the docked padding of the panel. (set by Panel:DockPadding)",
		"prefix": "GetDockPadding"
	},
	"Panel:GetFGColor": {
		"body": [
			"GetFGColor()$0"
		],
		"description": "Returns the foreground color of the panel.\n\nFor a Label or RichText, this is the color of its text.\n\nThis doesn't apply to all VGUI elements (such as DLabel) and its function varies between them",
		"prefix": "GetFGColor"
	},
	"Panel:GetFont": {
		"body": [
			"GetFont()$0"
		],
		"description": "Returns the name of the font that the panel renders its text with.\n\nThis is the same font name set with Panel:SetFontInternal.",
		"prefix": "GetFont"
	},
	"Panel:GetHTMLMaterial": {
		"body": [
			"GetHTMLMaterial()$0"
		],
		"description": "Returns the panel's HTML material. Only works with Awesomium, HTML and DHTML panels that have been fully loaded.",
		"prefix": "GetHTMLMaterial"
	},
	"Panel:GetMaximumCharCount": {
		"body": [
			"GetMaximumCharCount()$0"
		],
		"description": "Returns the current maximum character count.\n\nThis function will only work on RichText and TextEntry panels and their derivatives.",
		"prefix": "GetMaximumCharCount"
	},
	"Panel:GetName": {
		"body": [
			"GetName()$0"
		],
		"description": "Returns the internal name of the panel.",
		"prefix": "GetName"
	},
	"Panel:GetNumLines": {
		"body": [
			"GetNumLines()$0"
		],
		"description": "Returns the number of lines in a RichText. You must wait a couple frames before calling this after using Panel:AppendText or Panel:SetText, otherwise it will return the number of text lines before the text change.\n\nEven though this function can be called on any panel, it will only work with RichText",
		"prefix": "GetNumLines"
	},
	"Panel:GetParent": {
		"body": [
			"GetParent()$0"
		],
		"description": "Returns the parent of the panel, returns nil if there is no parent.",
		"prefix": "GetParent"
	},
	"Panel:GetPos": {
		"body": [
			"GetPos()$0"
		],
		"description": "Returns the position of the panel relative to its Panel:GetParent.\n\nIf you require the panel's position **and** size, consider using Panel:GetBounds instead.\n\n\nIf you need the position in screen space, see Panel:LocalToScreen.",
		"prefix": "GetPos"
	},
	"Panel:GetSelectedChildren": {
		"body": [
			"GetSelectedChildren()$0"
		],
		"description": "Returns a table of all children of the panel object that are selected. This is recursive, and the returned table will include tables for any child objects that also have children. This means that not all first-level members in the returned table will be of type Panel.",
		"prefix": "GetSelectedChildren"
	},
	"Panel:GetSelectedTextRange": {
		"body": [
			"GetSelectedTextRange()$0"
		],
		"description": "Returns the currently selected range of text.\n\nThis function will only work on RichText and TextEntry panels and their derivatives.",
		"prefix": "GetSelectedTextRange"
	},
	"Panel:GetSelectionCanvas": {
		"body": [
			"GetSelectionCanvas()$0"
		],
		"description": "Returns the panel object (`self`) if it has been enabled as a selection canvas. This is achieved using Panel:SetSelectionCanvas.",
		"prefix": "GetSelectionCanvas"
	},
	"Panel:GetSize": {
		"body": [
			"GetSize()$0"
		],
		"description": "Returns the size of the panel.\n\nIf you require both the panel's position and size, consider using Panel:GetBounds instead.",
		"prefix": "GetSize"
	},
	"Panel:GetSkin": {
		"body": [
			"GetSkin()$0"
		],
		"description": "Returns the table for the derma skin currently being used by this panel object.",
		"prefix": "GetSkin"
	},
	"Panel:GetTable": {
		"body": [
			"GetTable()$0"
		],
		"description": "Returns the internal Lua table of the panel.",
		"prefix": "GetTable"
	},
	"Panel:GetTall": {
		"body": [
			"GetTall()$0"
		],
		"description": "Returns the height of the panel.",
		"prefix": "GetTall"
	},
	"Panel:GetText": {
		"body": [
			"GetText()$0"
		],
		"description": "Returns the panel's text (where applicable).\n\nThis method returns a maximum of 1023 bytes, except for DTextEntry.",
		"prefix": "GetText"
	},
	"Panel:GetTextInset": {
		"body": [
			"GetTextInset()$0"
		],
		"description": "Gets the left and top text margins of a text-based panel object, such as a DButton or DLabel. This is set with Panel:SetTextInset.",
		"prefix": "GetTextInset"
	},
	"Panel:GetTextSize": {
		"body": [
			"GetTextSize()$0"
		],
		"description": "Gets the size of the text within a Label derived panel.\n\nThis can return 0 incorrectly.",
		"prefix": "GetTextSize"
	},
	"Panel:GetValidReceiverSlot": {
		"body": [
			"GetValidReceiverSlot()$0"
		],
		"description": "Gets valid receiver slot of currently dragged panel.",
		"prefix": "GetValidReceiverSlot"
	},
	"Panel:GetValue": {
		"body": [
			"GetValue()$0"
		],
		"description": "Returns the value the panel holds.\n\nIn engine is only implemented for CheckButton, Label and TextEntry as a string.\n\nThis function is limited to 8092 Bytes. If using DTextEntry, use Panel:GetText for unlimited bytes.",
		"prefix": "GetValue"
	},
	"Panel:GetWide": {
		"body": [
			"GetWide()$0"
		],
		"description": "Returns the width of the panel.",
		"prefix": "GetWide"
	},
	"Panel:GetZPos": {
		"body": [
			"GetZPos()$0"
		],
		"description": "Returns the Z position of the panel.",
		"prefix": "GetZPos"
	},
	"Panel:GoBack": {
		"body": [
			"GoBack()$0"
		],
		"description": "Goes back one page in the HTML panel's history if available.",
		"prefix": "GoBack"
	},
	"Panel:GoForward": {
		"body": [
			"GoForward()$0"
		],
		"description": "Goes forward one page in the HTML panel's history if available.",
		"prefix": "GoForward"
	},
	"Panel:GoToHistoryOffset": {
		"body": [
			"GoToHistoryOffset(${1:offset})$0"
		],
		"description": "Goes to the page in the HTML panel's history at the specified relative offset.",
		"prefix": "GoToHistoryOffset"
	},
	"Panel:GotoTextEnd": {
		"body": [
			"GotoTextEnd()$0"
		],
		"description": "Causes a RichText element to scroll to the bottom of its text.",
		"prefix": "GotoTextEnd"
	},
	"Panel:GotoTextStart": {
		"body": [
			"GotoTextStart()$0"
		],
		"description": "Causes a RichText element to scroll to the top of its text.\n\nThis does not work on the same frame as Panel:SetText.",
		"prefix": "GotoTextStart"
	},
	"Panel:HasChildren": {
		"body": [
			"HasChildren()$0"
		],
		"description": "Returns whenever the panel has child panels.",
		"prefix": "HasChildren"
	},
	"Panel:HasFocus": {
		"body": [
			"HasFocus()$0"
		],
		"description": "Returns if the panel is focused.",
		"prefix": "HasFocus"
	},
	"Panel:HasHierarchicalFocus": {
		"body": [
			"HasHierarchicalFocus()$0"
		],
		"description": "Returns if the panel or any of its children(sub children and so on) has the focus.",
		"prefix": "HasHierarchicalFocus"
	},
	"Panel:HasParent": {
		"body": [
			"HasParent(${1:parentPanel})$0"
		],
		"description": "Returns whether the panel is a descendent of the given panel.",
		"prefix": "HasParent"
	},
	"Panel:Hide": {
		"body": [
			"Hide()$0"
		],
		"description": "Makes a panel invisible.",
		"prefix": "Hide"
	},
	"Panel:InsertClickableTextEnd": {
		"body": [
			"InsertClickableTextEnd()$0"
		],
		"description": "Marks the end of a clickable text segment in a RichText element, started with Panel:InsertClickableTextStart.",
		"prefix": "InsertClickableTextEnd"
	},
	"Panel:InsertClickableTextStart": {
		"body": [
			"InsertClickableTextStart(${1:signalValue})$0"
		],
		"description": "Starts the insertion of clickable text for a RichText element. Any text appended with Panel:AppendText between this call and Panel:InsertClickableTextEnd will become clickable text.\n\nThe hook PANEL:ActionSignal is called when the text is clicked, with \"TextClicked\" as the signal name and `signalValue` as the signal value.\n\nThe clickable text is a separate Derma panel which will not inherit the current font from the `RichText`.",
		"prefix": "InsertClickableTextStart"
	},
	"Panel:InsertColorChange": {
		"body": [
			"InsertColorChange(${1:r}, ${2:g}, ${3:b}, ${4:a})$0"
		],
		"description": "Inserts a color change in a RichText element, which affects the color of all text added with Panel:AppendText until another color change is applied.",
		"prefix": "InsertColorChange"
	},
	"Panel:InsertFade": {
		"body": [
			"InsertFade(${1:sustain}, ${2:length})$0"
		],
		"description": "Begins a text fade for a RichText element where the last appended text segment is fully faded out after a specific amount of time, at a specific speed.\n\nThe alpha of the text at any given time is determined by the text's base alpha * ((`sustain` - Global.CurTime) / `length`) where Global.CurTime is added to `sustain` when this method is called.",
		"prefix": "InsertFade"
	},
	"Panel:InvalidateChildren": {
		"body": [
			"InvalidateChildren(${1:recursive=false})$0"
		],
		"description": "Invalidates the layout of this panel object and all its children. This will cause these objects to re-layout immediately, calling PANEL:PerformLayout. If you want to perform the layout in the next frame, you will have loop manually through all children, and call Panel:InvalidateLayout on each.",
		"prefix": "InvalidateChildren"
	},
	"Panel:InvalidateLayout": {
		"body": [
			"InvalidateLayout(${1:layoutNow=false})$0"
		],
		"description": "Causes the panel to re-layout in the next frame. During the layout process  PANEL:PerformLayout will be called on the target panel.\n\nYou should avoid calling this function every frame.\n\nUsing this on a panel after clicking on a docked element will cause docked elements to reorient themselves incorrectly. This can be fixed by assigning a unique Panel:SetZPos to each docked element.",
		"prefix": "InvalidateLayout"
	},
	"Panel:InvalidateParent": {
		"body": [
			"InvalidateParent(${1:layoutNow=false})$0"
		],
		"description": "Invalidates the layout of the parent of this panel object. This will cause it to re-layout, calling PANEL:PerformLayout.",
		"prefix": "InvalidateParent"
	},
	"Panel:IsChildHovered": {
		"body": [
			"IsChildHovered(${1:immediate=false})$0"
		],
		"description": "Determines whether the mouse cursor is hovered over one of this panel object's children. This is a reverse process using vgui.GetHoveredPanel, and looks upward to find the parent.",
		"prefix": "IsChildHovered"
	},
	"Panel:IsDraggable": {
		"body": [
			"IsDraggable()$0"
		],
		"description": "Returns whether this panel is draggable ( if user is able to drag it ) or not.",
		"prefix": "IsDraggable"
	},
	"Panel:IsDragging": {
		"body": [
			"IsDragging()$0"
		],
		"description": "Returns whether this panel is currently being dragged or not.",
		"prefix": "IsDragging"
	},
	"Panel:IsEnabled": {
		"body": [
			"IsEnabled()$0"
		],
		"description": "Returns whether the the panel is enabled or disabled.\n\nSee Panel:SetEnabled for a function that makes the panel enabled or disabled.",
		"prefix": "IsEnabled"
	},
	"Panel:IsHovered": {
		"body": [
			"IsHovered()$0"
		],
		"description": "Returns whether the mouse cursor is hovering over this panel or not\n\nUses vgui.GetHoveredPanel internally.\n\nRequires Panel:SetMouseInputEnabled to be set to true.",
		"prefix": "IsHovered"
	},
	"Panel:IsKeyboardInputEnabled": {
		"body": [
			"IsKeyboardInputEnabled()$0"
		],
		"description": "Returns true if the panel can receive keyboard input.",
		"prefix": "IsKeyboardInputEnabled"
	},
	"Panel:IsLoading": {
		"body": [
			"IsLoading()$0"
		],
		"description": "Determines whether or not a HTML or DHTML element is currently loading a page.\n\nBefore calling Panel:SetHTML or DHTML:OpenURL, the result seems to be `false` with the Awesomium web renderer and `true` for the Chromium web renderer. This difference can be used to determine the available HTML5 capabilities.\nOn Awesomium, the result remains `true` until the root document is loaded and when in-page content is loading (when adding pictures, frames, etc.). During this state, the HTML texture is not refreshed and the panel is not painted (it becomes invisible).\n\nOn Chromium, the value is only `true` when the root document is not ready. The rendering is not suspended when in-page elements are loading.",
		"prefix": "IsLoading"
	},
	"Panel:IsMarkedForDeletion": {
		"body": [
			"IsMarkedForDeletion()$0"
		],
		"description": "Returns if the panel is going to be deleted in the next frame.",
		"prefix": "IsMarkedForDeletion"
	},
	"Panel:IsMouseInputEnabled": {
		"body": [
			"IsMouseInputEnabled()$0"
		],
		"description": "Returns true if the panel can receive mouse input.",
		"prefix": "IsMouseInputEnabled"
	},
	"Panel:IsOurChild": {
		"body": [
			"IsOurChild(${1:childPanel})$0"
		],
		"description": "Returns whether the panel contains the given panel, recursively.",
		"prefix": "IsOurChild"
	},
	"Panel:IsSelectable": {
		"body": [
			"IsSelectable()$0"
		],
		"description": "Determines if the panel object is selectable (like icons in the Spawn Menu, holding Shift). This is set with Panel:SetSelectable.",
		"prefix": "IsSelectable"
	},
	"Panel:IsSelected": {
		"body": [
			"IsSelected()$0"
		],
		"description": "Returns if the panel object is selected (like icons in the Spawn Menu, holding Shift). This can be set in Lua using Panel:SetSelected.",
		"prefix": "IsSelected"
	},
	"Panel:IsSelectionCanvas": {
		"body": [
			"IsSelectionCanvas()$0"
		],
		"description": "Determines if the panel object is a selection canvas or not. This is set with Panel:SetSelectionCanvas.",
		"prefix": "IsSelectionCanvas"
	},
	"Panel:IsValid": {
		"body": [
			"IsValid()$0"
		],
		"description": "Returns if the panel is valid and not marked for deletion.",
		"prefix": "IsValid"
	},
	"Panel:IsVisible": {
		"body": [
			"IsVisible()$0"
		],
		"description": "Returns if the panel is visible.",
		"prefix": "IsVisible"
	},
	"Panel:IsWorldClicker": {
		"body": [
			"IsWorldClicker()$0"
		],
		"description": "Returns if a panel allows world clicking set by Panel:SetWorldClicker.",
		"prefix": "IsWorldClicker"
	},
	"Panel:KillFocus": {
		"body": [
			"KillFocus()$0"
		],
		"description": "Remove the focus from the panel.",
		"prefix": "KillFocus"
	},
	"Panel:LerpPositions": {
		"body": [
			"LerpPositions(${1:speed}, ${2:easeOut})$0"
		],
		"description": "Redefines the panel object's Panel:SetPos method to operate using frame-by-frame linear interpolation (Lerp). When the panel's position is changed, it will move to the target position at the speed defined. You can undo this with Panel:DisableLerp.\n\nUnlike the other panel animation functions, such as Panel:MoveTo, this animation method will not operate whilst the game is paused. This is because it relies on Global.FrameTime.",
		"prefix": "LerpPositions"
	},
	"Panel:LoadControlsFromFile": {
		"body": [
			"LoadControlsFromFile(${1:path})$0"
		],
		"description": "\n\nSimilar to Panel:LoadControlsFromString but loads controls from a file.",
		"prefix": "LoadControlsFromFile"
	},
	"Panel:LoadControlsFromString": {
		"body": [
			"LoadControlsFromString(${1:data})$0"
		],
		"description": "\n\nLoads controls(positions, etc) from given data. This is what the default options menu uses.",
		"prefix": "LoadControlsFromString"
	},
	"Panel:LoadGWENFile": {
		"body": [
			"LoadGWENFile(${1:filename}, ${2:path=GAME})$0"
		],
		"description": "Loads a .gwen file (created by GWEN Designer) and calls Panel:LoadGWENString with the contents of the loaded file.\n\nUsed to load panel controls from a file.",
		"prefix": "LoadGWENFile"
	},
	"Panel:LoadGWENString": {
		"body": [
			"LoadGWENString(${1:str})$0"
		],
		"description": "Loads controls for the panel from a JSON string.",
		"prefix": "LoadGWENString"
	},
	"Panel:LocalCursorPos": {
		"body": [
			"LocalCursorPos()$0"
		],
		"description": "Returns the cursor position local to the position of the panel (usually the upper-left corner).",
		"prefix": "LocalCursorPos"
	},
	"Panel:LocalToScreen": {
		"body": [
			"LocalToScreen(${1:posX}, ${2:posY})$0"
		],
		"description": "Gets the absolute screen position of the position specified relative to the panel.\n\nSee also Panel:ScreenToLocal.\n\nThis function uses a cached value for the screen position of the panel, computed at the end of the last VGUI Think/Layout pass, so inaccurate results may be returned if the panel or any of its ancestors have been re-positioned outside of PANEL:Think or PANEL:PerformLayout within the last frame.\n\nIf the panel uses Panel:Dock, this function will return 0, 0 when the panel was created. The position will be updated in the next frame.",
		"prefix": "LocalToScreen"
	},
	"Panel:MakePopup": {
		"body": [
			"MakePopup()$0"
		],
		"description": "Focuses the panel and enables it to receive input.\n\nThis automatically calls Panel:SetMouseInputEnabled and Panel:SetKeyboardInputEnabled and sets them to `true`.\n\nPanels derived from Panel will not work properly with this function. Due to this, any children will not be intractable with keyboard. Derive from EditablePanel instead.\n\nFor non gui related mouse focus, you can use gui.EnableScreenClicker.",
		"prefix": "MakePopup"
	},
	"Panel:MouseCapture": {
		"body": [
			"MouseCapture(${1:doCapture})$0"
		],
		"description": "Allows the panel to receive mouse input even if the mouse cursor is outside the bounds of the panel.",
		"prefix": "MouseCapture"
	},
	"Panel:MoveAbove": {
		"body": [
			"MoveAbove(${1:panel}, ${2:offset=0})$0"
		],
		"description": "Places the panel above the passed panel with the specified offset.",
		"prefix": "MoveAbove"
	},
	"Panel:MoveBelow": {
		"body": [
			"MoveBelow(${1:panel}, ${2:offset=0})$0"
		],
		"description": "Places the panel below the passed panel with the specified offset.",
		"prefix": "MoveBelow"
	},
	"Panel:MoveBy": {
		"body": [
			"MoveBy(${1:moveX}, ${2:moveY}, ${3:time}, ${4:delay=0}, ${5:ease=-1}, ${6:callback=nil})$0"
		],
		"description": "Moves the panel by the specified coordinates using animation.",
		"prefix": "MoveBy"
	},
	"Panel:MoveLeftOf": {
		"body": [
			"MoveLeftOf(${1:panel}, ${2:offset=0})$0"
		],
		"description": "Places the panel left to the passed panel with the specified offset.",
		"prefix": "MoveLeftOf"
	},
	"Panel:MoveRightOf": {
		"body": [
			"MoveRightOf(${1:panel}, ${2:offset=0})$0"
		],
		"description": "Places the panel right to the passed panel with the specified offset.",
		"prefix": "MoveRightOf"
	},
	"Panel:MoveTo": {
		"body": [
			"MoveTo(${1:posX}, ${2:posY}, ${3:time}, ${4:delay=0}, ${5:ease=-1}, ${6:callback})$0"
		],
		"description": "Moves the panel to the specified position using animation.\nSetting the ease argument to 0 will result in the animation happening instantly, this applies to all MoveTo/SizeTo functions",
		"prefix": "MoveTo"
	},
	"Panel:MoveToAfter": {
		"body": [
			"MoveToAfter(${1:siblingPanel})$0"
		],
		"description": "Moves this panel object in front of the specified sibling (child of the same parent) in the render order, and shuffles up the Z-positions of siblings now behind.",
		"prefix": "MoveToAfter"
	},
	"Panel:MoveToBack": {
		"body": [
			"MoveToBack()$0"
		],
		"description": "Moves the panel object behind all other panels on screen. If the panel has been made a pop-up with Panel:MakePopup, it will still draw in front of any panels that haven't.",
		"prefix": "MoveToBack"
	},
	"Panel:MoveToBefore": {
		"body": [
			"MoveToBefore(${1:siblingPanel})$0"
		],
		"description": "Moves this panel object behind the specified sibling (child of the same parent) in the render order, and shuffles up the Panel:SetZPos of siblings now in front.",
		"prefix": "MoveToBefore"
	},
	"Panel:MoveToFront": {
		"body": [
			"MoveToFront()$0"
		],
		"description": "Moves the panel in front of all other panels on screen. Unless the panel has been made a pop-up using Panel:MakePopup, it will still draw behind any that have.",
		"prefix": "MoveToFront"
	},
	"Panel:NewAnimation": {
		"body": [
			"NewAnimation(${1:length}, ${2:delay=0}, ${3:ease=-1}, ${4:callback=nil})$0"
		],
		"description": "Creates a new animation for the panel object.\n\nMethods that use this function:\n* Panel:MoveTo\n* Panel:SizeTo\n* Panel:SlideUp\n* Panel:SlideDown\n* Panel:ColorTo\n* Panel:AlphaTo\n* Panel:MoveBy\n* Panel:LerpPositions",
		"prefix": "NewAnimation"
	},
	"Panel:NewObject": {
		"body": [
			"NewObject(${1:objectName})$0"
		],
		"description": "",
		"prefix": "NewObject"
	},
	"Panel:NewObjectCallback": {
		"body": [
			"NewObjectCallback(${1:objectName}, ${2:callbackName})$0"
		],
		"description": "",
		"prefix": "NewObjectCallback"
	},
	"Panel:NoClipping": {
		"body": [
			"NoClipping(${1:clip})$0"
		],
		"description": "Sets whether this panel's drawings should be clipped within the parent panel's bounds.\n\nSee also Global.DisableClipping.",
		"prefix": "NoClipping"
	},
	"Panel:NumSelectedChildren": {
		"body": [
			"NumSelectedChildren()$0"
		],
		"description": "Returns the number of children of the panel object that are selected. This is equivalent to calling Panel:IsSelected on all child objects and counting the number of returns that are `true`.",
		"prefix": "NumSelectedChildren"
	},
	"Panel:PaintAt": {
		"body": [
			"PaintAt(${1:posX}, ${2:posY})$0"
		],
		"description": "Paints a ghost copy of the panel at the given position.",
		"prefix": "PaintAt"
	},
	"Panel:PaintManual": {
		"body": [
			"PaintManual()$0"
		],
		"description": "Paints the panel at its current position. To use this you must call Panel:SetPaintedManually(true).",
		"prefix": "PaintManual"
	},
	"Panel:ParentToHUD": {
		"body": [
			"ParentToHUD()$0"
		],
		"description": "Parents the panel to the HUD.\nMakes it invisible on the escape-menu and disables controls.",
		"prefix": "ParentToHUD"
	},
	"Panel:Paste": {
		"body": [
			"Paste()$0"
		],
		"description": "Due to privacy concerns, this function has been disabled\n\nOnly works for TextEntries.\n\nPastes the contents of the clipboard into the TextEntry.\n\nTab characters will be dropped from the pasted text",
		"prefix": "Paste"
	},
	"Panel:PositionLabel": {
		"body": [
			"PositionLabel(${1:lblWidth}, ${2:x}, ${3:y}, ${4:lbl}, ${5:panelObj})$0"
		],
		"description": "Sets the width and position of a DLabel and places the passed panel object directly to the right of it. Returns the `y` value of the bottom of the tallest object. The panel on which this method is run is not relevant; only the passed objects are affected.",
		"prefix": "PositionLabel"
	},
	"Panel:PostMessage": {
		"body": [
			"PostMessage(${1:messageName}, ${2:valueType}, ${3:value})$0"
		],
		"description": "Only used in deprecated Derma controls.Sends a command to the panel.",
		"prefix": "PostMessage"
	},
	"Panel:Prepare": {
		"body": [
			"Prepare()$0"
		],
		"description": "\nInstalls Lua defined functions into the panel.",
		"prefix": "Prepare"
	},
	"Panel:Queue": {
		"body": [
			"Queue()$0"
		],
		"description": "Enables the queue for panel animations. If enabled, the next new animation will begin after all current animations have ended. This must be called before Panel:NewAnimation to work, and only applies to the next new animation. If you want to queue many, you must call this before each.",
		"prefix": "Queue"
	},
	"Panel:RebuildSpawnIcon": {
		"body": [
			"RebuildSpawnIcon()$0"
		],
		"description": "Causes a SpawnIcon to rebuild its model image.",
		"prefix": "RebuildSpawnIcon"
	},
	"Panel:RebuildSpawnIconEx": {
		"body": [
			"RebuildSpawnIconEx(${1:data})$0"
		],
		"description": "Re-renders a spawn icon with customized cam data.\n\nGlobal.PositionSpawnIcon can be used to easily calculate the necessary camera parameters.\n\nThis function does **not** accept the standard Structures/CamData.",
		"prefix": "RebuildSpawnIconEx"
	},
	"Panel:Receiver": {
		"body": [
			"Receiver(${1:name}, ${2:func}, ${3:menu})$0"
		],
		"description": "Allows the panel to receive drag and drop events. Can be called multiple times with different names to receive multiple different draggable panel events.",
		"prefix": "Receiver"
	},
	"Panel:Refresh": {
		"body": [
			"Refresh(${1:ignoreCache=false})$0"
		],
		"description": "Refreshes the HTML panel's current page.",
		"prefix": "Refresh"
	},
	"Panel:Remove": {
		"body": [
			"Remove()$0"
		],
		"description": "Marks a panel for deletion so it will be deleted on the next frame.\n\nThis will not mark child panels for deletion this frame, but they will be marked and deleted in the next frame.\n\nSee also Panel:IsMarkedForDeletion\n\nWill automatically call Panel:InvalidateParent.",
		"prefix": "Remove"
	},
	"Panel:RequestFocus": {
		"body": [
			"RequestFocus()$0"
		],
		"description": "Attempts to obtain focus for this panel.",
		"prefix": "RequestFocus"
	},
	"Panel:ResetAllFades": {
		"body": [
			"ResetAllFades(${1:hold}, ${2:expiredOnly}, ${3:newSustain})$0"
		],
		"description": "Resets all text fades in a RichText element made with Panel:InsertFade.",
		"prefix": "ResetAllFades"
	},
	"Panel:RunJavascript": {
		"body": [
			"RunJavascript(${1:js})$0"
		],
		"description": "Runs/Executes a string as JavaScript code in a panel.\nThis function does **NOT** evaluate expression (i.e. allow you to pass variables from JavaScript (JS) to Lua context).Because a return value is nil/no value (a.k.a. void).If you wish to pass/return values from JS to Lua, you may want to use DHTML:AddFunction function to accomplish that job.\nThe Awesomium web renderer automatically delays the code execution if the document is not ready, but the Chromium web renderer does not!\n\nThis means that with Chromium, you cannot JavaScript run code immediatly after calling Panel:SetHTML or DHTML:OpenURL. You should wait for the events PANEL:OnDocumentReady or PANEL:OnFinishLoadingDocument to be triggered before proceeding, otherwise you may manipulate an empty / incomplete document.",
		"prefix": "RunJavascript"
	},
	"Panel:SaveUndoState": {
		"body": [
			"SaveUndoState()$0"
		],
		"description": "Saves the current state (caret position and the text inside) of a TextEntry as an undo state.\n\nSee also Panel:Undo.",
		"prefix": "SaveUndoState"
	},
	"Panel:ScreenToLocal": {
		"body": [
			"ScreenToLocal(${1:screenX}, ${2:screenY})$0"
		],
		"description": "Translates global screen coordinate to coordinates relative to the panel.\n\nSee also Panel:LocalToScreen.\n\nThis function uses a cached value for the screen position of the panel, computed at the end of the last VGUI Think/Layout pass, so inaccurate results may be returned if the panel or any of its ancestors have been re-positioned outside of PANEL:Think or PANEL:PerformLayout within the last frame.",
		"prefix": "ScreenToLocal"
	},
	"Panel:SelectAll": {
		"body": [
			"SelectAll()$0"
		],
		"description": "Selects all items within a panel or object. For text-based objects, selects all text.",
		"prefix": "SelectAll"
	},
	"Panel:SelectAllOnFocus": {
		"body": [
			"SelectAllOnFocus()$0"
		],
		"description": "If called on a text entry, clicking the text entry for the first time will automatically select all of the text ready to be copied by the user.",
		"prefix": "SelectAllOnFocus"
	},
	"Panel:SelectAllText": {
		"body": [
			"SelectAllText()$0"
		],
		"description": "Selects all the text in a panel object. Will not select non-text items; for this, use Panel:SelectAll.",
		"prefix": "SelectAllText"
	},
	"Panel:SelectNone": {
		"body": [
			"SelectNone()$0"
		],
		"description": "Deselects all items in a panel object. For text-based objects, this will deselect all text.",
		"prefix": "SelectNone"
	},
	"Panel:SetAchievement": {
		"body": [
			"SetAchievement(${1:id})$0"
		],
		"description": "Sets the achievement to be displayed by AchievementIcon.",
		"prefix": "SetAchievement"
	},
	"Panel:SetActionFunction": {
		"body": [
			"SetActionFunction(${1:func})$0"
		],
		"description": "Does nothing at all.\n\nUsed in Button to call a function when the button is clicked and in Slider when the value changes.",
		"prefix": "SetActionFunction"
	},
	"Panel:SetAllowNonAsciiCharacters": {
		"body": [
			"SetAllowNonAsciiCharacters(${1:allowed})$0"
		],
		"description": "Configures a text input to allow user to type characters that are not included in the US-ASCII (7-bit ASCII) character set.\n\nCharacters not included in US-ASCII are multi-byte characters in UTF-8. They can be accented characters, non-Latin characters and special characters.",
		"prefix": "SetAllowNonAsciiCharacters"
	},
	"Panel:SetAlpha": {
		"body": [
			"SetAlpha(${1:alpha})$0"
		],
		"description": "Sets the alpha multiplier for the panel",
		"prefix": "SetAlpha"
	},
	"Panel:SetAnimationEnabled": {
		"body": [
			"SetAnimationEnabled(${1:enable})$0"
		],
		"description": "Enables or disables animations for the panel object by overriding the PANEL:AnimationThink hook to nil and back.",
		"prefix": "SetAnimationEnabled"
	},
	"Panel:SetAutoDelete": {
		"body": [
			"SetAutoDelete(${1:autoDelete})$0"
		],
		"description": "Sets whenever the panel should be removed if the parent was removed.",
		"prefix": "SetAutoDelete"
	},
	"Panel:SetBGColor": {
		"body": [
			"SetBGColor(${1:r or color}, ${2:g}, ${3:b}, ${4:a})$0"
		],
		"description": "Sets the background color of a panel such as a RichText, Label or DColorCube.\n\nThis doesn't apply to all VGUI elements and its function varies between them\n\nFor DLabel elements, you must use Panel:SetPaintBackgroundEnabled( true ) before applying the color.\n\nThis will not work on setup of the panel - you should use this function in a hook like PANEL:ApplySchemeSettings or PANEL:PerformLayout.",
		"prefix": "SetBGColor"
	},
	"Panel:SetBGColorEx": {
		"body": [
			"SetBGColorEx(${1:r}, ${2:g}, ${3:b}, ${4:a})$0"
		],
		"description": "Sets the background color of the panel.",
		"prefix": "SetBGColorEx"
	},
	"Panel:SetCaretPos": {
		"body": [
			"SetCaretPos(${1:offset})$0"
		],
		"description": "Sets the position of the caret (or text cursor) in a text-based panel object.",
		"prefix": "SetCaretPos"
	},
	"Panel:SetCommand": {
		"body": [
			"SetCommand()$0"
		],
		"description": "Sets the action signal command that's fired when a Button is clicked. The hook PANEL:ActionSignal is called as the click response.\n\nThis has no effect on buttons unless it has had its `AddActionSignalTarget` method called (an internal function not available by default in Garry's Mod LUA).\n\nA better alternative is calling Panel:Command when a DButton is clicked.",
		"prefix": "SetCommand"
	},
	"Panel:SetConVar": {
		"body": [
			"SetConVar(${1:convar})$0"
		],
		"description": "This function does not exist on all panels\nThis function cannot interact with serverside convars unless you are host\nBlocked convars will not work with this, see Blocked ConCommands\n\nSets this panel's convar. When the convar changes this panel will update automatically.\n\nFor developer implementation, see Global.Derma_Install_Convar_Functions.",
		"prefix": "SetConVar"
	},
	"Panel:SetContentAlignment": {
		"body": [
			"SetContentAlignment(${1:alignment})$0"
		],
		"description": "Sets the alignment of the contents.",
		"prefix": "SetContentAlignment"
	},
	"Panel:SetCookie": {
		"body": [
			"SetCookie(${1:cookieName}, ${2:value})$0"
		],
		"description": "Stores a string in the named cookie using Panel:GetCookieName as prefix.\n\nYou can also retrieve and modify this cookie by using the cookie. Cookies are stored in this format:\n\n```\npanelCookieName.cookieName\n```\n\n\nThe panel's cookie name MUST be set for this function to work. See Panel:SetCookieName.",
		"prefix": "SetCookie"
	},
	"Panel:SetCookieName": {
		"body": [
			"SetCookieName(${1:name})$0"
		],
		"description": "Sets the panel's cookie name. Calls PANEL:LoadCookies if defined.",
		"prefix": "SetCookieName"
	},
	"Panel:SetCursor": {
		"body": [
			"SetCursor(${1:cursor})$0"
		],
		"description": "Sets the appearance of the cursor. You can find a list of all available cursors with image previews [here](https://wiki.facepunch.com/gmod/Cursors).",
		"prefix": "SetCursor"
	},
	"Panel:SetDragParent": {
		"body": [
			"SetDragParent(${1:parent})$0"
		],
		"description": "Sets the drag parent.\n\nDrag parent means that when we start to drag this panel, we'll really start dragging the defined parent.",
		"prefix": "SetDragParent"
	},
	"Panel:SetDrawLanguageID": {
		"body": [
			"SetDrawLanguageID(${1:visible})$0"
		],
		"description": "Sets the visibility of the language selection box in a TextEntry when typing in non-English mode.\n\nSee Panel:SetDrawLanguageIDAtLeft for a function that changes the position of the language selection box.",
		"prefix": "SetDrawLanguageID"
	},
	"Panel:SetDrawLanguageIDAtLeft": {
		"body": [
			"SetDrawLanguageIDAtLeft(${1:left})$0"
		],
		"description": "Sets where to draw the language selection box.\n\nSee Panel:SetDrawLanguageID for a function that hides or shows the language selection box.",
		"prefix": "SetDrawLanguageIDAtLeft"
	},
	"Panel:SetDrawOnTop": {
		"body": [
			"SetDrawOnTop(${1:drawOnTop=false})$0"
		],
		"description": "Makes the panel render in front of all others, including the spawn menu and main menu.\n\nPriority is given based on the last call, so of two panels that call this method, the second will draw in front of the first.\n\nThis only makes the panel **draw** above other panels. If there's another panel that would have otherwise covered it, users will not be able to interact with it.\nThis does not work when using PANEL:SetPaintedManually or PANEL:PaintAt!",
		"prefix": "SetDrawOnTop"
	},
	"Panel:SetDropTarget": {
		"body": [
			"SetDropTarget(${1:x}, ${2:y}, ${3:width}, ${4:height})$0"
		],
		"description": "Sets the target area for dropping when an object is being dragged around this panel using the dragndrop.\n\nThis draws a target box of the specified size and position, until Panel:DragHoverEnd is called. It uses Panel:DrawDragHover to draw this area.",
		"prefix": "SetDropTarget"
	},
	"Panel:SetEnabled": {
		"body": [
			"SetEnabled(${1:enable})$0"
		],
		"description": "Sets the enabled state of a disable-able panel object, such as a DButton or DTextEntry.\n\nSee Panel:IsEnabled for a function that retrieves the \"enabled\" state of a panel.",
		"prefix": "SetEnabled"
	},
	"Panel:SetExpensiveShadow": {
		"body": [
			"SetExpensiveShadow(${1:distance}, ${2:Color})$0"
		],
		"description": "Adds a shadow falling to the bottom right corner of the panel's text. This has no effect on panels that do not derive from Label.",
		"prefix": "SetExpensiveShadow"
	},
	"Panel:SetFGColor": {
		"body": [
			"SetFGColor(${1:r or color}, ${2:g}, ${3:b}, ${4:a})$0"
		],
		"description": "Sets the foreground color of a panel.\n\nFor a Label or RichText, this is the color of its text.\n\nThis function calls Panel:SetFGColorEx internally.\n\nThis doesn't apply to all VGUI elements (such as DLabel) and its function varies between them",
		"prefix": "SetFGColor"
	},
	"Panel:SetFGColorEx": {
		"body": [
			"SetFGColorEx(${1:r}, ${2:g}, ${3:b}, ${4:a})$0"
		],
		"description": "Sets the foreground color of the panel.\n\nFor labels, this is the color of their text.",
		"prefix": "SetFGColorEx"
	},
	"Panel:SetFocusTopLevel": {
		"body": [
			"SetFocusTopLevel(${1:state})$0"
		],
		"description": "Sets the panel that owns this FocusNavGroup to be the root in the focus traversal hierarchy. This function will only work on EditablePanel class panels and its derivatives.",
		"prefix": "SetFocusTopLevel"
	},
	"Panel:SetFontInternal": {
		"body": [
			"SetFontInternal(${1:fontName})$0"
		],
		"description": "Sets the font used to render this panel's text.\n\nTo retrieve the font used by a panel, call Panel:GetFont.",
		"prefix": "SetFontInternal"
	},
	"Panel:SetHTML": {
		"body": [
			"SetHTML(${1:HTML code})$0"
		],
		"description": "Allows you to set HTML code within a panel.",
		"prefix": "SetHTML"
	},
	"Panel:SetHeight": {
		"body": [
			"SetHeight(${1:height})$0"
		],
		"description": "Sets the height of the panel.\n\nCalls PANEL:OnSizeChanged and marks this panel for layout (Panel:InvalidateLayout).\n\n\nSee also Panel:SetSize.",
		"prefix": "SetHeight"
	},
	"Panel:SetKeyBoardInputEnabled": {
		"body": [
			"SetKeyBoardInputEnabled(${1:keyboardInput})$0"
		],
		"description": "Alias of Panel:SetKeyboardInputEnabled(lowercase)Enables or disables the keyboard input for the panel.",
		"prefix": "SetKeyBoardInputEnabled"
	},
	"Panel:SetKeyboardInputEnabled": {
		"body": [
			"SetKeyboardInputEnabled(${1:enable})$0"
		],
		"description": "Allows or disallows the panel to receive keyboard focus and input. This is recursively applied to all children.",
		"prefix": "SetKeyboardInputEnabled"
	},
	"Panel:SetMaximumCharCount": {
		"body": [
			"SetMaximumCharCount(${1:maxChar})$0"
		],
		"description": "Sets the maximum character count this panel should have.\n\nThis function will only work on RichText and TextEntry panels and their derivatives.",
		"prefix": "SetMaximumCharCount"
	},
	"Panel:SetMinimumSize": {
		"body": [
			"SetMinimumSize(${1:minW=nil}, ${2:minH=nil})$0"
		],
		"description": "Sets the minimum dimensions of the panel or object.\n\nYou can restrict either or both values.\n\nCalling the function without arguments will remove the minimum size.",
		"prefix": "SetMinimumSize"
	},
	"Panel:SetModel": {
		"body": [
			"SetModel(${1:ModelPath}, ${2:skin=0}, ${3:bodygroups})$0"
		],
		"description": "Sets the model to be displayed by SpawnIcon.\n\nThis must be called after setting size if you wish to use a different size spawnicon",
		"prefix": "SetModel"
	},
	"Panel:SetMouseInputEnabled": {
		"body": [
			"SetMouseInputEnabled(${1:mouseInput})$0"
		],
		"description": "Enables or disables the mouse input for the panel.",
		"prefix": "SetMouseInputEnabled"
	},
	"Panel:SetName": {
		"body": [
			"SetName(${1:name})$0"
		],
		"description": "Sets the internal name of the panel.",
		"prefix": "SetName"
	},
	"Panel:SetPaintBackgroundEnabled": {
		"body": [
			"SetPaintBackgroundEnabled(${1:paintBackground})$0"
		],
		"description": "Sets whenever all the default background of the panel should be drawn or not.",
		"prefix": "SetPaintBackgroundEnabled"
	},
	"Panel:SetPaintBorderEnabled": {
		"body": [
			"SetPaintBorderEnabled(${1:paintBorder})$0"
		],
		"description": "Sets whenever all the default border of the panel should be drawn or not.",
		"prefix": "SetPaintBorderEnabled"
	},
	"Panel:SetPaintFunction": {
		"body": [
			"SetPaintFunction()$0"
		],
		"description": "This function does nothing.\nThis function does nothing.",
		"prefix": "SetPaintFunction"
	},
	"Panel:SetPaintedManually": {
		"body": [
			"SetPaintedManually(${1:paintedManually})$0"
		],
		"description": "Enables or disables painting of the panel manually with Panel:PaintManual.",
		"prefix": "SetPaintedManually"
	},
	"Panel:SetParent": {
		"body": [
			"SetParent(${1:parent})$0"
		],
		"description": "Sets the parent of the panel.",
		"prefix": "SetParent"
	},
	"Panel:SetPlayer": {
		"body": [
			"SetPlayer(${1:player}, ${2:size})$0"
		],
		"description": "Used by AvatarImage to load an avatar for given player.",
		"prefix": "SetPlayer"
	},
	"Panel:SetPopupStayAtBack": {
		"body": [
			"SetPopupStayAtBack(${1:stayAtBack})$0"
		],
		"description": "If this panel object has been made a popup with Panel:MakePopup, this method will prevent it from drawing in front of other panels when it receives input focus.",
		"prefix": "SetPopupStayAtBack"
	},
	"Panel:SetPos": {
		"body": [
			"SetPos(${1:posX}, ${2:posY})$0"
		],
		"description": "Sets the position of the panel's top left corner.\n\nThis will trigger PANEL:PerformLayout. You should avoid calling this function in PANEL:PerformLayout to avoid infinite loops.\n\nIf you wish to position and re-size panels without much guesswork and have them look good on different screen resolutions, you may find Panel:Dock useful",
		"prefix": "SetPos"
	},
	"Panel:SetRenderInScreenshots": {
		"body": [
			"SetRenderInScreenshots(${1:renderInScreenshot})$0"
		],
		"description": "Sets whenever the panel should be rendered in the next screenshot.",
		"prefix": "SetRenderInScreenshots"
	},
	"Panel:SetSelectable": {
		"body": [
			"SetSelectable(${1:selectable})$0"
		],
		"description": "Sets whether the panel object can be selected or not (like icons in the Spawn Menu, holding Shift). If enabled, this will affect the function of a DButton whilst Shift is pressed. Panel:SetSelected can be used to select/deselect the object.",
		"prefix": "SetSelectable"
	},
	"Panel:SetSelected": {
		"body": [
			"SetSelected(${1:selected=false})$0"
		],
		"description": "Sets the selected state of a selectable panel object. This functionality is set with Panel:SetSelectable and checked with Panel:IsSelectable.",
		"prefix": "SetSelected"
	},
	"Panel:SetSelectionCanvas": {
		"body": [
			"SetSelectionCanvas(${1:selCanvas})$0"
		],
		"description": "Enables the panel object for selection (much like the spawn menu).",
		"prefix": "SetSelectionCanvas"
	},
	"Panel:SetSize": {
		"body": [
			"SetSize(${1:width}, ${2:height})$0"
		],
		"description": "Sets the size of the panel.\n\nCalls PANEL:OnSizeChanged and marks this panel for layout (Panel:InvalidateLayout).\n\n\nSee also Panel:SetWidth and Panel:SetHeight.\n\nIf you wish to position and re-size panels without much guesswork and have them look good on different screen resolutions, you may find Panel:Dock useful",
		"prefix": "SetSize"
	},
	"Panel:SetSkin": {
		"body": [
			"SetSkin(${1:skinName})$0"
		],
		"description": "Sets the derma skin that the panel object will use, and refreshes all panels with derma.RefreshSkins.",
		"prefix": "SetSkin"
	},
	"Panel:SetSpawnIcon": {
		"body": [
			"SetSpawnIcon(${1:icon})$0"
		],
		"description": "Sets the .png image to be displayed on a  SpawnIcon or the panel it is based on ModelImage.\n\nOnly .png images can be used with this function.",
		"prefix": "SetSpawnIcon"
	},
	"Panel:SetSteamID": {
		"body": [
			"SetSteamID(${1:steamid}, ${2:size})$0"
		],
		"description": "Used by AvatarImage panels to load an avatar by its 64-bit Steam ID (community ID).",
		"prefix": "SetSteamID"
	},
	"Panel:SetTabPosition": {
		"body": [
			"SetTabPosition(${1:position})$0"
		],
		"description": "When TAB is pressed, the next selectable panel in the number sequence is selected.",
		"prefix": "SetTabPosition"
	},
	"Panel:SetTall": {
		"body": [
			"SetTall(${1:height})$0"
		],
		"description": "Sets height of a panel. An alias of Panel:SetHeight.",
		"prefix": "SetTall"
	},
	"Panel:SetTerm": {
		"body": [
			"SetTerm(${1:delay})$0"
		],
		"description": "Removes the panel after given time in seconds.\nThis function will not work if PANEL:AnimationThink is overridden, unless Panel:AnimationThinkInternal is called every frame.",
		"prefix": "SetTerm"
	},
	"Panel:SetText": {
		"body": [
			"SetText(${1:text})$0"
		],
		"description": "Sets the text value of a panel object containing text, such as a Label, TextEntry or  RichText and their derivatives, such as DLabel, DTextEntry or DButton.\n\nWhen used on a Label or its derivatives ( DLabel and DButton ), it will automatically call Panel:InvalidateLayout, meaning that you should avoid running this function every frame on these panels to avoid unnecessary performance loss.",
		"prefix": "SetText"
	},
	"Panel:SetTextInset": {
		"body": [
			"SetTextInset(${1:insetX}, ${2:insetY})$0"
		],
		"description": "Sets the left and top text margins of a text-based panel object, such as a DButton or DLabel.",
		"prefix": "SetTextInset"
	},
	"Panel:SetToFullHeight": {
		"body": [
			"SetToFullHeight()$0"
		],
		"description": "Sets the height of a RichText element to accommodate the text inside.\n\nThis function internally relies on Panel:GetNumLines, so it should be called at least a couple frames after modifying the text using Panel:AppendText",
		"prefix": "SetToFullHeight"
	},
	"Panel:SetTooltip": {
		"body": [
			"SetTooltip(${1:str})$0"
		],
		"description": "Sets the tooltip to be displayed when a player hovers over the panel object with their cursor.",
		"prefix": "SetTooltip"
	},
	"Panel:SetTooltipPanel": {
		"body": [
			"SetTooltipPanel(${1:tooltipPanel=nil})$0"
		],
		"description": "Sets the panel to be displayed as contents of a DTooltip when a player hovers over the panel object with their cursor. See Panel:SetTooltipPanelOverride if you are looking to override DTooltip itself.\n\nPanel:SetTooltip will override this functionality.\n\nCalling this from PANEL:OnCursorEntered is too late! The tooltip will not be displayed or be updated.\nGiven panel or the previously set one will NOT be automatically removed.",
		"prefix": "SetTooltipPanel"
	},
	"Panel:SetTooltipPanelOverride": {
		"body": [
			"SetTooltipPanelOverride(${1:override})$0"
		],
		"description": "Sets the panel class to be created instead of DTooltip when the player hovers over this panel and a tooltip needs creating.",
		"prefix": "SetTooltipPanelOverride"
	},
	"Panel:SetURL": {
		"body": [
			"SetURL(${1:url})$0"
		],
		"description": "Sets the URL of a link-based panel such as DLabelURL.",
		"prefix": "SetURL"
	},
	"Panel:SetUnderlineFont": {
		"body": [
			"SetUnderlineFont(${1:fontName})$0"
		],
		"description": "Sets the underlined font for use by clickable text in a RichText. See also Panel:InsertClickableTextStart\n\nThis function will only work on RichText panels.",
		"prefix": "SetUnderlineFont"
	},
	"Panel:SetVerticalScrollbarEnabled": {
		"body": [
			"SetVerticalScrollbarEnabled(${1:display=false})$0"
		],
		"description": "Sets the visibility of the vertical scrollbar.\n\nWorks for RichText and TextEntry.",
		"prefix": "SetVerticalScrollbarEnabled"
	},
	"Panel:SetVisible": {
		"body": [
			"SetVisible(${1:visible})$0"
		],
		"description": "Sets the \"visibility\" of the panel.",
		"prefix": "SetVisible"
	},
	"Panel:SetWide": {
		"body": [
			"SetWide(${1:width})$0"
		],
		"description": "Sets width of a panel. An alias of Panel:SetWidth.",
		"prefix": "SetWide"
	},
	"Panel:SetWidth": {
		"body": [
			"SetWidth(${1:width})$0"
		],
		"description": "Sets the width of the panel.\n\nCalls PANEL:OnSizeChanged and marks this panel for layout (Panel:InvalidateLayout).\n\n\nSee also Panel:SetSize.",
		"prefix": "SetWidth"
	},
	"Panel:SetWorldClicker": {
		"body": [
			"SetWorldClicker(${1:enabled})$0"
		],
		"description": "This makes it so that when you're hovering over this panel you can `click` on the world. Your viewmodel will aim etc. This is primarily used for the Sandbox context menu.\n\nThis function doesn't scale with custom FOV specified by GM:CalcView or WEAPON:TranslateFOV.",
		"prefix": "SetWorldClicker"
	},
	"Panel:SetWrap": {
		"body": [
			"SetWrap(${1:wrap})$0"
		],
		"description": "Sets whether text wrapping should be enabled or disabled on Label and DLabel panels.\nUse DLabel:SetAutoStretchVertical to automatically correct vertical size; Panel:SizeToContents will not set the correct height.",
		"prefix": "SetWrap"
	},
	"Panel:SetZPos": {
		"body": [
			"SetZPos(${1:zIndex})$0"
		],
		"description": "Sets the panels z position which determines the rendering order.\n\nPanels with lower z positions appear behind panels with higher z positions.\n\nThis also controls in which order panels docked with Panel:Dock appears.",
		"prefix": "SetZPos"
	},
	"Panel:Show": {
		"body": [
			"Show()$0"
		],
		"description": "Makes a panel visible.",
		"prefix": "Show"
	},
	"Panel:SizeTo": {
		"body": [
			"SizeTo(${1:sizeW=0}, ${2:sizeH=0}, ${3:time}, ${4:delay=0}, ${5:ease=-1}, ${6:callback})$0"
		],
		"description": "Uses animation to resize the panel to the specified size.",
		"prefix": "SizeTo"
	},
	"Panel:SizeToChildren": {
		"body": [
			"SizeToChildren(${1:sizeW=false}, ${2:sizeH=false})$0"
		],
		"description": "Resizes the panel to fit the bounds of its children.\n\nYour panel must have its layout updated (Panel:InvalidateLayout) for this function to work properly.\nThe sizeW and sizeH parameters are false by default. Therefore, calling this function with no arguments will result in a no-op.",
		"prefix": "SizeToChildren"
	},
	"Panel:SizeToContents": {
		"body": [
			"SizeToContents()$0"
		],
		"description": "Resizes the panel so that its width and height fit all of the content inside.\n\nOnly works on Label derived panels such as DLabel by default, and on any panel that manually implemented the Panel:SizeToContents method, such as DNumberWang and DImage.\n\nYou must call this function **AFTER** setting text/font, adjusting child panels or otherwise altering the panel.",
		"prefix": "SizeToContents"
	},
	"Panel:SizeToContentsX": {
		"body": [
			"SizeToContentsX(${1:addVal=0})$0"
		],
		"description": "Resizes the panel object's width to accommodate all child objects/contents.\n\nOnly works on Label derived panels such as DLabel by default, and on any panel that manually implemented Panel:GetContentSize method.\n\nYou must call this function **AFTER** setting text/font or adjusting child panels.",
		"prefix": "SizeToContentsX"
	},
	"Panel:SizeToContentsY": {
		"body": [
			"SizeToContentsY(${1:addVal=0})$0"
		],
		"description": "Resizes the panel object's height to accommodate all child objects/contents.\n\nOnly works on Label derived panels such as DLabel by default, and on any panel that manually implemented Panel:GetContentSize method.\n\nYou must call this function **AFTER** setting text/font or adjusting child panels.",
		"prefix": "SizeToContentsY"
	},
	"Panel:SlideDown": {
		"body": [
			"SlideDown(${1:Length})$0"
		],
		"description": "Slides the panel in from above.",
		"prefix": "SlideDown"
	},
	"Panel:SlideUp": {
		"body": [
			"SlideUp(${1:Length})$0"
		],
		"description": "Slides the panel out to the top.",
		"prefix": "SlideUp"
	},
	"Panel:StartBoxSelection": {
		"body": [
			"StartBoxSelection()$0"
		],
		"description": "Begins a box selection, enables mouse capture for the panel object, and sets the start point of the selection box to the mouse cursor's position, relative to this object. For this to work, either the object or its parent must be enabled as a selection canvas. This is set using Panel:SetSelectionCanvas.",
		"prefix": "StartBoxSelection"
	},
	"Panel:Stop": {
		"body": [
			"Stop()$0"
		],
		"description": "Stops all panel animations by clearing its animation list. This also clears all delayed animations.",
		"prefix": "Stop"
	},
	"Panel:StretchBottomTo": {
		"body": [
			"StretchBottomTo(${1:tgtPanel}, ${2:offset=0})$0"
		],
		"description": "Resizes the panel object's height so that its bottom is aligned with the top of the passed panel. An offset greater than zero will reduce the panel's height to leave a gap between it and the passed panel.",
		"prefix": "StretchBottomTo"
	},
	"Panel:StretchRightTo": {
		"body": [
			"StretchRightTo(${1:tgtPanel}, ${2:offset=0})$0"
		],
		"description": "Resizes the panel object's width so that its right edge is aligned with the left of the passed panel. An offset greater than zero will reduce the panel's width to leave a gap between it and the passed panel.",
		"prefix": "StretchRightTo"
	},
	"Panel:StretchToParent": {
		"body": [
			"StretchToParent(${1:offsetLeft}, ${2:offsetTop}, ${3:offsetRight}, ${4:offsetBottom})$0"
		],
		"description": "Sets the dimensions of the panel to fill its parent. It will only stretch in directions that aren't nil.",
		"prefix": "StretchToParent"
	},
	"Panel:ToggleSelection": {
		"body": [
			"ToggleSelection()$0"
		],
		"description": "Toggles the selected state of a selectable panel object. This functionality is set with Panel:SetSelectable and checked with Panel:IsSelectable. To check whether the object is selected or not, Panel:IsSelected is used.",
		"prefix": "ToggleSelection"
	},
	"Panel:ToggleVisible": {
		"body": [
			"ToggleVisible()$0"
		],
		"description": "Toggles the visibility of a panel and all its children.",
		"prefix": "ToggleVisible"
	},
	"Panel:Undo": {
		"body": [
			"Undo()$0"
		],
		"description": "Restores the last saved state (caret position and the text inside) of a TextEntry. Should act identically to pressing CTRL+Z in a TextEntry.\n\nSee also Panel:SaveUndoState.",
		"prefix": "Undo"
	},
	"Panel:UnselectAll": {
		"body": [
			"UnselectAll()$0"
		],
		"description": "Recursively deselects this panel object and all of its children. This will cascade to all child objects at every level below the parent.",
		"prefix": "UnselectAll"
	},
	"Panel:UpdateHTMLTexture": {
		"body": [
			"UpdateHTMLTexture()$0"
		],
		"description": "Forcibly updates the panels' HTML Material, similar to when Paint is called on it.This is only useful if the panel is not normally visible, i.e the panel exists purely for its HTML Material.\nOnly works on with panels that have a HTML Material. See Panel:GetHTMLMaterial for more details.\nA good place to call this is in the GM:PreRender hook",
		"prefix": "UpdateHTMLTexture"
	},
	"Panel:Valid": {
		"body": [
			"Valid()$0"
		],
		"description": "Use Panel:IsValid instead.Returns if a given panel is valid or not.",
		"prefix": "Valid"
	},
	"PathFollower:Chase": {
		"body": [
			"Chase(${1:bot}, ${2:ent})$0"
		],
		"description": "If you created your path with type \"Chase\" this functions should be used in place of PathFollower:Update to cause the bot to chase the specified entity.",
		"prefix": "Chase"
	},
	"PathFollower:Compute": {
		"body": [
			"Compute(${1:from}, ${2:to}, ${3:generator=nil})$0"
		],
		"description": "Compute shortest path from bot to 'goal' via A* algorithm.",
		"prefix": "Compute"
	},
	"PathFollower:Draw": {
		"body": [
			"Draw()$0"
		],
		"description": "Draws the path. This is meant for debugging - and uses debug overlay.",
		"prefix": "Draw"
	},
	"PathFollower:FirstSegment": {
		"body": [
			"FirstSegment()$0"
		],
		"description": "Returns the first segment of the path.",
		"prefix": "FirstSegment"
	},
	"PathFollower:GetAge": {
		"body": [
			"GetAge()$0"
		],
		"description": "Returns the age since the path was built",
		"prefix": "GetAge"
	},
	"PathFollower:GetAllSegments": {
		"body": [
			"GetAllSegments()$0"
		],
		"description": "Returns all of the segments of the given path.",
		"prefix": "GetAllSegments"
	},
	"PathFollower:GetClosestPosition": {
		"body": [
			"GetClosestPosition(${1:position})$0"
		],
		"description": "The closest position along the path to a position",
		"prefix": "GetClosestPosition"
	},
	"PathFollower:GetCurrentGoal": {
		"body": [
			"GetCurrentGoal()$0"
		],
		"description": "Returns the current goal data. Can return nil if the current goal is invalid, for example immediately after PathFollower:Update.",
		"prefix": "GetCurrentGoal"
	},
	"PathFollower:GetCursorData": {
		"body": [
			"GetCursorData()$0"
		],
		"description": "Returns the cursor data",
		"prefix": "GetCursorData"
	},
	"PathFollower:GetCursorPosition": {
		"body": [
			"GetCursorPosition()$0"
		],
		"description": "Returns the current progress along the path",
		"prefix": "GetCursorPosition"
	},
	"PathFollower:GetEnd": {
		"body": [
			"GetEnd()$0"
		],
		"description": "Returns the path end position",
		"prefix": "GetEnd"
	},
	"PathFollower:GetGoalTolerance": {
		"body": [
			"GetGoalTolerance()$0"
		],
		"description": "Returns how close we can get to the goal to call it done.",
		"prefix": "GetGoalTolerance"
	},
	"PathFollower:GetHindrance": {
		"body": [
			"GetHindrance()$0"
		],
		"description": "",
		"prefix": "GetHindrance"
	},
	"PathFollower:GetLength": {
		"body": [
			"GetLength()$0"
		],
		"description": "Returns the total length of the path",
		"prefix": "GetLength"
	},
	"PathFollower:GetMinLookAheadDistance": {
		"body": [
			"GetMinLookAheadDistance()$0"
		],
		"description": "Returns the minimum range movement goal must be along path.",
		"prefix": "GetMinLookAheadDistance"
	},
	"PathFollower:GetPositionOnPath": {
		"body": [
			"GetPositionOnPath(${1:distance})$0"
		],
		"description": "Returns the vector position of distance along path",
		"prefix": "GetPositionOnPath"
	},
	"PathFollower:GetStart": {
		"body": [
			"GetStart()$0"
		],
		"description": "Returns the path start position",
		"prefix": "GetStart"
	},
	"PathFollower:Invalidate": {
		"body": [
			"Invalidate()$0"
		],
		"description": "Invalidates the current path",
		"prefix": "Invalidate"
	},
	"PathFollower:IsValid": {
		"body": [
			"IsValid()$0"
		],
		"description": "Returns true if the path is valid",
		"prefix": "IsValid"
	},
	"PathFollower:LastSegment": {
		"body": [
			"LastSegment()$0"
		],
		"description": "Returns the last segment of the path.",
		"prefix": "LastSegment"
	},
	"PathFollower:MoveCursor": {
		"body": [
			"MoveCursor(${1:distance})$0"
		],
		"description": "Moves the cursor by give distance.\n\nFor a function that sets the distance, see PathFollower:MoveCursorTo.",
		"prefix": "MoveCursor"
	},
	"PathFollower:MoveCursorTo": {
		"body": [
			"MoveCursorTo(${1:distance})$0"
		],
		"description": "Sets the cursor position to given distance.\n\nFor relative distance, see PathFollower:MoveCursor.",
		"prefix": "MoveCursorTo"
	},
	"PathFollower:MoveCursorToClosestPosition": {
		"body": [
			"MoveCursorToClosestPosition(${1:pos}, ${2:type=0}, ${3:alongLimit=0})$0"
		],
		"description": "Moves the cursor of the path to the closest position compared to given vector.",
		"prefix": "MoveCursorToClosestPosition"
	},
	"PathFollower:MoveCursorToEnd": {
		"body": [
			"MoveCursorToEnd()$0"
		],
		"description": "Moves the cursor to the end of the path",
		"prefix": "MoveCursorToEnd"
	},
	"PathFollower:MoveCursorToStart": {
		"body": [
			"MoveCursorToStart()$0"
		],
		"description": "Moves the cursor to the end of the path",
		"prefix": "MoveCursorToStart"
	},
	"PathFollower:ResetAge": {
		"body": [
			"ResetAge()$0"
		],
		"description": "Resets the age which is retrieved by PathFollower:GetAge to 0.",
		"prefix": "ResetAge"
	},
	"PathFollower:SetGoalTolerance": {
		"body": [
			"SetGoalTolerance(${1:distance})$0"
		],
		"description": "How close we can get to the goal to call it done",
		"prefix": "SetGoalTolerance"
	},
	"PathFollower:SetMinLookAheadDistance": {
		"body": [
			"SetMinLookAheadDistance(${1:mindist})$0"
		],
		"description": "Sets minimum range movement goal must be along path",
		"prefix": "SetMinLookAheadDistance"
	},
	"PathFollower:Update": {
		"body": [
			"Update(${1:bot})$0"
		],
		"description": "Move the bot along the path.",
		"prefix": "Update"
	},
	"PhysCollide:Destroy": {
		"body": [
			"Destroy()$0"
		],
		"description": "Destroys the PhysCollide object.",
		"prefix": "Destroy"
	},
	"PhysCollide:IsValid": {
		"body": [
			"IsValid()$0"
		],
		"description": "Checks whether this PhysCollide object is valid or not.\n\nYou should just use Global.IsValid instead.",
		"prefix": "IsValid"
	},
	"PhysCollide:TraceBox": {
		"body": [
			"TraceBox(${1:origin}, ${2:angles}, ${3:rayStart}, ${4:rayEnd}, ${5:rayMins}, ${6:rayMaxs})$0"
		],
		"description": "Performs a trace against this PhysCollide with the given parameters. This can be used for both line traces and box traces.",
		"prefix": "TraceBox"
	},
	"PhysObj:AddAngleVelocity": {
		"body": [
			"AddAngleVelocity(${1:angularVelocity})$0"
		],
		"description": "Adds the specified velocity to the current.",
		"prefix": "AddAngleVelocity"
	},
	"PhysObj:AddGameFlag": {
		"body": [
			"AddGameFlag(${1:flags})$0"
		],
		"description": "Adds one or more bit flags.",
		"prefix": "AddGameFlag"
	},
	"PhysObj:AddVelocity": {
		"body": [
			"AddVelocity(${1:velocity})$0"
		],
		"description": "Adds the specified velocity to the current.",
		"prefix": "AddVelocity"
	},
	"PhysObj:AlignAngles": {
		"body": [
			"AlignAngles(${1:from}, ${2:to})$0"
		],
		"description": "Rotates the object so that it's angles are aligned to the ones inputted.",
		"prefix": "AlignAngles"
	},
	"PhysObj:ApplyForceCenter": {
		"body": [
			"ApplyForceCenter(${1:force})$0"
		],
		"description": "Applies the specified force to the physics object (in [Newtons](https://en.wikipedia.org/wiki/Newton_(unit))).\n\nThis will not work on players, use Entity:SetVelocity instead.",
		"prefix": "ApplyForceCenter"
	},
	"PhysObj:ApplyForceOffset": {
		"body": [
			"ApplyForceOffset(${1:force}, ${2:position})$0"
		],
		"description": "Applies the specified force on the physics object at the specified position",
		"prefix": "ApplyForceOffset"
	},
	"PhysObj:ApplyTorqueCenter": {
		"body": [
			"ApplyTorqueCenter(${1:torque})$0"
		],
		"description": "Applies specified angular impulse to the physics object. See PhysObj:CalculateForceOffset",
		"prefix": "ApplyTorqueCenter"
	},
	"PhysObj:CalculateForceOffset": {
		"body": [
			"CalculateForceOffset(${1:force}, ${2:pos})$0"
		],
		"description": "Calculates the force and torque on the center of mass for an offset force impulse. The outputs can be directly passed to PhysObj:ApplyForceCenter and PhysObj:ApplyTorqueCenter, respectively.",
		"prefix": "CalculateForceOffset"
	},
	"PhysObj:CalculateVelocityOffset": {
		"body": [
			"CalculateVelocityOffset(${1:force}, ${2:pos})$0"
		],
		"description": "Calculates the linear and angular velocities on the center of mass for an offset force impulse. The outputs can be directly passed to PhysObj:AddVelocity and PhysObj:AddAngleVelocity, respectively.\n\nThis will return zero length vectors if the physics object's motion is disabled. See PhysObj:IsMotionEnabled.",
		"prefix": "CalculateVelocityOffset"
	},
	"PhysObj:ClearGameFlag": {
		"body": [
			"ClearGameFlag(${1:flags})$0"
		],
		"description": "Removes one of more specified flags.",
		"prefix": "ClearGameFlag"
	},
	"PhysObj:ComputeShadowControl": {
		"body": [
			"ComputeShadowControl(${1:shadowparams})$0"
		],
		"description": "Allows you to move a PhysObj to a point and angle in 3D space.",
		"prefix": "ComputeShadowControl"
	},
	"PhysObj:EnableCollisions": {
		"body": [
			"EnableCollisions(${1:enable})$0"
		],
		"description": "Sets whether the physics object should collide with anything or not, including world.\n\nThis function currently has major problems with player collisions, and as such should be avoided at all costs.\n\n\n\nA better alternative to this function would be using Entity:SetCollisionGroup( COLLISION_GROUP_WORLD ).",
		"prefix": "EnableCollisions"
	},
	"PhysObj:EnableDrag": {
		"body": [
			"EnableDrag(${1:enable})$0"
		],
		"description": "Sets whenever the physics object should be affected by drag.",
		"prefix": "EnableDrag"
	},
	"PhysObj:EnableGravity": {
		"body": [
			"EnableGravity(${1:enable})$0"
		],
		"description": "Sets whether the PhysObject should be affected by gravity",
		"prefix": "EnableGravity"
	},
	"PhysObj:EnableMotion": {
		"body": [
			"EnableMotion(${1:enable})$0"
		],
		"description": "Sets whether the physobject should be able to move or not.\n\nThis is the exact method the Physics Gun uses to freeze props. If a motion-disabled physics object is grabbed with the physics gun, the object will be able to move again. To disallow this, use GM:PhysgunPickup.",
		"prefix": "EnableMotion"
	},
	"PhysObj:GetAABB": {
		"body": [
			"GetAABB()$0"
		],
		"description": "Returns the mins and max of the physics object.",
		"prefix": "GetAABB"
	},
	"PhysObj:GetAngleVelocity": {
		"body": [
			"GetAngleVelocity()$0"
		],
		"description": "Gets the angular velocity of the object in degrees per second.",
		"prefix": "GetAngleVelocity"
	},
	"PhysObj:GetAngles": {
		"body": [
			"GetAngles()$0"
		],
		"description": "Returns the angles of the physics object.",
		"prefix": "GetAngles"
	},
	"PhysObj:GetContents": {
		"body": [
			"GetContents()$0"
		],
		"description": "Returns the contents flag of the PhysObj.",
		"prefix": "GetContents"
	},
	"PhysObj:GetDamping": {
		"body": [
			"GetDamping()$0"
		],
		"description": "Returns the linear and angular damping of the physics object.",
		"prefix": "GetDamping"
	},
	"PhysObj:GetEnergy": {
		"body": [
			"GetEnergy()$0"
		],
		"description": "Returns the sum of the linear and rotational kinetic energies of the physics object.",
		"prefix": "GetEnergy"
	},
	"PhysObj:GetEntity": {
		"body": [
			"GetEntity()$0"
		],
		"description": "Returns the parent entity of the physics object.",
		"prefix": "GetEntity"
	},
	"PhysObj:GetFrictionSnapshot": {
		"body": [
			"GetFrictionSnapshot()$0"
		],
		"description": "Returns the friction snapshot of this physics object. This is useful for determining if an object touching ground for example.",
		"prefix": "GetFrictionSnapshot"
	},
	"PhysObj:GetInertia": {
		"body": [
			"GetInertia()$0"
		],
		"description": "Returns the directional inertia of the physics object.",
		"prefix": "GetInertia"
	},
	"PhysObj:GetInvInertia": {
		"body": [
			"GetInvInertia()$0"
		],
		"description": "Returns 1 divided by the inertia.",
		"prefix": "GetInvInertia"
	},
	"PhysObj:GetInvMass": {
		"body": [
			"GetInvMass()$0"
		],
		"description": "Returns 1 divided by the physics object's mass.",
		"prefix": "GetInvMass"
	},
	"PhysObj:GetMass": {
		"body": [
			"GetMass()$0"
		],
		"description": "Returns the mass of the physics object.",
		"prefix": "GetMass"
	},
	"PhysObj:GetMassCenter": {
		"body": [
			"GetMassCenter()$0"
		],
		"description": "Returns the center of mass of the physics object as a local vector.",
		"prefix": "GetMassCenter"
	},
	"PhysObj:GetMaterial": {
		"body": [
			"GetMaterial()$0"
		],
		"description": "Returns the physical material of the physics object.",
		"prefix": "GetMaterial"
	},
	"PhysObj:GetMesh": {
		"body": [
			"GetMesh()$0"
		],
		"description": "Returns the physics mesh of the object which is used for physobj-on-physobj collision.",
		"prefix": "GetMesh"
	},
	"PhysObj:GetMeshConvexes": {
		"body": [
			"GetMeshConvexes()$0"
		],
		"description": "Returns all convex physics meshes of the object. See Entity:PhysicsInitMultiConvex for more information.",
		"prefix": "GetMeshConvexes"
	},
	"PhysObj:GetName": {
		"body": [
			"GetName()$0"
		],
		"description": "Returns the name of the physics object.",
		"prefix": "GetName"
	},
	"PhysObj:GetPos": {
		"body": [
			"GetPos()$0"
		],
		"description": "Returns the position of the physics object.",
		"prefix": "GetPos"
	},
	"PhysObj:GetPositionMatrix": {
		"body": [
			"GetPositionMatrix()$0"
		],
		"description": "Returns the position and angle of the physics object as a 3x4 matrix (VMatrix is 4x4 so the fourth row goes unused). The first three columns store the angle as a [rotation matrix](https://en.wikipedia.org/wiki/Rotation_matrix), and the fourth column stores the position vector.",
		"prefix": "GetPositionMatrix"
	},
	"PhysObj:GetRotDamping": {
		"body": [
			"GetRotDamping()$0"
		],
		"description": "Returns the rotation damping of the physics object.",
		"prefix": "GetRotDamping"
	},
	"PhysObj:GetShadowAngles": {
		"body": [
			"GetShadowAngles()$0"
		],
		"description": "Returns the angles of the PhysObj shadow. See PhysObj:UpdateShadow.",
		"prefix": "GetShadowAngles"
	},
	"PhysObj:GetShadowPos": {
		"body": [
			"GetShadowPos()$0"
		],
		"description": "Returns the position of the PhysObj shadow. See PhysObj:UpdateShadow.",
		"prefix": "GetShadowPos"
	},
	"PhysObj:GetSpeedDamping": {
		"body": [
			"GetSpeedDamping()$0"
		],
		"description": "Returns the speed damping of the physics object.",
		"prefix": "GetSpeedDamping"
	},
	"PhysObj:GetStress": {
		"body": [
			"GetStress()$0"
		],
		"description": "Returns the stress of the entity.",
		"prefix": "GetStress"
	},
	"PhysObj:GetSurfaceArea": {
		"body": [
			"GetSurfaceArea()$0"
		],
		"description": "Returns the surface area of the physics object in source-units\u00c2\u00b2. Or nil if the PhysObj is a generated sphere or box.",
		"prefix": "GetSurfaceArea"
	},
	"PhysObj:GetVelocity": {
		"body": [
			"GetVelocity()$0"
		],
		"description": "Returns the absolute directional velocity of the physobject.",
		"prefix": "GetVelocity"
	},
	"PhysObj:GetVelocityAtPoint": {
		"body": [
			"GetVelocityAtPoint(${1:point})$0"
		],
		"description": "Returns the world velocity of a point in world coordinates about the object. This is useful for objects rotating around their own axis/origin.",
		"prefix": "GetVelocityAtPoint"
	},
	"PhysObj:GetVolume": {
		"body": [
			"GetVolume()$0"
		],
		"description": "Returns the volume in source units\u00c2\u00b3. Or nil if the PhysObj is a generated sphere or box.",
		"prefix": "GetVolume"
	},
	"PhysObj:HasGameFlag": {
		"body": [
			"HasGameFlag(${1:flags})$0"
		],
		"description": "Returns whenever the specified flag(s) is/are set.",
		"prefix": "HasGameFlag"
	},
	"PhysObj:IsAsleep": {
		"body": [
			"IsAsleep()$0"
		],
		"description": "Returns whether the physics object is \"sleeping\".\n\nSee PhysObj:Sleep for more information.",
		"prefix": "IsAsleep"
	},
	"PhysObj:IsCollisionEnabled": {
		"body": [
			"IsCollisionEnabled()$0"
		],
		"description": "Returns whenever the entity is able to collide or not.",
		"prefix": "IsCollisionEnabled"
	},
	"PhysObj:IsDragEnabled": {
		"body": [
			"IsDragEnabled()$0"
		],
		"description": "Returns whenever the entity is affected by drag.",
		"prefix": "IsDragEnabled"
	},
	"PhysObj:IsGravityEnabled": {
		"body": [
			"IsGravityEnabled()$0"
		],
		"description": "Returns whenever the entity is affected by gravity.",
		"prefix": "IsGravityEnabled"
	},
	"PhysObj:IsMotionEnabled": {
		"body": [
			"IsMotionEnabled()$0"
		],
		"description": "Returns if the physics object can move itself (by velocity, acceleration)",
		"prefix": "IsMotionEnabled"
	},
	"PhysObj:IsMoveable": {
		"body": [
			"IsMoveable()$0"
		],
		"description": "Returns whenever the entity is able to move.",
		"prefix": "IsMoveable"
	},
	"PhysObj:IsPenetrating": {
		"body": [
			"IsPenetrating()$0"
		],
		"description": "Returns whenever the physics object is penetrating another physics object.\n\nThis is internally implemented as `PhysObj:HasGameFlag( FVPHYSICS_PENETRATING )` and thus is only updated for non-static physics objects.",
		"prefix": "IsPenetrating"
	},
	"PhysObj:IsValid": {
		"body": [
			"IsValid()$0"
		],
		"description": "Returns if the physics object is valid/not NULL.",
		"prefix": "IsValid"
	},
	"PhysObj:LocalToWorld": {
		"body": [
			"LocalToWorld(${1:LocalVec})$0"
		],
		"description": "Mapping a vector in local frame of the physics object to world frame.\n\nthis function does translation and rotation, with translation done first.",
		"prefix": "LocalToWorld"
	},
	"PhysObj:LocalToWorldVector": {
		"body": [
			"LocalToWorldVector(${1:LocalVec})$0"
		],
		"description": "Rotate a vector from the local frame of the physics object to world frame.\n\nThis function only rotates the vector, without any translation operation.",
		"prefix": "LocalToWorldVector"
	},
	"PhysObj:OutputDebugInfo": {
		"body": [
			"OutputDebugInfo()$0"
		],
		"description": "Prints debug info about the state of the physics object to the console.",
		"prefix": "OutputDebugInfo"
	},
	"PhysObj:RecheckCollisionFilter": {
		"body": [
			"RecheckCollisionFilter()$0"
		],
		"description": "Call this when the collision filter conditions change due to this object's state (e.g. changing solid type or collision group)",
		"prefix": "RecheckCollisionFilter"
	},
	"PhysObj:RotateAroundAxis": {
		"body": [
			"RotateAroundAxis(${1:dir}, ${2:ang})$0"
		],
		"description": "A convinience function for Angle:RotateAroundAxis.",
		"prefix": "RotateAroundAxis"
	},
	"PhysObj:SetAngleDragCoefficient": {
		"body": [
			"SetAngleDragCoefficient(${1:coefficient})$0"
		],
		"description": "Sets the amount of [drag](https://en.wikipedia.org/wiki/Drag_(physics)) to apply to a physics object when attempting to rotate.",
		"prefix": "SetAngleDragCoefficient"
	},
	"PhysObj:SetAngles": {
		"body": [
			"SetAngles(${1:angles})$0"
		],
		"description": "Sets the angles of the physobject.",
		"prefix": "SetAngles"
	},
	"PhysObj:SetBuoyancyRatio": {
		"body": [
			"SetBuoyancyRatio(${1:buoyancy})$0"
		],
		"description": "Sets the buoyancy ratio of the physics object. (How well it floats in water)",
		"prefix": "SetBuoyancyRatio"
	},
	"PhysObj:SetContents": {
		"body": [
			"SetContents(${1:contents})$0"
		],
		"description": "Sets the contents flag of the PhysObj.",
		"prefix": "SetContents"
	},
	"PhysObj:SetDamping": {
		"body": [
			"SetDamping(${1:linearDamping}, ${2:angularDamping})$0"
		],
		"description": "Sets the linear and angular damping of the physics object.",
		"prefix": "SetDamping"
	},
	"PhysObj:SetDragCoefficient": {
		"body": [
			"SetDragCoefficient(${1:drag})$0"
		],
		"description": "Modifies how much drag (air resistance) affects the object.",
		"prefix": "SetDragCoefficient"
	},
	"PhysObj:SetInertia": {
		"body": [
			"SetInertia(${1:directionalInertia})$0"
		],
		"description": "Sets the directional inertia.",
		"prefix": "SetInertia"
	},
	"PhysObj:SetMass": {
		"body": [
			"SetMass(${1:mass})$0"
		],
		"description": "Sets the mass of the physics object.",
		"prefix": "SetMass"
	},
	"PhysObj:SetMaterial": {
		"body": [
			"SetMaterial(${1:materialName})$0"
		],
		"description": "Sets the material of the physobject.\n\nImpact sounds will only change if this is called on client",
		"prefix": "SetMaterial"
	},
	"PhysObj:SetPos": {
		"body": [
			"SetPos(${1:position}, ${2:teleport=false})$0"
		],
		"description": "Sets the position of the physobject.",
		"prefix": "SetPos"
	},
	"PhysObj:SetVelocity": {
		"body": [
			"SetVelocity(${1:velocity})$0"
		],
		"description": "Sets the velocity of the physics object for the next iteration.",
		"prefix": "SetVelocity"
	},
	"PhysObj:SetVelocityInstantaneous": {
		"body": [
			"SetVelocityInstantaneous(${1:velocity})$0"
		],
		"description": "Sets the velocity of the physics object.",
		"prefix": "SetVelocityInstantaneous"
	},
	"PhysObj:Sleep": {
		"body": [
			"Sleep()$0"
		],
		"description": "Makes the physics object \"sleep\".\n\nThe physics object will no longer be moving unless it is \"woken up\" by either a collision with another moving object, or by PhysObj:Wake. This is an optimization feature of the physics engine.",
		"prefix": "Sleep"
	},
	"PhysObj:UpdateShadow": {
		"body": [
			"UpdateShadow(${1:targetPosition}, ${2:targetAngles}, ${3:frameTime})$0"
		],
		"description": "Unlike PhysObj:SetPos and PhysObj:SetAngles, this allows the movement of a physobj while leaving physics interactions intact.\nThis is used internally by the motion controller of the Gravity Gun , the +use pickup and the Physics Gun, and entities such as the crane.\n\nThis is the ideal function to move a physics shadow created with Entity:PhysicsInitShadow or Entity:MakePhysicsObjectAShadow.",
		"prefix": "UpdateShadow"
	},
	"PhysObj:Wake": {
		"body": [
			"Wake()$0"
		],
		"description": "Wakes the physics object.\n\nSee PhysObj:Sleep for more information.",
		"prefix": "Wake"
	},
	"PhysObj:WorldToLocal": {
		"body": [
			"WorldToLocal(${1:vec})$0"
		],
		"description": "Converts a vector to a relative to the physics object coordinate system.",
		"prefix": "WorldToLocal"
	},
	"PhysObj:WorldToLocalVector": {
		"body": [
			"WorldToLocalVector(${1:WorldVec})$0"
		],
		"description": "Rotate a vector from the world frame to the local frame of the physics object.\n\nThis function only rotates the vector, without any translation operation.",
		"prefix": "WorldToLocalVector"
	},
	"Player:AccountID": {
		"body": [
			"AccountID()$0"
		],
		"description": "Returns the player's AccountID aka SteamID3.\n\nFor bots this will return values starting with 0 for the first bot, 1 for the second bot and so on.\nIn singleplayer, this will return no value.",
		"prefix": "AccountID"
	},
	"Player:AddCleanup": {
		"body": [
			"AddCleanup(${1:type}, ${2:ent})$0"
		],
		"description": "Adds an entity to the players clean up list.",
		"prefix": "AddCleanup"
	},
	"Player:AddCount": {
		"body": [
			"AddCount(${1:str}, ${2:ent})$0"
		],
		"description": "Adds an entity to the total count of entities of same class.",
		"prefix": "AddCount"
	},
	"Player:AddDeaths": {
		"body": [
			"AddDeaths(${1:count})$0"
		],
		"description": "Add a certain amount to the player's death count",
		"prefix": "AddDeaths"
	},
	"Player:AddFrags": {
		"body": [
			"AddFrags(${1:count})$0"
		],
		"description": "Add a certain amount to the player's frag count (or kills count)",
		"prefix": "AddFrags"
	},
	"Player:AddFrozenPhysicsObject": {
		"body": [
			"AddFrozenPhysicsObject(${1:ent}, ${2:physobj})$0"
		],
		"description": "Adds a entity to the players list of frozen objects.",
		"prefix": "AddFrozenPhysicsObject"
	},
	"Player:AddPlayerOption": {
		"body": [
			"AddPlayerOption(${1:name}, ${2:timeout}, ${3:vote_callback}, ${4:draw_callback})$0"
		],
		"description": "Sets up the voting system for the player.\nThis is a really barebone system. By calling this a vote gets started, when the player presses 0-9 the callback function gets called along with the key the player pressed. Use the draw callback to draw the vote panel.",
		"prefix": "AddPlayerOption"
	},
	"Player:AddVCDSequenceToGestureSlot": {
		"body": [
			"AddVCDSequenceToGestureSlot(${1:slot}, ${2:sequenceId}, ${3:cycle}, ${4:autokill=false})$0"
		],
		"description": "Plays a sequence directly from a sequence number, similar to Player:AnimRestartGesture. This function has the advantage to play sequences that haven't been bound to an existing Enums/ACT",
		"prefix": "AddVCDSequenceToGestureSlot"
	},
	"Player:Alive": {
		"body": [
			"Alive()$0"
		],
		"description": "Checks if the player is alive.",
		"prefix": "Alive"
	},
	"Player:AllowFlashlight": {
		"body": [
			"AllowFlashlight(${1:canFlashlight})$0"
		],
		"description": "Sets if the player can toggle his flashlight. Function exists on both the server and client but has no effect when ran on the client.",
		"prefix": "AllowFlashlight"
	},
	"Player:AllowImmediateDecalPainting": {
		"body": [
			"AllowImmediateDecalPainting(${1:allow})$0"
		],
		"description": "Lets the player spray his decal without delay",
		"prefix": "AllowImmediateDecalPainting"
	},
	"Player:AnimResetGestureSlot": {
		"body": [
			"AnimResetGestureSlot(${1:slot})$0"
		],
		"description": "Resets player gesture in selected slot.",
		"prefix": "AnimResetGestureSlot"
	},
	"Player:AnimRestartGesture": {
		"body": [
			"AnimRestartGesture(${1:slot}, ${2:activity}, ${3:autokill=false})$0"
		],
		"description": "Restart a gesture on a player, within a gesture slot.\n\nThis is not automatically networked. This function has to be called on the client to be seen by said client.",
		"prefix": "AnimRestartGesture"
	},
	"Player:AnimRestartMainSequence": {
		"body": [
			"AnimRestartMainSequence()$0"
		],
		"description": "Restarts the main animation on the player, has the same effect as calling Entity:SetCycle( 0 ).",
		"prefix": "AnimRestartMainSequence"
	},
	"Player:AnimSetGestureSequence": {
		"body": [
			"AnimSetGestureSequence(${1:slot}, ${2:sequenceID})$0"
		],
		"description": "Sets the sequence of the animation playing in the given gesture slot.",
		"prefix": "AnimSetGestureSequence"
	},
	"Player:AnimSetGestureWeight": {
		"body": [
			"AnimSetGestureWeight(${1:slot}, ${2:weight})$0"
		],
		"description": "Sets the weight of the animation playing in the given gesture slot.",
		"prefix": "AnimSetGestureWeight"
	},
	"Player:Armor": {
		"body": [
			"Armor()$0"
		],
		"description": "Returns the player's armor.",
		"prefix": "Armor"
	},
	"Player:Ban": {
		"body": [
			"Ban(${1:minutes}, ${2:kick=false})$0"
		],
		"description": "Bans the player from the server for a certain amount of minutes.",
		"prefix": "Ban"
	},
	"Player:CanUseFlashlight": {
		"body": [
			"CanUseFlashlight()$0"
		],
		"description": "Returns true if the player's flashlight hasn't been disabled by Player:AllowFlashlight.\n\nThis is not synchronized between clients and server automatically!",
		"prefix": "CanUseFlashlight"
	},
	"Player:ChatPrint": {
		"body": [
			"ChatPrint(${1:message})$0"
		],
		"description": "Prints a string to the chatbox of the client.\n\nJust like the usermessage, this function is affected by the 255 byte limit!",
		"prefix": "ChatPrint"
	},
	"Player:CheckLimit": {
		"body": [
			"CheckLimit(${1:limitType})$0"
		],
		"description": "Checks if the limit is hit or not. If it is, it will throw a notification saying so.",
		"prefix": "CheckLimit"
	},
	"Player:ConCommand": {
		"body": [
			"ConCommand(${1:command})$0"
		],
		"description": "Runs the concommand on the player. This does not work on bots.\n\nIf you wish to directly modify the movement input of bots, use GM:StartCommand instead.\n\nSome commands/convars are blocked from being ran/changed using this function, usually to prevent harm/annoyance to clients. For a list of blocked commands, see Blocked ConCommands.\nOn clientside running a ConCommand on an other player will not throw any warnings or errors but will run the ConCommand on LocalPlayer() instead.",
		"prefix": "ConCommand"
	},
	"Player:CreateRagdoll": {
		"body": [
			"CreateRagdoll()$0"
		],
		"description": "Creates the player's death ragdoll entity and deletes the old one.\n\nThis is normally used when a player dies, to create their death ragdoll.\n\nThe ragdoll will be created with the player's properties such as Entity:GetPos, Entity:GetAngles, Player:GetPlayerColor, Entity:GetVelocity and Entity:GetModel.\n\nYou can retrieve the entity this creates with Player:GetRagdollEntity.",
		"prefix": "CreateRagdoll"
	},
	"Player:CrosshairDisable": {
		"body": [
			"CrosshairDisable()$0"
		],
		"description": "Disables the default player's crosshair. Can be reenabled with Player:CrosshairEnable. This will affect WEAPON:DoDrawCrosshair.",
		"prefix": "CrosshairDisable"
	},
	"Player:CrosshairEnable": {
		"body": [
			"CrosshairEnable()$0"
		],
		"description": "Enables the player's crosshair, if it was previously disabled via Player:CrosshairDisable.",
		"prefix": "CrosshairEnable"
	},
	"Player:Crouching": {
		"body": [
			"Crouching()$0"
		],
		"description": "Returns whether the player is crouching or not (Enums/FL flag).",
		"prefix": "Crouching"
	},
	"Player:Deaths": {
		"body": [
			"Deaths()$0"
		],
		"description": "Returns the player's death count",
		"prefix": "Deaths"
	},
	"Player:DebugInfo": {
		"body": [
			"DebugInfo()$0"
		],
		"description": "Prints the players' name and position to the console.",
		"prefix": "DebugInfo"
	},
	"Player:DetonateTripmines": {
		"body": [
			"DetonateTripmines()$0"
		],
		"description": "Detonates all tripmines belonging to the player.",
		"prefix": "DetonateTripmines"
	},
	"Player:DoAnimationEvent": {
		"body": [
			"DoAnimationEvent(${1:data})$0"
		],
		"description": "Sends a third person animation event to the player.\n\nCalls GM:DoAnimationEvent with Enums/PLAYERANIMEVENT as the event, data as the given data.",
		"prefix": "DoAnimationEvent"
	},
	"Player:DoAttackEvent": {
		"body": [
			"DoAttackEvent()$0"
		],
		"description": "Starts the player's attack animation. The attack animation is determined by the weapon's HoldType.\n\nSimilar to other animation event functions, calls GM:DoAnimationEvent with Enums/PLAYERANIMEVENT as the event and no extra data.",
		"prefix": "DoAttackEvent"
	},
	"Player:DoCustomAnimEvent": {
		"body": [
			"DoCustomAnimEvent(${1:event}, ${2:data})$0"
		],
		"description": "Sends a specified third person animation event to the player.\n\nCalls GM:DoAnimationEvent with specified arguments.",
		"prefix": "DoCustomAnimEvent"
	},
	"Player:DoReloadEvent": {
		"body": [
			"DoReloadEvent()$0"
		],
		"description": "Sends a third person reload animation event to the player.\n\nSimilar to other animation event functions, calls GM:DoAnimationEvent with Enums/PLAYERANIMEVENT as the event and no extra data.",
		"prefix": "DoReloadEvent"
	},
	"Player:DoSecondaryAttack": {
		"body": [
			"DoSecondaryAttack()$0"
		],
		"description": "Sends a third person secondary fire animation event to the player.\n\nSimilar to other animation event functions, calls GM:DoAnimationEvent with Enums/PLAYERANIMEVENT as the event and no extra data.",
		"prefix": "DoSecondaryAttack"
	},
	"Player:DrawViewModel": {
		"body": [
			"DrawViewModel(${1:draw}, ${2:vm=0})$0"
		],
		"description": "Show/Hide the player's weapon's viewmodel.",
		"prefix": "DrawViewModel"
	},
	"Player:DrawWorldModel": {
		"body": [
			"DrawWorldModel(${1:draw})$0"
		],
		"description": "Show/Hide the player's weapon's worldmodel.",
		"prefix": "DrawWorldModel"
	},
	"Player:DropNamedWeapon": {
		"body": [
			"DropNamedWeapon(${1:class}, ${2:target=nil}, ${3:velocity=nil})$0"
		],
		"description": "Drops the players' weapon of a specific class.",
		"prefix": "DropNamedWeapon"
	},
	"Player:DropObject": {
		"body": [
			"DropObject()$0"
		],
		"description": "Drops any object the player is currently holding with either gravitygun or +Use (E key)",
		"prefix": "DropObject"
	},
	"Player:DropWeapon": {
		"body": [
			"DropWeapon(${1:weapon=nil}, ${2:target=nil}, ${3:velocity=nil})$0"
		],
		"description": "Forces the player to drop the specified weapon",
		"prefix": "DropWeapon"
	},
	"Player:EnterVehicle": {
		"body": [
			"EnterVehicle(${1:vehicle})$0"
		],
		"description": "Enters the player into specified vehicle",
		"prefix": "EnterVehicle"
	},
	"Player:EquipSuit": {
		"body": [
			"EquipSuit()$0"
		],
		"description": "Equips the player with the HEV suit.\n\nAllows the player to zoom, walk slowly, sprint, pickup armor batteries, use the health and armor stations and also shows the HUD.\nThe player also emits a flatline sound on death, which can be overridden with GM:PlayerDeathSound.\n\nThe player is automatically equipped with the suit on spawn, if you wish to stop that, use Player:RemoveSuit.",
		"prefix": "EquipSuit"
	},
	"Player:ExitVehicle": {
		"body": [
			"ExitVehicle()$0"
		],
		"description": "Makes the player exit the vehicle if they're in one.",
		"prefix": "ExitVehicle"
	},
	"Player:Flashlight": {
		"body": [
			"Flashlight(${1:isOn})$0"
		],
		"description": "Enables/Disables the player's flashlight.Player:CanUseFlashlight must be true in order for the player's flashlight to be changed.",
		"prefix": "Flashlight"
	},
	"Player:FlashlightIsOn": {
		"body": [
			"FlashlightIsOn()$0"
		],
		"description": "Returns true if the player's flashlight is on.",
		"prefix": "FlashlightIsOn"
	},
	"Player:Frags": {
		"body": [
			"Frags()$0"
		],
		"description": "Returns the amount of kills a player has.",
		"prefix": "Frags"
	},
	"Player:Freeze": {
		"body": [
			"Freeze(${1:frozen=false})$0"
		],
		"description": "Freeze the player. Frozen players cannot move, look around, or attack. Key bindings are still called. Similar to Player:Lock but the player can still take damage.\n\nAdds or removes the Enums/FL flag from the player.\n\nFrozen bots will still be able to look around.",
		"prefix": "Freeze"
	},
	"Player:GetActiveWeapon": {
		"body": [
			"GetActiveWeapon()$0"
		],
		"description": "Returns the player's active weapon.\n\nIf used on a Global.LocalPlayer() and the player is spectating another player with `OBS_MODE_IN_EYE`, the weapon returned will be of the spectated player.",
		"prefix": "GetActiveWeapon"
	},
	"Player:GetAimVector": {
		"body": [
			"GetAimVector()$0"
		],
		"description": "Returns the direction that the player is aiming.",
		"prefix": "GetAimVector"
	},
	"Player:GetAllowFullRotation": {
		"body": [
			"GetAllowFullRotation()$0"
		],
		"description": "Returns true if the players' model is allowed to rotate around the pitch and roll axis.",
		"prefix": "GetAllowFullRotation"
	},
	"Player:GetAllowWeaponsInVehicle": {
		"body": [
			"GetAllowWeaponsInVehicle()$0"
		],
		"description": "Returns whether the player is allowed to use his weapons in a vehicle or not.",
		"prefix": "GetAllowWeaponsInVehicle"
	},
	"Player:GetAmmo": {
		"body": [
			"GetAmmo()$0"
		],
		"description": "Returns a table of all ammo the player has.",
		"prefix": "GetAmmo"
	},
	"Player:GetAmmoCount": {
		"body": [
			"GetAmmoCount(${1:ammotype})$0"
		],
		"description": "Gets the amount of ammo the player has.",
		"prefix": "GetAmmoCount"
	},
	"Player:GetAvoidPlayers": {
		"body": [
			"GetAvoidPlayers()$0"
		],
		"description": "Gets if the player will be pushed out of nocollided players.",
		"prefix": "GetAvoidPlayers"
	},
	"Player:GetCanWalk": {
		"body": [
			"GetCanWalk()$0"
		],
		"description": "Returns true if the player is able to walk using the (default) alt key.",
		"prefix": "GetCanWalk"
	},
	"Player:GetCanZoom": {
		"body": [
			"GetCanZoom()$0"
		],
		"description": "Determines whenever the player is allowed to use the zoom functionality.",
		"prefix": "GetCanZoom"
	},
	"Player:GetClassID": {
		"body": [
			"GetClassID()$0"
		],
		"description": "Returns the player's class id.",
		"prefix": "GetClassID"
	},
	"Player:GetCount": {
		"body": [
			"GetCount(${1:type}, ${2:minus=0})$0"
		],
		"description": "Gets total count of entities of same class.",
		"prefix": "GetCount"
	},
	"Player:GetCrouchedWalkSpeed": {
		"body": [
			"GetCrouchedWalkSpeed()$0"
		],
		"description": "Returns the crouched walk speed multiplier.\n\nSee also Player:GetWalkSpeed and Player:SetCrouchedWalkSpeed.",
		"prefix": "GetCrouchedWalkSpeed"
	},
	"Player:GetCurrentCommand": {
		"body": [
			"GetCurrentCommand()$0"
		],
		"description": "Returns the last command which was sent by the specified player. This can only be called on the player which Global.GetPredictionPlayer() returns.\n\nWhen called clientside in singleplayer during WEAPON:Think, it will return nothing as the hook is not technically predicted in that instance. See the note on the page.\n\nThis will fail in GM:StartCommand.",
		"prefix": "GetCurrentCommand"
	},
	"Player:GetCurrentViewOffset": {
		"body": [
			"GetCurrentViewOffset()$0"
		],
		"description": "Gets the **actual** view offset which equals the difference between the players actual position and their view when standing.\n\nDo not confuse with Player:GetViewOffset and Player:GetViewOffsetDucked",
		"prefix": "GetCurrentViewOffset"
	},
	"Player:GetDrivingEntity": {
		"body": [
			"GetDrivingEntity()$0"
		],
		"description": "Gets the entity the player is currently driving.",
		"prefix": "GetDrivingEntity"
	},
	"Player:GetDrivingMode": {
		"body": [
			"GetDrivingMode()$0"
		],
		"description": "Returns driving mode of the player. See Entity Driving.",
		"prefix": "GetDrivingMode"
	},
	"Player:GetDuckSpeed": {
		"body": [
			"GetDuckSpeed()$0"
		],
		"description": "Returns a player's duck speed (in seconds)",
		"prefix": "GetDuckSpeed"
	},
	"Player:GetEntityInUse": {
		"body": [
			"GetEntityInUse()$0"
		],
		"description": "Returns the entity the player is currently using, like func_tank mounted turrets or +use prop pickups.",
		"prefix": "GetEntityInUse"
	},
	"Player:GetEyeTrace": {
		"body": [
			"GetEyeTrace()$0"
		],
		"description": "Returns a table with information of what the player is looking at.\n\nThe results of this function are **cached** clientside every frame.\n\nUses util.GetPlayerTrace internally and is therefore bound by its limits.\n\nSee also Player:GetEyeTraceNoCursor.",
		"prefix": "GetEyeTrace"
	},
	"Player:GetEyeTraceNoCursor": {
		"body": [
			"GetEyeTraceNoCursor()$0"
		],
		"description": "Returns the trace according to the players view direction, ignoring their mouse (holding C and moving the mouse in Sandbox).\n\nThe results of this function are **cached** clientside every frame.\n\nUses util.GetPlayerTrace internally and is therefore bound by its limits.\n\nSee also Player:GetEyeTrace.",
		"prefix": "GetEyeTraceNoCursor"
	},
	"Player:GetFOV": {
		"body": [
			"GetFOV()$0"
		],
		"description": "Returns the FOV of the player.",
		"prefix": "GetFOV"
	},
	"Player:GetFriendStatus": {
		"body": [
			"GetFriendStatus()$0"
		],
		"description": "Returns the steam \"relationship\" towards the player.",
		"prefix": "GetFriendStatus"
	},
	"Player:GetHands": {
		"body": [
			"GetHands()$0"
		],
		"description": "Gets the hands entity of a player",
		"prefix": "GetHands"
	},
	"Player:GetHoveredWidget": {
		"body": [
			"GetHoveredWidget()$0"
		],
		"description": "Returns the widget the player is hovering with his mouse.",
		"prefix": "GetHoveredWidget"
	},
	"Player:GetHull": {
		"body": [
			"GetHull()$0"
		],
		"description": "Gets the bottom base and the top base size of the player's hull.",
		"prefix": "GetHull"
	},
	"Player:GetHullDuck": {
		"body": [
			"GetHullDuck()$0"
		],
		"description": "Gets the bottom base and the top base size of the player's crouch hull.",
		"prefix": "GetHullDuck"
	},
	"Player:GetInfo": {
		"body": [
			"GetInfo(${1:cVarName})$0"
		],
		"description": "Retrieves the value of a client-side ConVar. The ConVar must have a Enums/FCVAR flag for this to work.\n\nThe returned value is truncated to 31 bytes.",
		"prefix": "GetInfo"
	},
	"Player:GetInfoNum": {
		"body": [
			"GetInfoNum(${1:cVarName}, ${2:default})$0"
		],
		"description": "Retrieves the numeric value of a client-side convar, returns nil if value is not convertible to a number. The ConVar must have a Enums/FCVAR flag for this to work.",
		"prefix": "GetInfoNum"
	},
	"Player:GetJumpPower": {
		"body": [
			"GetJumpPower()$0"
		],
		"description": "Returns the jump power of the player",
		"prefix": "GetJumpPower"
	},
	"Player:GetLadderClimbSpeed": {
		"body": [
			"GetLadderClimbSpeed()$0"
		],
		"description": "Returns the player's ladder climbing speed.\n\nSee Player:GetWalkSpeed for normal walking speed, Player:GetRunSpeed for sprinting speed and Player:GetSlowWalkSpeed for slow walking speed.",
		"prefix": "GetLadderClimbSpeed"
	},
	"Player:GetLaggedMovementValue": {
		"body": [
			"GetLaggedMovementValue()$0"
		],
		"description": "Returns the timescale multiplier of the player movement.",
		"prefix": "GetLaggedMovementValue"
	},
	"Player:GetMaxArmor": {
		"body": [
			"GetMaxArmor()$0"
		],
		"description": "Returns the maximum amount of armor the player should have. Default value is 100.",
		"prefix": "GetMaxArmor"
	},
	"Player:GetMaxSpeed": {
		"body": [
			"GetMaxSpeed()$0"
		],
		"description": "Returns the player's maximum movement speed.\n\nSee also Player:SetMaxSpeed, Player:GetWalkSpeed and Player:GetRunSpeed.",
		"prefix": "GetMaxSpeed"
	},
	"Player:GetName": {
		"body": [
			"GetName()$0"
		],
		"description": "Returns the player's name, this is an alias of Player:Nick.\n\nThis function overrides Entity:GetName (in the Lua metatable, not in c++), keep it in mind when dealing with ents.FindByName or any engine function which requires the mapping name.",
		"prefix": "GetName"
	},
	"Player:GetNoCollideWithTeammates": {
		"body": [
			"GetNoCollideWithTeammates()$0"
		],
		"description": "Returns whenever the player is set not to collide with their teammates.",
		"prefix": "GetNoCollideWithTeammates"
	},
	"Player:GetObserverMode": {
		"body": [
			"GetObserverMode()$0"
		],
		"description": "Returns the the observer mode of the player",
		"prefix": "GetObserverMode"
	},
	"Player:GetObserverTarget": {
		"body": [
			"GetObserverTarget()$0"
		],
		"description": "Returns the entity the player is currently observing.\n\nSet using Player:SpectateEntity.",
		"prefix": "GetObserverTarget"
	},
	"Player:GetPData": {
		"body": [
			"GetPData(${1:key}, ${2:default=nil})$0"
		],
		"description": "Returns a **P**layer **Data** key-value pair from the SQL database. (sv.db when called on server,  cl.db when called on client)\n\nInternally uses the sql.\n\nThis function internally uses Player:UniqueID, which can cause collisions (two or more players sharing the same PData entry). It's recommended that you don't use it. See the related wiki page for more information.\n\nPData is not networked from servers to clients!",
		"prefix": "GetPData"
	},
	"Player:GetPlayerColor": {
		"body": [
			"GetPlayerColor()$0"
		],
		"description": "Returns a player model's color. The part of the model that is colored is determined by the model itself, and is different for each model. The format is Vector(r,g,b), and each color should be between 0 and 1.",
		"prefix": "GetPlayerColor"
	},
	"Player:GetPlayerInfo": {
		"body": [
			"GetPlayerInfo()$0"
		],
		"description": "Returns a table containing player information.",
		"prefix": "GetPlayerInfo"
	},
	"Player:GetPreferredCarryAngles": {
		"body": [
			"GetPreferredCarryAngles(${1:carryEnt})$0"
		],
		"description": "Returns the preferred carry angles of an object, if any are set.\n\nCalls GM:GetPreferredCarryAngles with the target entity and returns the carry angles.",
		"prefix": "GetPreferredCarryAngles"
	},
	"Player:GetPressedWidget": {
		"body": [
			"GetPressedWidget()$0"
		],
		"description": "Returns the widget entity the player is using.\n\nHaving a pressed widget stops the player from firing his weapon to allow input to be passed onto the widget.",
		"prefix": "GetPressedWidget"
	},
	"Player:GetPreviousWeapon": {
		"body": [
			"GetPreviousWeapon()$0"
		],
		"description": "Returns the weapon the player previously had equipped.",
		"prefix": "GetPreviousWeapon"
	},
	"Player:GetPunchAngle": {
		"body": [
			"GetPunchAngle()$0"
		],
		"description": "You should use Player:GetViewPunchAngles instead.\nReturns players screen punch effect angle.",
		"prefix": "GetPunchAngle"
	},
	"Player:GetRagdollEntity": {
		"body": [
			"GetRagdollEntity()$0"
		],
		"description": "Returns players death ragdoll. The ragdoll is created by Player:CreateRagdoll.",
		"prefix": "GetRagdollEntity"
	},
	"Player:GetRenderAngles": {
		"body": [
			"GetRenderAngles()$0"
		],
		"description": "Returns the render angles for the player.",
		"prefix": "GetRenderAngles"
	},
	"Player:GetRunSpeed": {
		"body": [
			"GetRunSpeed()$0"
		],
		"description": "Returns the player's sprint speed.\n\nSee also Player:SetRunSpeed, Player:GetWalkSpeed and Player:GetMaxSpeed.",
		"prefix": "GetRunSpeed"
	},
	"Player:GetShootPos": {
		"body": [
			"GetShootPos()$0"
		],
		"description": "Returns the position of a Player's view\n\nThis is the same as calling Entity:EyePos on the player.",
		"prefix": "GetShootPos"
	},
	"Player:GetSlowWalkSpeed": {
		"body": [
			"GetSlowWalkSpeed()$0"
		],
		"description": "Returns the player's slow walking speed, which is activated via +WALK keybind.\n\nSee Player:GetWalkSpeed for normal walking speed, Player:GetRunSpeed for sprinting speed and Player:GetLadderClimbSpeed for ladder climb speed.",
		"prefix": "GetSlowWalkSpeed"
	},
	"Player:GetStepSize": {
		"body": [
			"GetStepSize()$0"
		],
		"description": "Returns the maximum height player can step onto.",
		"prefix": "GetStepSize"
	},
	"Player:GetSuitPower": {
		"body": [
			"GetSuitPower()$0"
		],
		"description": "Returns the player's HEV suit power.\n\nThis will only work for the local player when used clientside.",
		"prefix": "GetSuitPower"
	},
	"Player:GetTimeoutSeconds": {
		"body": [
			"GetTimeoutSeconds()$0"
		],
		"description": "Returns the number of seconds that the player has been timing out for. You can check if a player is timing out with Player:IsTimingOut.",
		"prefix": "GetTimeoutSeconds"
	},
	"Player:GetTool": {
		"body": [
			"GetTool(${1:mode=nil})$0"
		],
		"description": "Returns TOOL table of players current tool, or of the one specified.",
		"prefix": "GetTool"
	},
	"Player:GetUnDuckSpeed": {
		"body": [
			"GetUnDuckSpeed()$0"
		],
		"description": "Returns a player's unduck speed (in seconds)",
		"prefix": "GetUnDuckSpeed"
	},
	"Player:GetUseEntity": {
		"body": [
			"GetUseEntity()$0"
		],
		"description": "Returns the entity the player would use if they would press their `+use` keybind.",
		"prefix": "GetUseEntity"
	},
	"Player:GetUserGroup": {
		"body": [
			"GetUserGroup()$0"
		],
		"description": "Returns the player's user group.",
		"prefix": "GetUserGroup"
	},
	"Player:GetVehicle": {
		"body": [
			"GetVehicle()$0"
		],
		"description": "Gets the vehicle the player is driving, returns NULL ENTITY if the player is not driving.",
		"prefix": "GetVehicle"
	},
	"Player:GetViewEntity": {
		"body": [
			"GetViewEntity()$0"
		],
		"description": "Returns the entity the player is using to see from (such as the player itself, the camera, or another entity).",
		"prefix": "GetViewEntity"
	},
	"Player:GetViewModel": {
		"body": [
			"GetViewModel(${1:index=0})$0"
		],
		"description": "Returns the player's view model entity by the index.\nEach player has 3 view models by default, but only the first one is used.\n\nTo use the other viewmodels in your SWEP, see Entity:SetWeaponModel.\n\nIn the Client States, other players' viewmodels are not available unless they are being spectated.",
		"prefix": "GetViewModel"
	},
	"Player:GetViewOffset": {
		"body": [
			"GetViewOffset()$0"
		],
		"description": "Returns the view offset of the player which equals the difference between the players actual position and their view.\n\nSee also Player:GetViewOffsetDucked.",
		"prefix": "GetViewOffset"
	},
	"Player:GetViewOffsetDucked": {
		"body": [
			"GetViewOffsetDucked()$0"
		],
		"description": "Returns the view offset of the player which equals the difference between the players actual position and their view when ducked.\n\nSee also Player:GetViewOffset.",
		"prefix": "GetViewOffsetDucked"
	},
	"Player:GetViewPunchAngles": {
		"body": [
			"GetViewPunchAngles()$0"
		],
		"description": "Returns players screen punch effect angle.",
		"prefix": "GetViewPunchAngles"
	},
	"Player:GetViewPunchVelocity": {
		"body": [
			"GetViewPunchVelocity()$0"
		],
		"description": "Returns client's view punch velocity. See Player:ViewPunch and Player:SetViewPunchVelocity",
		"prefix": "GetViewPunchVelocity"
	},
	"Player:GetWalkSpeed": {
		"body": [
			"GetWalkSpeed()$0"
		],
		"description": "Returns the player's normal walking speed. Not sprinting, not slow walking. (+walk)\n\nSee also Player:SetWalkSpeed, Player:GetMaxSpeed and Player:GetRunSpeed.",
		"prefix": "GetWalkSpeed"
	},
	"Player:GetWeapon": {
		"body": [
			"GetWeapon(${1:className})$0"
		],
		"description": "Returns the weapon for the specified class",
		"prefix": "GetWeapon"
	},
	"Player:GetWeaponColor": {
		"body": [
			"GetWeaponColor()$0"
		],
		"description": "Returns a player's weapon color. The part of the model that is colored is determined by the model itself, and is different for each model. The format is Vector(r,g,b), and each color should be between 0 and 1.",
		"prefix": "GetWeaponColor"
	},
	"Player:GetWeapons": {
		"body": [
			"GetWeapons()$0"
		],
		"description": "Returns a table of the player's weapons.",
		"prefix": "GetWeapons"
	},
	"Player:Give": {
		"body": [
			"Give(${1:weaponClassName}, ${2:bNoAmmo=false})$0"
		],
		"description": "Gives the player a weapon.\n\nWhile this function is meant for weapons/pickupables only, it is **not** restricted to weapons. Any entity can be spawned using this function, including NPCs and SENTs.",
		"prefix": "Give"
	},
	"Player:GiveAmmo": {
		"body": [
			"GiveAmmo(${1:amount}, ${2:type}, ${3:hidePopup=false})$0"
		],
		"description": "Gives ammo to a player",
		"prefix": "GiveAmmo"
	},
	"Player:GodDisable": {
		"body": [
			"GodDisable()$0"
		],
		"description": "Disables god mode on the player.",
		"prefix": "GodDisable"
	},
	"Player:GodEnable": {
		"body": [
			"GodEnable()$0"
		],
		"description": "Enables god mode on the player.",
		"prefix": "GodEnable"
	},
	"Player:HasGodMode": {
		"body": [
			"HasGodMode()$0"
		],
		"description": "Returns whether the player has god mode or not, contolled by Player:GodEnable and Player:GodDisable.\n\nThis is not synced between the client and server. This will cause the client to always return false even in godmode.",
		"prefix": "HasGodMode"
	},
	"Player:HasWeapon": {
		"body": [
			"HasWeapon(${1:className})$0"
		],
		"description": "Returns if the player has the specified weapon",
		"prefix": "HasWeapon"
	},
	"Player:IPAddress": {
		"body": [
			"IPAddress()$0"
		],
		"description": "Returns the player's IP address and connection port in ip:port form",
		"prefix": "IPAddress"
	},
	"Player:InVehicle": {
		"body": [
			"InVehicle()$0"
		],
		"description": "Returns if the player is in a vehicle",
		"prefix": "InVehicle"
	},
	"Player:IsAdmin": {
		"body": [
			"IsAdmin()$0"
		],
		"description": "Returns whether the player is an admin or not.",
		"prefix": "IsAdmin"
	},
	"Player:IsBot": {
		"body": [
			"IsBot()$0"
		],
		"description": "Returns if the player is an bot or not",
		"prefix": "IsBot"
	},
	"Player:IsConnected": {
		"body": [
			"IsConnected()$0"
		],
		"description": "Returns true from the point when the player is sending client info but not fully in the game until they disconnect.",
		"prefix": "IsConnected"
	},
	"Player:IsDrivingEntity": {
		"body": [
			"IsDrivingEntity()$0"
		],
		"description": "Used to find out if a player is currently 'driving' an entity (by which we mean 'right click > drive' ).",
		"prefix": "IsDrivingEntity"
	},
	"Player:IsFrozen": {
		"body": [
			"IsFrozen()$0"
		],
		"description": "Returns whether the players movement is currently frozen, controlled by Player:Freeze.",
		"prefix": "IsFrozen"
	},
	"Player:IsFullyAuthenticated": {
		"body": [
			"IsFullyAuthenticated()$0"
		],
		"description": "Returns whether the player identity was confirmed by the steam network.",
		"prefix": "IsFullyAuthenticated"
	},
	"Player:IsListenServerHost": {
		"body": [
			"IsListenServerHost()$0"
		],
		"description": "Returns if a player is the host of the current session.",
		"prefix": "IsListenServerHost"
	},
	"Player:IsMuted": {
		"body": [
			"IsMuted()$0"
		],
		"description": "Returns whether or not the player is muted locally.",
		"prefix": "IsMuted"
	},
	"Player:IsPlayingTaunt": {
		"body": [
			"IsPlayingTaunt()$0"
		],
		"description": "Returns true if the player is playing a taunt.",
		"prefix": "IsPlayingTaunt"
	},
	"Player:IsSpeaking": {
		"body": [
			"IsSpeaking()$0"
		],
		"description": "Returns whenever the player is heard by the local player.",
		"prefix": "IsSpeaking"
	},
	"Player:IsSprinting": {
		"body": [
			"IsSprinting()$0"
		],
		"description": "Returns whether the player is currently sprinting or not.",
		"prefix": "IsSprinting"
	},
	"Player:IsSuitEquipped": {
		"body": [
			"IsSuitEquipped()$0"
		],
		"description": "Returns whenever the player is equipped with the suit item.\n\nThis will only work for the local player when used clientside.",
		"prefix": "IsSuitEquipped"
	},
	"Player:IsSuperAdmin": {
		"body": [
			"IsSuperAdmin()$0"
		],
		"description": "Returns whether the player is a superadmin.",
		"prefix": "IsSuperAdmin"
	},
	"Player:IsTimingOut": {
		"body": [
			"IsTimingOut()$0"
		],
		"description": "Returns true if the player is timing out (i.e. is losing connection), false otherwise.",
		"prefix": "IsTimingOut"
	},
	"Player:IsTyping": {
		"body": [
			"IsTyping()$0"
		],
		"description": "Returns whether the player is typing in their chat.\n\nThis may not work properly if the server uses a custom chatbox.",
		"prefix": "IsTyping"
	},
	"Player:IsUserGroup": {
		"body": [
			"IsUserGroup(${1:groupname})$0"
		],
		"description": "Returns true/false if the player is in specified group or not.",
		"prefix": "IsUserGroup"
	},
	"Player:IsVoiceAudible": {
		"body": [
			"IsVoiceAudible()$0"
		],
		"description": "Returns if the player can be heard by the local player.",
		"prefix": "IsVoiceAudible"
	},
	"Player:IsWorldClicking": {
		"body": [
			"IsWorldClicking()$0"
		],
		"description": "Returns if the player is in the context menu.\n\nAlthough this is shared, it will only work properly on the CLIENT for the local player. Using this serverside or on other players will return false.",
		"prefix": "IsWorldClicking"
	},
	"Player:KeyDown": {
		"body": [
			"KeyDown(${1:key})$0"
		],
		"description": "Gets whether a key is down. This is not networked to other players, meaning only the local client can see the keys they are pressing.",
		"prefix": "KeyDown"
	},
	"Player:KeyDownLast": {
		"body": [
			"KeyDownLast(${1:key})$0"
		],
		"description": "Gets whether a key was down one tick ago.",
		"prefix": "KeyDownLast"
	},
	"Player:KeyPressed": {
		"body": [
			"KeyPressed(${1:key})$0"
		],
		"description": "Gets whether a key was just pressed this tick.",
		"prefix": "KeyPressed"
	},
	"Player:KeyReleased": {
		"body": [
			"KeyReleased(${1:key})$0"
		],
		"description": "Gets whether a key was just released this tick.",
		"prefix": "KeyReleased"
	},
	"Player:Kick": {
		"body": [
			"Kick(${1:reason=No reason given})$0"
		],
		"description": "Kicks the player from the server.\nThis can not be run before the player has fully joined in. Use game.KickID for that.",
		"prefix": "Kick"
	},
	"Player:Kill": {
		"body": [
			"Kill()$0"
		],
		"description": "Kills a player and calls GM:PlayerDeath.",
		"prefix": "Kill"
	},
	"Player:KillSilent": {
		"body": [
			"KillSilent()$0"
		],
		"description": "Kills a player without notifying the rest of the server.\n\nThis will call GM:PlayerSilentDeath instead of GM:PlayerDeath.",
		"prefix": "KillSilent"
	},
	"Player:LagCompensation": {
		"body": [
			"LagCompensation(${1:lagCompensation})$0"
		],
		"description": "This allows the server to mitigate the lag of the player by moving back all the entities that can be lag compensated to the time the player attacked with his weapon.\n\nThis technique is most commonly used on things that hit other entities instantaneously, such as traces.\n\nEntity:FireBullets calls this function internally.\n\nLag compensation only works for players and entities that have been enabled with Entity:SetLagCompensated\n\nDespite being defined shared, it can only be used server-side in a ~search:%3Cpredicted%3EYes.\n\nThis function NEEDS to be disabled after you're done with it or it will break the movement of the entities affected!\n\nLag compensation does not support pose parameters.",
		"prefix": "LagCompensation"
	},
	"Player:LastHitGroup": {
		"body": [
			"LastHitGroup()$0"
		],
		"description": "Returns the hitgroup where the player was last hit.",
		"prefix": "LastHitGroup"
	},
	"Player:LimitHit": {
		"body": [
			"LimitHit(${1:type})$0"
		],
		"description": "Shows \"limit hit\" notification in sandbox.\nThis function is only available in Sandbox and its derivatives.",
		"prefix": "LimitHit"
	},
	"Player:Lock": {
		"body": [
			"Lock()$0"
		],
		"description": "Stops a player from using any inputs, such as moving, turning, or attacking. Key binds are still called. Similar to Player:Freeze but the player takes no damage.\n\nAdds the Enums/FL and Enums/FL flags to the player.\n\nFrozen bots will still be able to look around.",
		"prefix": "Lock"
	},
	"Player:MotionSensorPos": {
		"body": [
			"MotionSensorPos(${1:bone})$0"
		],
		"description": "Returns the position of a Kinect bone.",
		"prefix": "MotionSensorPos"
	},
	"Player:Name": {
		"body": [
			"Name()$0"
		],
		"description": "Returns the players name. Identical to Player:Nick and Player:GetName.",
		"prefix": "Name"
	},
	"Player:Nick": {
		"body": [
			"Nick()$0"
		],
		"description": "Returns the player's nickname.",
		"prefix": "Nick"
	},
	"Player:OwnerSteamID64": {
		"body": [
			"OwnerSteamID64()$0"
		],
		"description": "Returns the 64-bit SteamID aka CommunityID of the Steam Account that owns the Garry's Mod license this player is using. This is useful for detecting players using Steam Family Sharing.\n\nIf player is not using Steam Family Sharing, this will return the player's actual SteamID64().\n\nThis data will only be available after the player has fully authenticated with Steam. See Player:IsFullyAuthenticated.",
		"prefix": "OwnerSteamID64"
	},
	"Player:PacketLoss": {
		"body": [
			"PacketLoss()$0"
		],
		"description": "Returns the packet loss of the client. It is not networked so it only returns 0 when run clientside.",
		"prefix": "PacketLoss"
	},
	"Player:PhysgunUnfreeze": {
		"body": [
			"PhysgunUnfreeze()$0"
		],
		"description": "Unfreezes the props player is looking at. This is essentially the same as pressing reload with the physics gun, including double press for unfreeze all.",
		"prefix": "PhysgunUnfreeze"
	},
	"Player:PickupObject": {
		"body": [
			"PickupObject(${1:entity})$0"
		],
		"description": "This makes the player hold ( same as pressing E on a small prop ) the provided entity.\n\nDon't get this confused with picking up items like ammo or health kits\n\nThis picks up the passed entity regardless of its mass or distance from the player",
		"prefix": "PickupObject"
	},
	"Player:PickupWeapon": {
		"body": [
			"PickupWeapon(${1:wep}, ${2:ammoOnly=false})$0"
		],
		"description": "Forces the player to pickup an existing weapon entity. The player will not pick up the weapon if they already own a weapon of given type, or if the player could not normally have this weapon in their inventory.\n\nThis function **will** bypass GM:PlayerCanPickupWeapon.",
		"prefix": "PickupWeapon"
	},
	"Player:Ping": {
		"body": [
			"Ping()$0"
		],
		"description": "Returns the player's ping to server.",
		"prefix": "Ping"
	},
	"Player:PlayStepSound": {
		"body": [
			"PlayStepSound(${1:volume})$0"
		],
		"description": "Plays the correct step sound according to what the player is staying on.",
		"prefix": "PlayStepSound"
	},
	"Player:PrintMessage": {
		"body": [
			"PrintMessage(${1:type}, ${2:message})$0"
		],
		"description": "Displays a message either in their chat, console, or center of the screen. See also Global.PrintMessage.\n\nWhen called serverside, this uses the archaic user message system (the umsg) and hence is limited to \u00e2\u2030\u02c6250 characters.\n\n`HUD_PRINTCENTER` will not work when this is called clientside.",
		"prefix": "PrintMessage"
	},
	"Player:RemoveAllAmmo": {
		"body": [
			"RemoveAllAmmo()$0"
		],
		"description": "Removes all ammo from a certain player",
		"prefix": "RemoveAllAmmo"
	},
	"Player:RemoveAllItems": {
		"body": [
			"RemoveAllItems()$0"
		],
		"description": "Removes all weapons and ammo from the player.",
		"prefix": "RemoveAllItems"
	},
	"Player:RemoveAmmo": {
		"body": [
			"RemoveAmmo(${1:ammoCount}, ${2:ammoName})$0"
		],
		"description": "Removes the amount of the specified ammo from the player.",
		"prefix": "RemoveAmmo"
	},
	"Player:RemovePData": {
		"body": [
			"RemovePData(${1:key})$0"
		],
		"description": "Removes a **P**layer **Data** key-value pair from the SQL database. (sv.db when called on server,  cl.db when called on client)\n\nInternally uses the sql.\n\nThis function internally uses Player:UniqueID, which can cause collisions (two or more players sharing the same PData entry). It's recommended that you don't use it. See the related wiki page for more information.",
		"prefix": "RemovePData"
	},
	"Player:RemoveSuit": {
		"body": [
			"RemoveSuit()$0"
		],
		"description": "Strips the player's suit item.",
		"prefix": "RemoveSuit"
	},
	"Player:ResetHull": {
		"body": [
			"ResetHull()$0"
		],
		"description": "Resets both normal and duck hulls to their default values.",
		"prefix": "ResetHull"
	},
	"Player:Say": {
		"body": [
			"Say(${1:text}, ${2:teamOnly=false})$0"
		],
		"description": "Forces the player to say whatever the first argument is. Works on bots too.\n\nThis function ignores the default chat message cooldown",
		"prefix": "Say"
	},
	"Player:ScreenFade": {
		"body": [
			"ScreenFade(${1:flags}, ${2:clr=color_white}, ${3:fadeTime}, ${4:fadeHold})$0"
		],
		"description": "Fades the screen",
		"prefix": "ScreenFade"
	},
	"Player:SelectWeapon": {
		"body": [
			"SelectWeapon(${1:className})$0"
		],
		"description": "Sets the active weapon of the player by its class name.\n\nThis will switch the weapon out of prediction, causing delay on the client and WEAPON:Deploy and WEAPON:Holster to be called out of prediction. Try using CUserCmd:SelectWeapon or input.SelectWeapon, instead.\n\nThis will trigger the weapon switch event and associated animations. To switch weapons silently, use Player:SetActiveWeapon.",
		"prefix": "SelectWeapon"
	},
	"Player:SendHint": {
		"body": [
			"SendHint(${1:name}, ${2:delay})$0"
		],
		"description": "Sends a hint to a player.\n\nThis function is only available in Sandbox and its derivatives. Since this adds `#Hint_` to the beginning of each message, you should only use it with default hint messages, or those cached with language.Add. For hints with custom text, look at notification.AddLegacy.",
		"prefix": "SendHint"
	},
	"Player:SendLua": {
		"body": [
			"SendLua(${1:script})$0"
		],
		"description": "Executes a simple Lua string on the player.\nIf you need to use this function more than once consider using net library. Send net message and make the entire code you want to execute in net.Receive on client.\n\nThe string is limited to 254 bytes. Consider using the Net_Library_Usage for more advanced server-client interaction.",
		"prefix": "SendLua"
	},
	"Player:SetActiveWeapon": {
		"body": [
			"SetActiveWeapon(${1:weapon})$0"
		],
		"description": "Sets the player's active weapon. You should use CUserCmd:SelectWeapon or Player:SelectWeapon, instead in most cases.\n\nThis function will not trigger the weapon switch events or associated equip animations. It will bypass\nGM:PlayerSwitchWeapon and the currently active weapon's WEAPON:Holster return value.",
		"prefix": "SetActiveWeapon"
	},
	"Player:SetAllowFullRotation": {
		"body": [
			"SetAllowFullRotation(${1:Allowed})$0"
		],
		"description": "Set if the players' model is allowed to rotate around the pitch and roll axis.",
		"prefix": "SetAllowFullRotation"
	},
	"Player:SetAllowWeaponsInVehicle": {
		"body": [
			"SetAllowWeaponsInVehicle(${1:allow})$0"
		],
		"description": "Allows player to use his weapons in a vehicle. You need to call this before entering a vehicle.\n\nShooting in a vehicle fires two bullets.\n\nWeapon viewpunch does not decay while in a vehicle, leading to incorrect aim angles.",
		"prefix": "SetAllowWeaponsInVehicle"
	},
	"Player:SetAmmo": {
		"body": [
			"SetAmmo(${1:ammoCount}, ${2:ammoType})$0"
		],
		"description": "Sets the amount of the specified ammo for the player.",
		"prefix": "SetAmmo"
	},
	"Player:SetArmor": {
		"body": [
			"SetArmor(${1:Amount})$0"
		],
		"description": "Sets the player armor to the argument.",
		"prefix": "SetArmor"
	},
	"Player:SetAvoidPlayers": {
		"body": [
			"SetAvoidPlayers(${1:avoidPlayers})$0"
		],
		"description": "Pushes the player away from another player whenever it's inside the other players bounding box.",
		"prefix": "SetAvoidPlayers"
	},
	"Player:SetCanWalk": {
		"body": [
			"SetCanWalk(${1:abletowalk})$0"
		],
		"description": "Set if the player should be allowed to walk using the (default) alt key.",
		"prefix": "SetCanWalk"
	},
	"Player:SetCanZoom": {
		"body": [
			"SetCanZoom(${1:canZoom})$0"
		],
		"description": "Sets whether the player can use the HL2 suit zoom (\"+zoom\" bind) or not.",
		"prefix": "SetCanZoom"
	},
	"Player:SetClassID": {
		"body": [
			"SetClassID(${1:classID})$0"
		],
		"description": "Sets the player's class id.",
		"prefix": "SetClassID"
	},
	"Player:SetCrouchedWalkSpeed": {
		"body": [
			"SetCrouchedWalkSpeed(${1:speed})$0"
		],
		"description": "Sets the crouched walk speed multiplier.\n\nDoesn't work for values above 1.\n\nSee also Player:SetWalkSpeed and Player:GetCrouchedWalkSpeed.",
		"prefix": "SetCrouchedWalkSpeed"
	},
	"Player:SetCurrentViewOffset": {
		"body": [
			"SetCurrentViewOffset(${1:viewOffset})$0"
		],
		"description": "Sets the **actual** view offset which equals the difference between the players actual position and their view when standing.\n\nDo not confuse with Player:SetViewOffset and Player:SetViewOffsetDucked",
		"prefix": "SetCurrentViewOffset"
	},
	"Player:SetDSP": {
		"body": [
			"SetDSP(${1:soundFilter}, ${2:fastReset})$0"
		],
		"description": "Applies the specified sound filter to the player.",
		"prefix": "SetDSP"
	},
	"Player:SetDeaths": {
		"body": [
			"SetDeaths(${1:deathcount})$0"
		],
		"description": "Sets a player's death count",
		"prefix": "SetDeaths"
	},
	"Player:SetDrivingEntity": {
		"body": [
			"SetDrivingEntity(${1:drivingEntity=NULL}, ${2:drivingMode})$0"
		],
		"description": "\nSets the driving entity and driving mode.\n\nUse drive.PlayerStartDriving instead, see Entity Driving.",
		"prefix": "SetDrivingEntity"
	},
	"Player:SetDuckSpeed": {
		"body": [
			"SetDuckSpeed(${1:duckSpeed})$0"
		],
		"description": "Sets how quickly a player ducks.\n\nThis will not work for values >= 1.",
		"prefix": "SetDuckSpeed"
	},
	"Player:SetEyeAngles": {
		"body": [
			"SetEyeAngles(${1:angle})$0"
		],
		"description": "Sets the angle of the player's view (may rotate body too if angular difference is large)",
		"prefix": "SetEyeAngles"
	},
	"Player:SetFOV": {
		"body": [
			"SetFOV(${1:fov}, ${2:time=0}, ${3:requester=self})$0"
		],
		"description": "Set a player's FOV (Field Of View) over a certain amount of time.",
		"prefix": "SetFOV"
	},
	"Player:SetFrags": {
		"body": [
			"SetFrags(${1:fragcount})$0"
		],
		"description": "Sets a player's frags (kills)",
		"prefix": "SetFrags"
	},
	"Player:SetHands": {
		"body": [
			"SetHands(${1:hands})$0"
		],
		"description": "Sets the hands entity of a player.\n\nThe hands entity is an entity introduced in Garry's Mod 13 and it's used to show the player's hands attached to the viewmodel.\nThis is similar to the approach used in L4D and CS:GO, for more information on how to implement this system in your gamemode visit Using Viewmodel Hands.",
		"prefix": "SetHands"
	},
	"Player:SetHoveredWidget": {
		"body": [
			"SetHoveredWidget(${1:widget=NULL})$0"
		],
		"description": "Sets the widget that is currently hovered by the player's mouse.",
		"prefix": "SetHoveredWidget"
	},
	"Player:SetHull": {
		"body": [
			"SetHull(${1:hullMins}, ${2:hullMaxs})$0"
		],
		"description": "Sets the mins and maxs of the AABB of the players collision.\n\nSee Player:SetHullDuck for the hull while crouching/ducking.\n\nSetting both the mins and maxs to Global.Vector(0,0,0) will crash the game.",
		"prefix": "SetHull"
	},
	"Player:SetHullDuck": {
		"body": [
			"SetHullDuck(${1:hullMins}, ${2:hullMaxs})$0"
		],
		"description": "Sets the mins and maxs of the AABB of the players collision when ducked.\n\nSee Player:SetHull for setting the hull while standing.",
		"prefix": "SetHullDuck"
	},
	"Player:SetJumpPower": {
		"body": [
			"SetJumpPower(${1:jumpPower})$0"
		],
		"description": "Sets the jump power, eg. the velocity the player will applied to when he jumps.",
		"prefix": "SetJumpPower"
	},
	"Player:SetLadderClimbSpeed": {
		"body": [
			"SetLadderClimbSpeed(${1:speed})$0"
		],
		"description": "Sets the player's ladder climbing speed.\n\nSee Player:SetWalkSpeed for normal walking speed, Player:SetRunSpeed for sprinting speed and Player:SetSlowWalkSpeed for slow walking speed.",
		"prefix": "SetLadderClimbSpeed"
	},
	"Player:SetLaggedMovementValue": {
		"body": [
			"SetLaggedMovementValue(${1:timescale})$0"
		],
		"description": "Slows down the player movement simulation by the timescale, this is used internally in the HL2 weapon stripping sequence.\n\nIt achieves such behavior by multiplying the Global.FrameTime by the specified timescale at the start of the movement simulation and then restoring it afterwards.\n\nThis is reset to 1 on spawn.\n\nThere is no weapon counterpart to this, you'll have to hardcode the multiplier in the weapon or call Weapon:SetNextPrimaryFire / Weapon:SetNextSecondaryFire manually from a.",
		"prefix": "SetLaggedMovementValue"
	},
	"Player:SetLastHitGroup": {
		"body": [
			"SetLastHitGroup(${1:hitgroup})$0"
		],
		"description": "Sets the hitgroup where the player was last hit.",
		"prefix": "SetLastHitGroup"
	},
	"Player:SetMaxArmor": {
		"body": [
			"SetMaxArmor(${1:maxarmor})$0"
		],
		"description": "Sets the maximum amount of armor the player should have. This affects default built-in armor pickups, but not Player:SetArmor.\nThis limit isn't reset after a player respawn. For example, this means if you set the max armor to 50 and the player dies, the limit will always be 50 instead of the limit set by the player's class (like Entity:SetMaxHealth). **This will be fixed in the next update.**.",
		"prefix": "SetMaxArmor"
	},
	"Player:SetMaxSpeed": {
		"body": [
			"SetMaxSpeed(${1:walkSpeed})$0"
		],
		"description": "Sets the maximum speed which the player can move at.\n\nThis is called automatically by the engine. If you wish to limit player speed without setting their run/sprint speeds, see CMoveData:SetMaxClientSpeed.",
		"prefix": "SetMaxSpeed"
	},
	"Player:SetMuted": {
		"body": [
			"SetMuted(${1:mute})$0"
		],
		"description": "Sets if the player should be muted locally.",
		"prefix": "SetMuted"
	},
	"Player:SetNoCollideWithTeammates": {
		"body": [
			"SetNoCollideWithTeammates(${1:shouldNotCollide})$0"
		],
		"description": "Sets whenever the player should not collide with their teammates.",
		"prefix": "SetNoCollideWithTeammates"
	},
	"Player:SetNoTarget": {
		"body": [
			"SetNoTarget(${1:visibility})$0"
		],
		"description": "Sets the players visibility towards NPCs.\n\nInternally this toggles the Enums/FL flag, which you can manually test for using Entity:IsFlagSet",
		"prefix": "SetNoTarget"
	},
	"Player:SetObserverMode": {
		"body": [
			"SetObserverMode(${1:mode})$0"
		],
		"description": "Sets the players observer mode. You must start the spectating first with Player:Spectate.",
		"prefix": "SetObserverMode"
	},
	"Player:SetPData": {
		"body": [
			"SetPData(${1:key}, ${2:value})$0"
		],
		"description": "Writes a **P**layer **Data** key-value pair to the SQL database. (sv.db when called on server,  cl.db when called on client)\n\nInternally uses the sql.\n\nThis function internally uses Player:UniqueID, which can cause collisions (two or more players sharing the same PData entry). It's recommended that you don't use it. See the related wiki page for more information.\n\nPData is not networked from servers to clients!",
		"prefix": "SetPData"
	},
	"Player:SetPlayerColor": {
		"body": [
			"SetPlayerColor(${1:Color})$0"
		],
		"description": "Sets the player model's color. The part of the model that is colored is determined by the model itself, and is different for each model.",
		"prefix": "SetPlayerColor"
	},
	"Player:SetPressedWidget": {
		"body": [
			"SetPressedWidget(${1:pressedWidget=NULL})$0"
		],
		"description": "Sets the widget that is currently in use by the player's mouse.\n\nHaving a pressed widget stops the player from firing his weapon to allow input to be passed onto the widget.",
		"prefix": "SetPressedWidget"
	},
	"Player:SetRenderAngles": {
		"body": [
			"SetRenderAngles(${1:ang})$0"
		],
		"description": "Sets the render angles of a player.",
		"prefix": "SetRenderAngles"
	},
	"Player:SetRunSpeed": {
		"body": [
			"SetRunSpeed(${1:runSpeed})$0"
		],
		"description": "Sets the player's sprint speed.\n\nSee also Player:GetRunSpeed, Player:SetWalkSpeed and Player:SetMaxSpeed.\nplayer_default class run speed is: 600",
		"prefix": "SetRunSpeed"
	},
	"Player:SetSlowWalkSpeed": {
		"body": [
			"SetSlowWalkSpeed(${1:speed})$0"
		],
		"description": "Sets the player's slow walking speed, which is activated via +WALK keybind.\n\nSee Player:SetWalkSpeed for normal walking speed, Player:SetRunSpeed for sprinting speed and Player:SetLadderClimbSpeed for ladder climb speed.",
		"prefix": "SetSlowWalkSpeed"
	},
	"Player:SetStepSize": {
		"body": [
			"SetStepSize(${1:stepHeight})$0"
		],
		"description": "Sets the maximum height a player can step onto without jumping.",
		"prefix": "SetStepSize"
	},
	"Player:SetSuitPower": {
		"body": [
			"SetSuitPower(${1:power})$0"
		],
		"description": "Sets the player's HEV suit power.\n\nThis will only work for the local player when used clientside.",
		"prefix": "SetSuitPower"
	},
	"Player:SetSuppressPickupNotices": {
		"body": [
			"SetSuppressPickupNotices(${1:doSuppress})$0"
		],
		"description": "Sets whenever to suppress the pickup notification for the player.",
		"prefix": "SetSuppressPickupNotices"
	},
	"Player:SetTeam": {
		"body": [
			"SetTeam(${1:Team})$0"
		],
		"description": "Sets the player to the chosen team.",
		"prefix": "SetTeam"
	},
	"Player:SetUnDuckSpeed": {
		"body": [
			"SetUnDuckSpeed(${1:UnDuckSpeed})$0"
		],
		"description": "Sets how quickly a player un-ducks",
		"prefix": "SetUnDuckSpeed"
	},
	"Player:SetUserGroup": {
		"body": [
			"SetUserGroup(${1:groupName})$0"
		],
		"description": "Sets the usergroup of the player.",
		"prefix": "SetUserGroup"
	},
	"Player:SetViewEntity": {
		"body": [
			"SetViewEntity(${1:viewEntity})$0"
		],
		"description": "Attaches the players view to the position and angles of the specified entity.",
		"prefix": "SetViewEntity"
	},
	"Player:SetViewOffset": {
		"body": [
			"SetViewOffset(${1:viewOffset})$0"
		],
		"description": "Sets the **desired** view offset which equals the difference between the players actual position and their view when standing.\n\nIf you want to set **actual** view offset, use Player:SetCurrentViewOffset\n\nSee also Player:SetViewOffsetDucked for **desired** view offset when crouching.",
		"prefix": "SetViewOffset"
	},
	"Player:SetViewOffsetDucked": {
		"body": [
			"SetViewOffsetDucked(${1:viewOffset})$0"
		],
		"description": "Sets the **desired** view offset which equals the difference between the players actual position and their view when crouching.\n\nIf you want to set **actual** view offset, use Player:SetCurrentViewOffset\n\nSee also Player:SetViewOffset for **desired** view offset when standing.",
		"prefix": "SetViewOffsetDucked"
	},
	"Player:SetViewPunchAngles": {
		"body": [
			"SetViewPunchAngles(${1:punchAngle})$0"
		],
		"description": "Sets client's view punch angle, but not the velocity. See Player:ViewPunch",
		"prefix": "SetViewPunchAngles"
	},
	"Player:SetViewPunchVelocity": {
		"body": [
			"SetViewPunchVelocity(${1:punchVel})$0"
		],
		"description": "Sets client's view punch velocity. See Player:ViewPunch and Player:SetViewPunchAngles",
		"prefix": "SetViewPunchVelocity"
	},
	"Player:SetWalkSpeed": {
		"body": [
			"SetWalkSpeed(${1:walkSpeed})$0"
		],
		"description": "Sets the player's normal walking speed. Not sprinting, not slow walking +walk.\n\n\nSee also Player:SetSlowWalkSpeed, Player:GetWalkSpeed, Player:SetCrouchedWalkSpeed, Player:SetMaxSpeed and Player:SetRunSpeed.\n\nUsing a speed of 0 can lead to prediction errors.\nplayer_default class run speed is: 400",
		"prefix": "SetWalkSpeed"
	},
	"Player:SetWeaponColor": {
		"body": [
			"SetWeaponColor(${1:Color})$0"
		],
		"description": "Sets the player weapon's color. The part of the model that is colored is determined by the model itself, and is different for each model.",
		"prefix": "SetWeaponColor"
	},
	"Player:SetupHands": {
		"body": [
			"SetupHands(${1:ent})$0"
		],
		"description": "Sets up the players view model hands. Calls GM:PlayerSetHandsModel to set the model of the hands.",
		"prefix": "SetupHands"
	},
	"Player:ShouldDrawLocalPlayer": {
		"body": [
			"ShouldDrawLocalPlayer()$0"
		],
		"description": "Returns whether the player's player model will be drawn at the time the function is called.",
		"prefix": "ShouldDrawLocalPlayer"
	},
	"Player:ShouldDropWeapon": {
		"body": [
			"ShouldDropWeapon(${1:drop})$0"
		],
		"description": "Sets whether the player's current weapon should drop on death.\n\nThis is reset on spawn to the Player_Classes's **DropWeaponOnDie** field by player_manager.OnPlayerSpawn.",
		"prefix": "ShouldDropWeapon"
	},
	"Player:ShowProfile": {
		"body": [
			"ShowProfile()$0"
		],
		"description": "Opens the player steam profile page in the steam overlay browser.",
		"prefix": "ShowProfile"
	},
	"Player:SimulateGravGunDrop": {
		"body": [
			"SimulateGravGunDrop(${1:ent})$0"
		],
		"description": "Signals the entity that it was dropped by the gravity gun.",
		"prefix": "SimulateGravGunDrop"
	},
	"Player:SimulateGravGunPickup": {
		"body": [
			"SimulateGravGunPickup(${1:ent})$0"
		],
		"description": "Signals the entity that it was picked up by the gravity gun. This call is only required if you want to simulate the situation of picking up objects.",
		"prefix": "SimulateGravGunPickup"
	},
	"Player:Spectate": {
		"body": [
			"Spectate(${1:mode})$0"
		],
		"description": "Starts spectate mode for given player. This will also affect the players movetype in some cases.\n\nUsing this function while spectating the player's own ragdoll will cause it to teleport it to the center of the map. You will spectate the ragdoll even after it's been teleported. This only happens on the client of the player spectating the ragdoll and is purely client-side.",
		"prefix": "Spectate"
	},
	"Player:SpectateEntity": {
		"body": [
			"SpectateEntity(${1:entity})$0"
		],
		"description": "Makes the player spectate the entity.\n\nTo get the applied spectated entity, use Player:GetObserverTarget.",
		"prefix": "SpectateEntity"
	},
	"Player:SprayDecal": {
		"body": [
			"SprayDecal(${1:sprayOrigin}, ${2:sprayEndPos})$0"
		],
		"description": "Makes a player spray their decal.",
		"prefix": "SprayDecal"
	},
	"Player:SprintDisable": {
		"body": [
			"SprintDisable()$0"
		],
		"description": "Disables the sprint on the player.\n\nNot working - use Player:SetRunSpeed or CMoveData:SetMaxSpeed in a GM:Move hook, instead.",
		"prefix": "SprintDisable"
	},
	"Player:SprintEnable": {
		"body": [
			"SprintEnable()$0"
		],
		"description": "Enables the sprint on the player.\n\nNot working - use Player:SetRunSpeed or CMoveData:SetMaxSpeed in a GM:Move hook, instead.",
		"prefix": "SprintEnable"
	},
	"Player:StartSprinting": {
		"body": [
			"StartSprinting()$0"
		],
		"description": "This appears to be a direct binding to internal functionality that is overridden by the engine every frame so calling these functions may not have any or expected effect.\n\nDoesn't appear to do anything.",
		"prefix": "StartSprinting"
	},
	"Player:StartWalking": {
		"body": [
			"StartWalking()$0"
		],
		"description": "This appears to be a direct binding to internal functionality that is overridden by the engine every frame so calling these functions may not have any or expected effect.\n\nWhen used in a GM:SetupMove hook, this function will force the player to walk, as well as preventing the player from sprinting.",
		"prefix": "StartWalking"
	},
	"Player:SteamID": {
		"body": [
			"SteamID()$0"
		],
		"description": "Returns the player's SteamID. In singleplayer, this will be STEAM_ID_PENDING serverside.\n\nFor Bots this will return `BOT` on the server and on the client it returns `NULL`.\n\nUse Player:AccountID for a shorter version of the SteamID.",
		"prefix": "SteamID"
	},
	"Player:SteamID64": {
		"body": [
			"SteamID64()$0"
		],
		"description": "Returns the player's 64-bit SteamID aka CommunityID.\n\nSee Player:AccountID for a shorter version of the SteamID.\n\nIn singleplayer, this will return `no value` serverside.\n\nIn a `-multirun` environment, this will return `no value` serverside for all \"copies\" of a player.\n\nFor bots, this will return `90071996842377216` (equivalent to `STEAM_0:0:0`) for the first bot to join.\n\nFor each additional bot, the number increases by 1. So the next bot will be `90071996842377217` (`STEAM_0:1:0`) then `90071996842377218` (`STEAM_0:0:1`) and so on.\n\nIt returns `no value` for bots clientside.\n",
		"prefix": "SteamID64"
	},
	"Player:StopSprinting": {
		"body": [
			"StopSprinting()$0"
		],
		"description": "This appears to be a direct binding to internal functionality that is overridden by the engine every frame so calling these functions may not have any or expected effect.\n\nWhen used in a GM:SetupMove hook, this function will prevent the player from sprinting.\n\nWhen +walk is engaged, the player will still be able to sprint to half speed (normal run speed) as opposed to full sprint speed without this function.",
		"prefix": "StopSprinting"
	},
	"Player:StopWalking": {
		"body": [
			"StopWalking()$0"
		],
		"description": "This appears to be a direct binding to internal functionality that is overridden by the engine every frame so calling these functions may not have any or expected effect.\n\nWhen used in a GM:SetupMove hook, this function behaves unexpectedly by preventing the player from sprinting similar to Player:StopSprinting.",
		"prefix": "StopWalking"
	},
	"Player:StopZooming": {
		"body": [
			"StopZooming()$0"
		],
		"description": "Turns off the zoom mode of the player. (+zoom console command)\n\nBasically equivalent of entering \"-zoom\" into player's console.",
		"prefix": "StopZooming"
	},
	"Player:StripAmmo": {
		"body": [
			"StripAmmo()$0"
		],
		"description": "Removes all ammo from the player.",
		"prefix": "StripAmmo"
	},
	"Player:StripWeapon": {
		"body": [
			"StripWeapon(${1:weapon})$0"
		],
		"description": "Removes the specified weapon class from a certain player",
		"prefix": "StripWeapon"
	},
	"Player:StripWeapons": {
		"body": [
			"StripWeapons()$0"
		],
		"description": "Removes all weapons from a certain player",
		"prefix": "StripWeapons"
	},
	"Player:SuppressHint": {
		"body": [
			"SuppressHint(${1:name})$0"
		],
		"description": "Prevents a hint from showing up.\n\n\nThis function is only available in Sandbox and its derivatives",
		"prefix": "SuppressHint"
	},
	"Player:SwitchToDefaultWeapon": {
		"body": [
			"SwitchToDefaultWeapon()$0"
		],
		"description": "Attempts to switch the player weapon to the one specified in the \"cl_defaultweapon\" convar, if the player does not own the specified weapon nothing will happen.\n\nIf you want to switch to a specific weapon, use: Player:SetActiveWeapon",
		"prefix": "SwitchToDefaultWeapon"
	},
	"Player:Team": {
		"body": [
			"Team()$0"
		],
		"description": "Returns the player's team ID.\n\nReturns 0 clientside when the game is not fully loaded.",
		"prefix": "Team"
	},
	"Player:TimeConnected": {
		"body": [
			"TimeConnected()$0"
		],
		"description": "Returns the time in seconds since the player connected.\nBots will always return value 0.",
		"prefix": "TimeConnected"
	},
	"Player:TraceHullAttack": {
		"body": [
			"TraceHullAttack(${1:startPos}, ${2:endPos}, ${3:mins}, ${4:maxs}, ${5:damage}, ${6:damageFlags}, ${7:damageForce}, ${8:damageAllNPCs})$0"
		],
		"description": "Performs a trace hull and applies damage to the entities hit, returns the first entity hit.\n\nHitting the victim entity with this function in ENTITY:OnTakeDamage can cause infinite loops.",
		"prefix": "TraceHullAttack"
	},
	"Player:TranslateWeaponActivity": {
		"body": [
			"TranslateWeaponActivity(${1:act})$0"
		],
		"description": "Translates Enums/ACT according to the holdtype of players currently held weapon.",
		"prefix": "TranslateWeaponActivity"
	},
	"Player:UnLock": {
		"body": [
			"UnLock()$0"
		],
		"description": "Unlocks the player movement if locked previously.\n\nWill disable godmode for the player if locked previously.",
		"prefix": "UnLock"
	},
	"Player:UnSpectate": {
		"body": [
			"UnSpectate()$0"
		],
		"description": "Stops the player from spectating another entity.",
		"prefix": "UnSpectate"
	},
	"Player:UnfreezePhysicsObjects": {
		"body": [
			"UnfreezePhysicsObjects()$0"
		],
		"description": "Unfreezes all objects the player has frozen with their Physics Gun. Same as double pressing R while holding Physics Gun.",
		"prefix": "UnfreezePhysicsObjects"
	},
	"Player:UniqueID": {
		"body": [
			"UniqueID()$0"
		],
		"description": "**This function has collisions,** where more than one player has the same UniqueID. It is **highly** recommended to use Player:AccountID, Player:SteamID or Player:SteamID64 instead, which are guaranteed to be unique to each player.\n\nReturns a 32 bit integer that remains constant for a player across joins/leaves and across different servers. This can be used when a string is inappropriate - e.g. in a database primary key.\n\nIn Singleplayer, this function will always return 1.",
		"prefix": "UniqueID"
	},
	"Player:UniqueIDTable": {
		"body": [
			"UniqueIDTable(${1:key})$0"
		],
		"description": "Returns a table that will stay allocated for the specific player between connects until the server shuts down. Note, that this table is not synchronized between client and server.",
		"prefix": "UniqueIDTable"
	},
	"Player:UserID": {
		"body": [
			"UserID()$0"
		],
		"description": "Returns the player's ID.\nYou can use Global.Player() to get the player by their ID.",
		"prefix": "UserID"
	},
	"Player:ViewPunch": {
		"body": [
			"ViewPunch(${1:PunchAngle})$0"
		],
		"description": "Simulates a push on the client's screen. This **adds** view punch velocity, and does not touch the current view punch angle, for which you can use Player:SetViewPunchAngles.",
		"prefix": "ViewPunch"
	},
	"Player:ViewPunchReset": {
		"body": [
			"ViewPunchReset(${1:tolerance=0})$0"
		],
		"description": "Resets the player's view punch (and the view punch velocity, read more at Player:ViewPunch) effect back to normal.",
		"prefix": "ViewPunchReset"
	},
	"Player:VoiceVolume": {
		"body": [
			"VoiceVolume()$0"
		],
		"description": "Returns the players voice volume, how loud the player's voice communication currently is, as a normal number. Doesn't work on local player unless the voice_loopback convar is set to 1.",
		"prefix": "VoiceVolume"
	},
	"ProjectedTexture:GetAngles": {
		"body": [
			"GetAngles()$0"
		],
		"description": "Returns the angle of the ProjectedTexture, which were previously set by ProjectedTexture:SetAngles",
		"prefix": "GetAngles"
	},
	"ProjectedTexture:GetBrightness": {
		"body": [
			"GetBrightness()$0"
		],
		"description": "Returns the brightness of the ProjectedTexture, which was previously set by ProjectedTexture:SetBrightness",
		"prefix": "GetBrightness"
	},
	"ProjectedTexture:GetColor": {
		"body": [
			"GetColor()$0"
		],
		"description": "Returns the color of the ProjectedTexture, which was previously set by ProjectedTexture:SetColor.\n\nThe returned color will not have the color metatable.",
		"prefix": "GetColor"
	},
	"ProjectedTexture:GetConstantAttenuation": {
		"body": [
			"GetConstantAttenuation()$0"
		],
		"description": "Returns the constant attenuation of the projected texture, which can also be set by ProjectedTexture:SetConstantAttenuation.",
		"prefix": "GetConstantAttenuation"
	},
	"ProjectedTexture:GetEnableShadows": {
		"body": [
			"GetEnableShadows()$0"
		],
		"description": "Returns whether shadows are enabled for this ProjectedTexture, which was previously set by ProjectedTexture:SetEnableShadows",
		"prefix": "GetEnableShadows"
	},
	"ProjectedTexture:GetFarZ": {
		"body": [
			"GetFarZ()$0"
		],
		"description": "Returns the projection distance of the ProjectedTexture, which was previously set by ProjectedTexture:SetFarZ",
		"prefix": "GetFarZ"
	},
	"ProjectedTexture:GetHorizontalFOV": {
		"body": [
			"GetHorizontalFOV()$0"
		],
		"description": "Returns the horizontal FOV of the ProjectedTexture, which was previously set by ProjectedTexture:SetHorizontalFOV or ProjectedTexture:SetFOV",
		"prefix": "GetHorizontalFOV"
	},
	"ProjectedTexture:GetLinearAttenuation": {
		"body": [
			"GetLinearAttenuation()$0"
		],
		"description": "Returns the linear attenuation of the projected texture, which can also be set by ProjectedTexture:SetLinearAttenuation.",
		"prefix": "GetLinearAttenuation"
	},
	"ProjectedTexture:GetNearZ": {
		"body": [
			"GetNearZ()$0"
		],
		"description": "Returns the NearZ value of the ProjectedTexture, which was previously set by ProjectedTexture:SetNearZ",
		"prefix": "GetNearZ"
	},
	"ProjectedTexture:GetOrthographic": {
		"body": [
			"GetOrthographic()$0"
		],
		"description": "Returns the current orthographic settings of the Projected Texture. To set these values, use ProjectedTexture:SetOrthographic.",
		"prefix": "GetOrthographic"
	},
	"ProjectedTexture:GetPos": {
		"body": [
			"GetPos()$0"
		],
		"description": "Returns the position of the ProjectedTexture, which was previously set by ProjectedTexture:SetPos",
		"prefix": "GetPos"
	},
	"ProjectedTexture:GetQuadraticAttenuation": {
		"body": [
			"GetQuadraticAttenuation()$0"
		],
		"description": "Returns the quadratic attenuation of the projected texture, which can also be set by ProjectedTexture:SetQuadraticAttenuation.",
		"prefix": "GetQuadraticAttenuation"
	},
	"ProjectedTexture:GetTexture": {
		"body": [
			"GetTexture()$0"
		],
		"description": "Returns the texture of the ProjectedTexture, which was previously set by ProjectedTexture:SetTexture",
		"prefix": "GetTexture"
	},
	"ProjectedTexture:GetTextureFrame": {
		"body": [
			"GetTextureFrame()$0"
		],
		"description": "Returns the texture frame of the ProjectedTexture, which was previously set by ProjectedTexture:SetTextureFrame",
		"prefix": "GetTextureFrame"
	},
	"ProjectedTexture:GetVerticalFOV": {
		"body": [
			"GetVerticalFOV()$0"
		],
		"description": "Returns the vertical FOV of the ProjectedTexture, which was previously set by ProjectedTexture:SetVerticalFOV or ProjectedTexture:SetFOV",
		"prefix": "GetVerticalFOV"
	},
	"ProjectedTexture:IsValid": {
		"body": [
			"IsValid()$0"
		],
		"description": "Returns true if the projected texture is valid (i.e. has not been removed), false otherwise.\n\nInstead of calling this directly it's a good idea to call Global.IsValid in case the variable is nil.\n\n\n```\nIsValid( ptexture )\n```\n\n\nThis not only checks whether the projected texture is valid - but also checks whether it's nil.",
		"prefix": "IsValid"
	},
	"ProjectedTexture:Remove": {
		"body": [
			"Remove()$0"
		],
		"description": "Removes the projected texture. After calling this, ProjectedTexture:IsValid will return false, and any hooks with the projected texture as the identifier will be automatically deleted.",
		"prefix": "Remove"
	},
	"ProjectedTexture:SetAngles": {
		"body": [
			"SetAngles(${1:angle})$0"
		],
		"description": "Sets the angles (direction) of the projected texture.\n\nYou must call ProjectedTexture:Update after using this function for it to take effect.",
		"prefix": "SetAngles"
	},
	"ProjectedTexture:SetBrightness": {
		"body": [
			"SetBrightness(${1:brightness})$0"
		],
		"description": "Sets the brightness of the projected texture.\n\nYou must call ProjectedTexture:Update after using this function for it to take effect.",
		"prefix": "SetBrightness"
	},
	"ProjectedTexture:SetColor": {
		"body": [
			"SetColor(${1:color})$0"
		],
		"description": "Sets the color of the projected texture.\n\nYou must call ProjectedTexture:Update after using this function for it to take effect.",
		"prefix": "SetColor"
	},
	"ProjectedTexture:SetConstantAttenuation": {
		"body": [
			"SetConstantAttenuation(${1:constAtten})$0"
		],
		"description": "Sets the constant attenuation of the projected texture.\n\nSee also ProjectedTexture:SetLinearAttenuation and ProjectedTexture:SetQuadraticAttenuation.\n\nYou must call ProjectedTexture:Update after using this function for it to take effect.",
		"prefix": "SetConstantAttenuation"
	},
	"ProjectedTexture:SetEnableShadows": {
		"body": [
			"SetEnableShadows(${1:newState})$0"
		],
		"description": "Enable or disable shadows cast from the projected texture.\n\nas with all types of projected textures (including the player's flashlight and env_projectedtexture), there can only be 8 projected textures with shadows enabled in total. This limit can be increased with the launch parameter: -numshadowtextures limit where limit is the new limit. Naturally, many projected lights with shadows enabled will drastically decrease framerate.\n\nYou must call ProjectedTexture:Update after using this function for it to take effect.",
		"prefix": "SetEnableShadows"
	},
	"ProjectedTexture:SetFOV": {
		"body": [
			"SetFOV(${1:fov})$0"
		],
		"description": "Sets the angle of projection.\n\nYou must call ProjectedTexture:Update after using this function for it to take effect.",
		"prefix": "SetFOV"
	},
	"ProjectedTexture:SetFarZ": {
		"body": [
			"SetFarZ(${1:farZ})$0"
		],
		"description": "Sets the distance at which the projected texture ends.\n\nYou must call ProjectedTexture:Update after using this function for it to take effect.",
		"prefix": "SetFarZ"
	},
	"ProjectedTexture:SetHorizontalFOV": {
		"body": [
			"SetHorizontalFOV(${1:hFOV})$0"
		],
		"description": "Sets the horizontal angle of projection without affecting the vertical angle.\n\nYou must call ProjectedTexture:Update after using this function for it to take effect.",
		"prefix": "SetHorizontalFOV"
	},
	"ProjectedTexture:SetLinearAttenuation": {
		"body": [
			"SetLinearAttenuation(${1:linearAtten})$0"
		],
		"description": "Sets the linear attenuation of the projected texture.\n\nSee also ProjectedTexture:SetConstantAttenuation and ProjectedTexture:SetQuadraticAttenuation.\n\nThe default value of linear attenuation when the projected texture is created is 100. (others are 0, as you are not supposed to mix them)\n\nYou must call ProjectedTexture:Update after using this function for it to take effect.",
		"prefix": "SetLinearAttenuation"
	},
	"ProjectedTexture:SetNearZ": {
		"body": [
			"SetNearZ(${1:nearZ})$0"
		],
		"description": "Sets the distance at which the projected texture begins its projection.\n\nYou must call ProjectedTexture:Update after using this function for it to take effect.\n\nSetting this to 0 will disable the projected texture completely! This may be useful if you want to disable a projected texture without actually removing it\n\nThis seems to affect the rendering of shadows - a higher Near Z value will have shadows begin to render closer to their casting object. Comparing a low Near Z value (like 1) with a normal one (12) or high one (1000) is the easiest way to understand this artifact",
		"prefix": "SetNearZ"
	},
	"ProjectedTexture:SetOrthographic": {
		"body": [
			"SetOrthographic(${1:orthographic}, ${2:left}, ${3:top}, ${4:right}, ${5:bottom})$0"
		],
		"description": "Changes the current projected texture between orthographic and perspective projection.\n\nYou must call ProjectedTexture:Update after using this function for it to take effect.",
		"prefix": "SetOrthographic"
	},
	"ProjectedTexture:SetPos": {
		"body": [
			"SetPos(${1:position})$0"
		],
		"description": "Move the Projected Texture to the specified position.\n\nYou must call ProjectedTexture:Update after using this function for it to take effect.",
		"prefix": "SetPos"
	},
	"ProjectedTexture:SetQuadraticAttenuation": {
		"body": [
			"SetQuadraticAttenuation(${1:quadAtten})$0"
		],
		"description": "Sets the quadratic attenuation of the projected texture.\n\nSee also ProjectedTexture:SetLinearAttenuation and ProjectedTexture:SetConstantAttenuation.\n\nYou must call ProjectedTexture:Update after using this function for it to take effect.",
		"prefix": "SetQuadraticAttenuation"
	},
	"ProjectedTexture:SetTexture": {
		"body": [
			"SetTexture(${1:texture})$0"
		],
		"description": "Sets the texture to be projected.\n\nYou must call ProjectedTexture:Update after using this function for it to take effect.",
		"prefix": "SetTexture"
	},
	"ProjectedTexture:SetTextureFrame": {
		"body": [
			"SetTextureFrame(${1:frame})$0"
		],
		"description": "For animated textures, this will choose which frame in the animation will be projected.\n\nYou must call ProjectedTexture:Update after using this function for it to take effect.",
		"prefix": "SetTextureFrame"
	},
	"ProjectedTexture:SetVerticalFOV": {
		"body": [
			"SetVerticalFOV(${1:vFOV})$0"
		],
		"description": "Sets the vertical angle of projection without affecting the horizontal angle.\n\nYou must call ProjectedTexture:Update after using this function for it to take effect.",
		"prefix": "SetVerticalFOV"
	},
	"ProjectedTexture:Update": {
		"body": [
			"Update()$0"
		],
		"description": "Updates the Projected Light and applies all previously set parameters.",
		"prefix": "Update"
	},
	"Schedule:AddTask": {
		"body": [
			"AddTask(${1:taskname}, ${2:taskdata})$0"
		],
		"description": "Adds a task to the schedule. See also Schedule:AddTaskEx if you wish to customize task start and run function names.\n\nSee also ENTITY:StartSchedule, NPC:StartEngineTask, and NPC:RunEngineTask.",
		"prefix": "AddTask"
	},
	"Schedule:AddTaskEx": {
		"body": [
			"AddTaskEx(${1:start}, ${2:run}, ${3:data})$0"
		],
		"description": "Adds a task to the schedule with completely custom function names.\n\nSee also Schedule:AddTask.",
		"prefix": "AddTaskEx"
	},
	"Schedule:EngTask": {
		"body": [
			"EngTask(${1:taskname}, ${2:taskdata})$0"
		],
		"description": "Adds an engine task to the schedule.",
		"prefix": "EngTask"
	},
	"Schedule:GetTask": {
		"body": [
			"GetTask(${1:num})$0"
		],
		"description": "Returns the task at the given index.",
		"prefix": "GetTask"
	},
	"Schedule:Init": {
		"body": [
			"Init(${1:debugName})$0"
		],
		"description": " Initialises the Schedule. Called by ai_schedule.New when the Schedule is created.",
		"prefix": "Init"
	},
	"Schedule:NumTasks": {
		"body": [
			"NumTasks()$0"
		],
		"description": "Returns the number of tasks in the schedule.",
		"prefix": "NumTasks"
	},
	"Stack:Pop": {
		"body": [
			"Pop(${1:amount=1})$0"
		],
		"description": "Pop an item from the stack",
		"prefix": "Pop"
	},
	"Stack:Push": {
		"body": [
			"Push(${1:object})$0"
		],
		"description": "Push an item onto the stack",
		"prefix": "Push"
	},
	"Stack:Size": {
		"body": [
			"Size()$0"
		],
		"description": "Returns the size of the stack",
		"prefix": "Size"
	},
	"Stack:Top": {
		"body": [
			"Top()$0"
		],
		"description": "Get the item at the top of the stack",
		"prefix": "Top"
	},
	"SurfaceInfo:GetMaterial": {
		"body": [
			"GetMaterial()$0"
		],
		"description": "Returns the brush surface's material.",
		"prefix": "GetMaterial"
	},
	"SurfaceInfo:GetVertices": {
		"body": [
			"GetVertices()$0"
		],
		"description": "Returns a list of vertices the brush surface is built from.",
		"prefix": "GetVertices"
	},
	"SurfaceInfo:IsNoDraw": {
		"body": [
			"IsNoDraw()$0"
		],
		"description": "Checks if the brush surface is a nodraw surface, meaning it will not be drawn by the engine.\n\nThis internally checks the SURFDRAW_NODRAW flag.",
		"prefix": "IsNoDraw"
	},
	"SurfaceInfo:IsSky": {
		"body": [
			"IsSky()$0"
		],
		"description": "Checks if the brush surface is displaying the skybox.\n\nThis internally checks the SURFDRAW_SKY flag.",
		"prefix": "IsSky"
	},
	"SurfaceInfo:IsWater": {
		"body": [
			"IsWater()$0"
		],
		"description": "Checks if the brush surface is water.\n\nThis internally checks the SURFDRAW_WATER flag.",
		"prefix": "IsWater"
	},
	"Task:Init": {
		"body": [
			"Init()$0"
		],
		"description": " Initialises the AI task. Called by ai_task.New.",
		"prefix": "Init"
	},
	"Task:InitEngine": {
		"body": [
			"InitEngine(${1:taskname}, ${2:taskdata})$0"
		],
		"description": "Initialises the AI task as an engine task.",
		"prefix": "InitEngine"
	},
	"Task:InitFunctionName": {
		"body": [
			"InitFunctionName(${1:startname}, ${2:runname}, ${3:taskdata})$0"
		],
		"description": "Initialises the AI task as NPC method-based.",
		"prefix": "InitFunctionName"
	},
	"Task:IsEngineType": {
		"body": [
			"IsEngineType()$0"
		],
		"description": "Determines if the task is an engine task (`TYPE_ENGINE`, 1).",
		"prefix": "IsEngineType"
	},
	"Task:IsFNameType": {
		"body": [
			"IsFNameType()$0"
		],
		"description": "Determines if the task is an NPC method-based task (`TYPE_FNAME`, 2).",
		"prefix": "IsFNameType"
	},
	"Task:Run": {
		"body": [
			"Run(${1:target})$0"
		],
		"description": "Runs the AI task.",
		"prefix": "Run"
	},
	"Task:Run_FName": {
		"body": [
			"Run_FName(${1:target})$0"
		],
		"description": " Runs the AI task as an NPC method. This requires the task to be of type `TYPE_FNAME`.",
		"prefix": "Run_FName"
	},
	"Task:Start": {
		"body": [
			"Start(${1:target})$0"
		],
		"description": "Starts the AI task.",
		"prefix": "Start"
	},
	"Task:Start_FName": {
		"body": [
			"Start_FName(${1:target})$0"
		],
		"description": " Starts the AI task as an NPC method.",
		"prefix": "Start_FName"
	},
	"Tool:Allowed": {
		"body": [
			"Allowed()$0"
		],
		"description": "Checks whether the tool is allowed on the server. This will always return true clientside and will not be affected by SANDBOX:CanTool.\n\nThis function uses **TOOL.AllowedCVar** which is a ConVar object pointing to  **toolmode_allow_`*toolname***` convar.",
		"prefix": "Allowed"
	},
	"Tool:BuildConVarList": {
		"body": [
			"BuildConVarList()$0"
		],
		"description": "Builds a list of all ConVars set via the ClientConVar variable on the Structures/TOOL and their default values. This is used for the preset system.",
		"prefix": "BuildConVarList"
	},
	"Tool:CheckObjects": {
		"body": [
			"CheckObjects()$0"
		],
		"description": "This is called automatically for most toolgun actions so you shouldn't need to use it.\n\nChecks all added objects to see if they're still valid, if not, clears the list of objects.",
		"prefix": "CheckObjects"
	},
	"Tool:ClearObjects": {
		"body": [
			"ClearObjects()$0"
		],
		"description": "Clears all objects previously set with Tool:SetObject.",
		"prefix": "ClearObjects"
	},
	"Tool:Create": {
		"body": [
			"Create()$0"
		],
		"description": "This is called automatically for all tools.\nInitializes the tool object",
		"prefix": "Create"
	},
	"Tool:CreateConVars": {
		"body": [
			"CreateConVars()$0"
		],
		"description": "This is called automatically for all tools.\n\nCreates clientside ConVars based on the ClientConVar table specified in the tool structure. Also creates the 'toolmode_allow_X' ConVar.",
		"prefix": "CreateConVars"
	},
	"Tool:GetBone": {
		"body": [
			"GetBone(${1:id})$0"
		],
		"description": "Retrieves a physics bone number previously stored using Tool:SetObject.",
		"prefix": "GetBone"
	},
	"Tool:GetClientInfo": {
		"body": [
			"GetClientInfo(${1:name})$0"
		],
		"description": "Attempts to grab a clientside tool ConVar.",
		"prefix": "GetClientInfo"
	},
	"Tool:GetClientNumber": {
		"body": [
			"GetClientNumber(${1:name}, ${2:default=0})$0"
		],
		"description": "Attempts to grab a clientside tool ConVar.",
		"prefix": "GetClientNumber"
	},
	"Tool:GetEnt": {
		"body": [
			"GetEnt(${1:id})$0"
		],
		"description": "Retrieves an Entity previously stored using Tool:SetObject.",
		"prefix": "GetEnt"
	},
	"Tool:GetHelpText": {
		"body": [
			"GetHelpText()$0"
		],
		"description": "Returns a language key based on this tool's name and the current stage it is on.",
		"prefix": "GetHelpText"
	},
	"Tool:GetLocalPos": {
		"body": [
			"GetLocalPos(${1:id})$0"
		],
		"description": "Retrieves an local vector previously stored using Tool:SetObject.\nSee also Tool:GetPos.",
		"prefix": "GetLocalPos"
	},
	"Tool:GetMode": {
		"body": [
			"GetMode()$0"
		],
		"description": "Returns the name of the current tool mode.",
		"prefix": "GetMode"
	},
	"Tool:GetNormal": {
		"body": [
			"GetNormal(${1:id})$0"
		],
		"description": "Retrieves an normal vector previously stored using Tool:SetObject.",
		"prefix": "GetNormal"
	},
	"Tool:GetOperation": {
		"body": [
			"GetOperation()$0"
		],
		"description": "Returns the current operation of the tool set by Tool:SetOperation.",
		"prefix": "GetOperation"
	},
	"Tool:GetOwner": {
		"body": [
			"GetOwner()$0"
		],
		"description": "Returns the owner of this tool.",
		"prefix": "GetOwner"
	},
	"Tool:GetPhys": {
		"body": [
			"GetPhys(${1:id})$0"
		],
		"description": "Retrieves an PhysObj previously stored using Tool:SetObject.\nSee also Tool:GetEnt.",
		"prefix": "GetPhys"
	},
	"Tool:GetPos": {
		"body": [
			"GetPos(${1:id})$0"
		],
		"description": "Retrieves an vector previously stored using Tool:SetObject. See also Tool:GetLocalPos.",
		"prefix": "GetPos"
	},
	"Tool:GetServerInfo": {
		"body": [
			"GetServerInfo(${1:name})$0"
		],
		"description": "Attempts to grab a serverside tool ConVar.\nThis will not do anything on client, despite the function being defined shared.",
		"prefix": "GetServerInfo"
	},
	"Tool:GetStage": {
		"body": [
			"GetStage()$0"
		],
		"description": "Returns the current stage of the tool set by Tool:SetStage.",
		"prefix": "GetStage"
	},
	"Tool:MakeGhostEntity": {
		"body": [
			"MakeGhostEntity(${1:model}, ${2:pos}, ${3:angle})$0"
		],
		"description": "Initializes the ghost entity with the given model. Removes any old ghost entity if called multiple times.\n\nThe ghost is a regular prop_physics entity in singleplayer games, and a clientside prop in multiplayer games.",
		"prefix": "MakeGhostEntity"
	},
	"Tool:NumObjects": {
		"body": [
			"NumObjects()$0"
		],
		"description": "Returns the amount of stored objects ( Entitys ) the tool has.\nAre TOOLs limited to 4 entities?",
		"prefix": "NumObjects"
	},
	"Tool:ReleaseGhostEntity": {
		"body": [
			"ReleaseGhostEntity()$0"
		],
		"description": "Removes any ghost entity created for this tool.",
		"prefix": "ReleaseGhostEntity"
	},
	"Tool:SetObject": {
		"body": [
			"SetObject(${1:id}, ${2:ent}, ${3:pos}, ${4:phys}, ${5:bone}, ${6:normal})$0"
		],
		"description": "Stores an Entity for later use in the tool.\n\nThe stored values can be retrieved by Tool:GetEnt, Tool:GetPos, Tool:GetLocalPos, Tool:GetPhys, Tool:GetBone and Tool:GetNormal",
		"prefix": "SetObject"
	},
	"Tool:SetOperation": {
		"body": [
			"SetOperation(${1:operation})$0"
		],
		"description": "Sets the current operation of the tool. Does nothing clientside. See also Tool:SetStage.\n\nOperations and stages work as follows:\n* Operation 1\n* * Stage 1\n* * Stage 2\n* * Stage 3\n* Operation 2\n* * Stage 1\n* * Stage 2\n* * Stage ...",
		"prefix": "SetOperation"
	},
	"Tool:SetStage": {
		"body": [
			"SetStage(${1:stage})$0"
		],
		"description": "Sets the current stage of the tool. Does nothing clientside.\n\nSee also Tool:SetOperation.",
		"prefix": "SetStage"
	},
	"Tool:StartGhostEntity": {
		"body": [
			"StartGhostEntity(${1:ent})$0"
		],
		"description": "Initializes the ghost entity based on the supplied entity.",
		"prefix": "StartGhostEntity"
	},
	"Tool:UpdateData": {
		"body": [
			"UpdateData()$0"
		],
		"description": "Called on deploy automatically\n\nSets the tool's stage to how many stored objects the tool has.",
		"prefix": "UpdateData"
	},
	"Tool:UpdateGhostEntity": {
		"body": [
			"UpdateGhostEntity()$0"
		],
		"description": "Updates the position and orientation of the ghost entity based on where the toolgun owner is looking along with data from object with id 1 set by Tool:SetObject.\n\nThis should be called in the tool's TOOL:Think hook.\n\nThis command is only used for tools that move props, such as easy weld, axis and motor. If you want to update a ghost like the thruster tool does it for example, check its [source code](https://github.com/Facepunch/garrysmod/blob/master/garrysmod/gamemodes/sandbox/entities/weapons/gmod_tool/stools/thruster.lua#L179).",
		"prefix": "UpdateGhostEntity"
	},
	"VMatrix:GetAngles": {
		"body": [
			"GetAngles()$0"
		],
		"description": "Returns the absolute rotation of the matrix.",
		"prefix": "GetAngles"
	},
	"VMatrix:GetField": {
		"body": [
			"GetField(${1:row}, ${2:column})$0"
		],
		"description": "Returns a specific field in the matrix.",
		"prefix": "GetField"
	},
	"VMatrix:GetForward": {
		"body": [
			"GetForward()$0"
		],
		"description": "Gets the forward direction of the matrix.\n\nie. The first column of the matrix, excluding the w coordinate.",
		"prefix": "GetForward"
	},
	"VMatrix:GetInverse": {
		"body": [
			"GetInverse()$0"
		],
		"description": "Returns an inverted matrix without modifying the original matrix.\n\nInverting the matrix will fail if its [determinant](https://en.wikipedia.org/wiki/Determinant) is 0 or close to 0. (ie. its \"scale\" in any direction is 0.)\n\nSee also VMatrix:GetInverseTR.",
		"prefix": "GetInverse"
	},
	"VMatrix:GetInverseTR": {
		"body": [
			"GetInverseTR()$0"
		],
		"description": "Returns an inverted matrix without modifying the original matrix. This function will not fail, but only works correctly on matrices that contain only translation and/or rotation.\n\nUsing this function on a matrix with modified scale may return an incorrect inverted matrix.\n\nTo get the inverse of a matrix that contains other modifications, see VMatrix:GetInverse.",
		"prefix": "GetInverseTR"
	},
	"VMatrix:GetRight": {
		"body": [
			"GetRight()$0"
		],
		"description": "Gets the right direction of the matrix.\n\nie. The second column of the matrix, negated, excluding the w coordinate.",
		"prefix": "GetRight"
	},
	"VMatrix:GetScale": {
		"body": [
			"GetScale()$0"
		],
		"description": "Returns the absolute scale of the matrix.",
		"prefix": "GetScale"
	},
	"VMatrix:GetTranslation": {
		"body": [
			"GetTranslation()$0"
		],
		"description": "Returns the absolute translation of the matrix.",
		"prefix": "GetTranslation"
	},
	"VMatrix:GetUp": {
		"body": [
			"GetUp()$0"
		],
		"description": "Gets the up direction of the matrix.\n\nie. The third column of the matrix, excluding the w coordinate.",
		"prefix": "GetUp"
	},
	"VMatrix:Identity": {
		"body": [
			"Identity()$0"
		],
		"description": "Initializes the matrix as Identity matrix.",
		"prefix": "Identity"
	},
	"VMatrix:Invert": {
		"body": [
			"Invert()$0"
		],
		"description": "Inverts the matrix.\n\nInverting the matrix will fail if its [determinant](https://en.wikipedia.org/wiki/Determinant) is 0 or close to 0. (ie. its \"scale\" in any direction is 0.)\n\nIf the matrix cannot be inverted, it does not get modified.\n\nSee also VMatrix:InvertTR.",
		"prefix": "Invert"
	},
	"VMatrix:InvertTR": {
		"body": [
			"InvertTR()$0"
		],
		"description": "Inverts the matrix. This function will not fail, but only works correctly on matrices that contain only translation and/or rotation.\n\nUsing this function on a matrix with modified scale may return an incorrect inverted matrix.\n\nTo invert a matrix that contains other modifications, see VMatrix:Invert.",
		"prefix": "InvertTR"
	},
	"VMatrix:IsIdentity": {
		"body": [
			"IsIdentity()$0"
		],
		"description": "Returns whether the matrix is equal to Identity matrix or not.",
		"prefix": "IsIdentity"
	},
	"VMatrix:IsRotationMatrix": {
		"body": [
			"IsRotationMatrix()$0"
		],
		"description": "Returns whether the matrix is a rotation matrix or not.\n\nTechnically it checks if the forward, right and up vectors are orthogonal and normalized.",
		"prefix": "IsRotationMatrix"
	},
	"VMatrix:IsZero": {
		"body": [
			"IsZero()$0"
		],
		"description": "Checks whenever all fields of the matrix are 0, aka if this is a [null matrix](https://en.wikipedia.org/wiki/Zero_matrix).",
		"prefix": "IsZero"
	},
	"VMatrix:Rotate": {
		"body": [
			"Rotate(${1:rotation})$0"
		],
		"description": "Rotates the matrix by the given angle.\n\nPostmultiplies the matrix by a rotation matrix (A = AR).",
		"prefix": "Rotate"
	},
	"VMatrix:Scale": {
		"body": [
			"Scale(${1:scale})$0"
		],
		"description": "Scales the matrix by the given vector.\n\nPostmultiplies the matrix by a scaling matrix (A = AS).",
		"prefix": "Scale"
	},
	"VMatrix:ScaleTranslation": {
		"body": [
			"ScaleTranslation(${1:scale})$0"
		],
		"description": "Scales the absolute translation with the given value.",
		"prefix": "ScaleTranslation"
	},
	"VMatrix:Set": {
		"body": [
			"Set(${1:src})$0"
		],
		"description": "Copies values from the given matrix object.",
		"prefix": "Set"
	},
	"VMatrix:SetAngles": {
		"body": [
			"SetAngles(${1:angle})$0"
		],
		"description": "Sets the absolute rotation of the matrix.",
		"prefix": "SetAngles"
	},
	"VMatrix:SetField": {
		"body": [
			"SetField(${1:row}, ${2:column}, ${3:value})$0"
		],
		"description": "Sets a specific field in the matrix.",
		"prefix": "SetField"
	},
	"VMatrix:SetForward": {
		"body": [
			"SetForward(${1:forward})$0"
		],
		"description": "Sets the forward direction of the matrix.\n\nie. The first column of the matrix, excluding the w coordinate.",
		"prefix": "SetForward"
	},
	"VMatrix:SetRight": {
		"body": [
			"SetRight(${1:forward})$0"
		],
		"description": "Sets the right direction of the matrix.\n\nie. The second column of the matrix, negated, excluding the w coordinate.",
		"prefix": "SetRight"
	},
	"VMatrix:SetScale": {
		"body": [
			"SetScale(${1:scale})$0"
		],
		"description": "Modifies the scale of the matrix while preserving the rotation and translation.",
		"prefix": "SetScale"
	},
	"VMatrix:SetTranslation": {
		"body": [
			"SetTranslation(${1:translation})$0"
		],
		"description": "Sets the absolute translation of the matrix.",
		"prefix": "SetTranslation"
	},
	"VMatrix:SetUnpacked": {
		"body": [
			"SetUnpacked(${1:e11}, ${2:e12}, ${3:e13}, ${4:e14}, ${5:e21}, ${6:e22}, ${7:e23}, ${8:e24}, ${9:e31}, ${10:e32}, ${11:e33}, ${12:e34}, ${13:e41}, ${14:e42}, ${15:e43}, ${16:e44})$0"
		],
		"description": "Sets each component of the matrix.",
		"prefix": "SetUnpacked"
	},
	"VMatrix:SetUp": {
		"body": [
			"SetUp(${1:forward})$0"
		],
		"description": "Sets the up direction of the matrix.\n\nie. The third column of the matrix, excluding the w coordinate.",
		"prefix": "SetUp"
	},
	"VMatrix:ToTable": {
		"body": [
			"ToTable()$0"
		],
		"description": "Converts the matrix to a 4x4 table. See Global.Matrix function.",
		"prefix": "ToTable"
	},
	"VMatrix:Translate": {
		"body": [
			"Translate(${1:translation})$0"
		],
		"description": "Translates the matrix by the given vector aka. adds the vector to the translation.\n\nPostmultiplies the matrix by a translation matrix (A = AT).",
		"prefix": "Translate"
	},
	"VMatrix:Unpack": {
		"body": [
			"Unpack()$0"
		],
		"description": "Returns each component of the matrix, expanding rows before columns.",
		"prefix": "Unpack"
	},
	"VMatrix:Zero": {
		"body": [
			"Zero()$0"
		],
		"description": "Sets all components of the matrix to 0, also known as a [null matrix](https://en.wikipedia.org/wiki/Zero_matrix).\n\nThis function is more efficient than setting each element manually.",
		"prefix": "Zero"
	},
	"Vector:Add": {
		"body": [
			"Add(${1:vector})$0"
		],
		"description": "Adds the values of the argument vector to the orignal vector. This functions the same as vector1 + vector2 without creating a new vector object, skipping object construction and garbage collection.",
		"prefix": "Add"
	},
	"Vector:Angle": {
		"body": [
			"Angle()$0"
		],
		"description": "Returns an angle representing the normal of the vector.",
		"prefix": "Angle"
	},
	"Vector:AngleEx": {
		"body": [
			"AngleEx(${1:up})$0"
		],
		"description": "Returns the angle of the vector, but instead of assuming that up is Global.Vector( 0, 0, 1 ) (Like Vector:Angle does) you can specify which direction is 'up' for the angle.",
		"prefix": "AngleEx"
	},
	"Vector:Cross": {
		"body": [
			"Cross(${1:otherVector})$0"
		],
		"description": "Calculates the cross product of this vector and the passed one.\n\nThe cross product of two vectors is a 3-dimensional vector with a direction perpendicular (at right angles) to both of them (according to the right-hand rule), and magnitude equal to the area of parallelogram they span. This is defined as the product of the magnitudes, the sine of the angle between them, and unit (normal) vector `n` defined by the right-hand rule:\n:**a** \u00c3\u2014 **b** = |**a**| |**b**| sin(\u00ce\u00b8) **n\u00cc\u201a**\nwhere **a** and **b** are vectors, and **n\u00cc\u201a** is a unit vector (magnitude of 1) perpendicular to both.",
		"prefix": "Cross"
	},
	"Vector:DistToSqr": {
		"body": [
			"DistToSqr(${1:otherVec})$0"
		],
		"description": "Returns the squared distance of 2 vectors, this is faster than Vector:Distance as calculating the square root is an expensive process.",
		"prefix": "DistToSqr"
	},
	"Vector:Distance": {
		"body": [
			"Distance(${1:otherVector})$0"
		],
		"description": "Returns the euclidean distance between the vector and the other vector.\n\nThis is a relatively expensive process since it uses the square root. It is recommended that you use Vector:DistToSqr whenever possible. (Benchmarking shows Vector:DistToSqr was at most 153 nanoseconds faster.)",
		"prefix": "Distance"
	},
	"Vector:Div": {
		"body": [
			"Div(${1:divisor})$0"
		],
		"description": "Divide the vector by the given number, that means x, y and z are divided by that value. This will change the value of the original vector, see example 2 for division without changing the value.",
		"prefix": "Div"
	},
	"Vector:Dot": {
		"body": [
			"Dot(${1:otherVector})$0"
		],
		"description": "Returns the [dot product](https://en.wikipedia.org/wiki/Dot_product#Geometric_definition)  of this vector and the passed one.\n\nThe dot product of two vectors is the product of their magnitudes (lengths), and the cosine of the angle between them:\n**a \u00c2\u00b7 b** = |**a**| |**b**| cos(\u00ce\u00b8) \nwhere **a** and **b** are vectors.\nSee Vector:Length for obtaining magnitudes.\n\nA dot product returns just the cosine of the angle if both vectors are normalized, and zero if the vectors are at right angles to each other.",
		"prefix": "Dot"
	},
	"Vector:DotProduct": {
		"body": [
			"DotProduct(${1:Vector})$0"
		],
		"description": "This is an alias of Vector:Dot. Use that instead.Returns the dot product of the two vectors.",
		"prefix": "DotProduct"
	},
	"Vector:GetNormal": {
		"body": [
			"GetNormal()$0"
		],
		"description": "Use Vector:GetNormalized instead.\n\nReturns a normalized version of the vector. This is a alias of Vector:GetNormalized.",
		"prefix": "GetNormal"
	},
	"Vector:GetNormalized": {
		"body": [
			"GetNormalized()$0"
		],
		"description": "Returns a normalized version of the vector. Normalized means vector with same direction but with length of 1.\n\nThis does not affect the vector you call it on; to do this, use Vector:Normalize.",
		"prefix": "GetNormalized"
	},
	"Vector:IsEqualTol": {
		"body": [
			"IsEqualTol(${1:compare}, ${2:tolerance})$0"
		],
		"description": "Returns if the vector is equal to another vector with the given tolerance.",
		"prefix": "IsEqualTol"
	},
	"Vector:IsZero": {
		"body": [
			"IsZero()$0"
		],
		"description": "Checks whenever all fields of the vector are 0.",
		"prefix": "IsZero"
	},
	"Vector:Length": {
		"body": [
			"Length()$0"
		],
		"description": "Returns the Euclidean length of the vector: \u00e2\u02c6\u0161(x\u00c2\u00b2 + y\u00c2\u00b2 + z\u00c2\u00b2)",
		"prefix": "Length"
	},
	"Vector:Length2D": {
		"body": [
			"Length2D()$0"
		],
		"description": "Returns the length of the vector in two dimensions, without the Z axis.",
		"prefix": "Length2D"
	},
	"Vector:Length2DSqr": {
		"body": [
			"Length2DSqr()$0"
		],
		"description": "Returns the squared length of the vectors x and y value, x\u00c2\u00b2 + y\u00c2\u00b2.\n\nThis is faster than Vector:Length2D as calculating the square root is an expensive process.",
		"prefix": "Length2DSqr"
	},
	"Vector:LengthSqr": {
		"body": [
			"LengthSqr()$0"
		],
		"description": "Returns the squared length of the vector, x\u00c2\u00b2 + y\u00c2\u00b2 + z\u00c2\u00b2.\n\nThis is faster than Vector:Length as calculating the square root is an expensive process.",
		"prefix": "LengthSqr"
	},
	"Vector:Mul": {
		"body": [
			"Mul(${1:multiplier})$0"
		],
		"description": "Scales the vector by the given number, that means x, y and z are multiplied by that value.",
		"prefix": "Mul"
	},
	"Vector:Normalize": {
		"body": [
			"Normalize()$0"
		],
		"description": "Normalizes the given vector. This changes the vector you call it on, if you want to return a normalized copy without affecting the original, use Vector:GetNormalized.",
		"prefix": "Normalize"
	},
	"Vector:Rotate": {
		"body": [
			"Rotate(${1:rotation})$0"
		],
		"description": "Rotates a vector by the given angle.\nDoesn't return anything, but rather changes the original vector.",
		"prefix": "Rotate"
	},
	"Vector:Set": {
		"body": [
			"Set(${1:vector})$0"
		],
		"description": "Copies the values from the second vector to the first vector.",
		"prefix": "Set"
	},
	"Vector:SetUnpacked": {
		"body": [
			"SetUnpacked(${1:x}, ${2:y}, ${3:z})$0"
		],
		"description": "Sets the x, y, and z of the vector.",
		"prefix": "SetUnpacked"
	},
	"Vector:Sub": {
		"body": [
			"Sub(${1:vector})$0"
		],
		"description": "Substracts the values of the second vector from the orignal vector, this function can be used to avoid garbage collection.",
		"prefix": "Sub"
	},
	"Vector:ToColor": {
		"body": [
			"ToColor()$0"
		],
		"description": "Translates the Vector (values ranging from 0 to 1) into a Color. This will also range the values from 0 - 1 to 0 - 255.\n\nx * 255 -> r\ny * 255 -> g\nz * 255 -> b\n\nThis is the opposite of Color:ToVector",
		"prefix": "ToColor"
	},
	"Vector:ToScreen": {
		"body": [
			"ToScreen()$0"
		],
		"description": "Returns where on the screen the specified position vector would appear. A related function is gui.ScreenToVector, which converts a 2D coordinate to a 3D direction.\n\nShould be called from a 3D rendering environment or after cam.Start3D or it may not work correctly.\n\nErrors in a render hook can make this value incorrect until the player restarts their game.\n\ncam.Start3D or 3D context cam.Start with non-default parameters incorrectly sets the reference FOV for this function, causing incorrect return values. This can be fixed by creating and ending a default 3D context (cam.Start3D with no arguments).",
		"prefix": "ToScreen"
	},
	"Vector:ToTable": {
		"body": [
			"ToTable()$0"
		],
		"description": "Returns the vector as a table with three elements.",
		"prefix": "ToTable"
	},
	"Vector:Unpack": {
		"body": [
			"Unpack()$0"
		],
		"description": "Returns the x, y, and z of the vector.",
		"prefix": "Unpack"
	},
	"Vector:WithinAABox": {
		"body": [
			"WithinAABox(${1:boxStart}, ${2:boxEnd})$0"
		],
		"description": "Returns whenever the given vector is in a box created by the 2 other vectors.",
		"prefix": "WithinAABox"
	},
	"Vector:Zero": {
		"body": [
			"Zero()$0"
		],
		"description": "Sets x, y and z to 0.",
		"prefix": "Zero"
	},
	"Vehicle:BoostTimeLeft": {
		"body": [
			"BoostTimeLeft()$0"
		],
		"description": "Returns the remaining boosting time left.",
		"prefix": "BoostTimeLeft"
	},
	"Vehicle:CheckExitPoint": {
		"body": [
			"CheckExitPoint(${1:yaw}, ${2:distance})$0"
		],
		"description": "Tries to find an Exit Point for leaving vehicle, if one is unobstructed in the direction given.",
		"prefix": "CheckExitPoint"
	},
	"Vehicle:EnableEngine": {
		"body": [
			"EnableEngine(${1:enable})$0"
		],
		"description": "Sets whether the engine is enabled or disabled, i.e. can be started or not.",
		"prefix": "EnableEngine"
	},
	"Vehicle:GetAmmo": {
		"body": [
			"GetAmmo()$0"
		],
		"description": "Returns information about the ammo of the vehicle",
		"prefix": "GetAmmo"
	},
	"Vehicle:GetCameraDistance": {
		"body": [
			"GetCameraDistance()$0"
		],
		"description": "Returns third person camera distance.",
		"prefix": "GetCameraDistance"
	},
	"Vehicle:GetDriver": {
		"body": [
			"GetDriver()$0"
		],
		"description": "Gets the driver of the vehicle, returns `NULL` if no driver is present.",
		"prefix": "GetDriver"
	},
	"Vehicle:GetHLSpeed": {
		"body": [
			"GetHLSpeed()$0"
		],
		"description": "Returns the current speed of the vehicle in Half-Life Hammer Units (in/s). Same as Entity:GetVelocity + Vector:Length.",
		"prefix": "GetHLSpeed"
	},
	"Vehicle:GetMaxSpeed": {
		"body": [
			"GetMaxSpeed()$0"
		],
		"description": "Returns the max speed of the vehicle in MPH.",
		"prefix": "GetMaxSpeed"
	},
	"Vehicle:GetOperatingParams": {
		"body": [
			"GetOperatingParams()$0"
		],
		"description": "Returns some info about the vehicle.",
		"prefix": "GetOperatingParams"
	},
	"Vehicle:GetPassenger": {
		"body": [
			"GetPassenger(${1:passenger})$0"
		],
		"description": "Gets the passenger of the vehicle, returns NULL if no drivers is present.",
		"prefix": "GetPassenger"
	},
	"Vehicle:GetPassengerSeatPoint": {
		"body": [
			"GetPassengerSeatPoint(${1:role})$0"
		],
		"description": "Returns the seat position and angle of a given passenger seat.",
		"prefix": "GetPassengerSeatPoint"
	},
	"Vehicle:GetRPM": {
		"body": [
			"GetRPM()$0"
		],
		"description": "Returns the current RPM of the vehicle. This value is fake and doesn't actually affect the vehicle movement.",
		"prefix": "GetRPM"
	},
	"Vehicle:GetSpeed": {
		"body": [
			"GetSpeed()$0"
		],
		"description": "Returns the current speed of the vehicle in MPH.",
		"prefix": "GetSpeed"
	},
	"Vehicle:GetSteering": {
		"body": [
			"GetSteering()$0"
		],
		"description": "Returns the current steering of the vehicle.",
		"prefix": "GetSteering"
	},
	"Vehicle:GetSteeringDegrees": {
		"body": [
			"GetSteeringDegrees()$0"
		],
		"description": "Returns the maximum steering degree of the vehicle",
		"prefix": "GetSteeringDegrees"
	},
	"Vehicle:GetThirdPersonMode": {
		"body": [
			"GetThirdPersonMode()$0"
		],
		"description": "Returns if vehicle has thirdperson mode enabled or not.",
		"prefix": "GetThirdPersonMode"
	},
	"Vehicle:GetThrottle": {
		"body": [
			"GetThrottle()$0"
		],
		"description": "Returns the current throttle of the vehicle.",
		"prefix": "GetThrottle"
	},
	"Vehicle:GetVehicleClass": {
		"body": [
			"GetVehicleClass()$0"
		],
		"description": "Returns the vehicle class name. This is only useful for Sandbox spawned vehicles or any vehicle that properly sets the vehicle class with Vehicle:SetVehicleClass.",
		"prefix": "GetVehicleClass"
	},
	"Vehicle:GetVehicleParams": {
		"body": [
			"GetVehicleParams()$0"
		],
		"description": "Returns the vehicle parameters of given vehicle.",
		"prefix": "GetVehicleParams"
	},
	"Vehicle:GetVehicleViewPosition": {
		"body": [
			"GetVehicleViewPosition(${1:role=0})$0"
		],
		"description": "Returns the view position and forward angle of a given passenger seat.",
		"prefix": "GetVehicleViewPosition"
	},
	"Vehicle:GetWheel": {
		"body": [
			"GetWheel(${1:wheel})$0"
		],
		"description": "Returns the PhysObj of given wheel.",
		"prefix": "GetWheel"
	},
	"Vehicle:GetWheelBaseHeight": {
		"body": [
			"GetWheelBaseHeight(${1:wheel})$0"
		],
		"description": "Returns the base wheel height.",
		"prefix": "GetWheelBaseHeight"
	},
	"Vehicle:GetWheelContactPoint": {
		"body": [
			"GetWheelContactPoint(${1:wheel})$0"
		],
		"description": "Returns the wheel contact point.",
		"prefix": "GetWheelContactPoint"
	},
	"Vehicle:GetWheelCount": {
		"body": [
			"GetWheelCount()$0"
		],
		"description": "Returns the wheel count of the vehicle",
		"prefix": "GetWheelCount"
	},
	"Vehicle:GetWheelTotalHeight": {
		"body": [
			"GetWheelTotalHeight(${1:wheel})$0"
		],
		"description": "Returns the total wheel height.",
		"prefix": "GetWheelTotalHeight"
	},
	"Vehicle:HasBoost": {
		"body": [
			"HasBoost()$0"
		],
		"description": "Returns whether this vehicle has boost at all.",
		"prefix": "HasBoost"
	},
	"Vehicle:HasBrakePedal": {
		"body": [
			"HasBrakePedal()$0"
		],
		"description": "Returns whether this vehicle has a brake pedal. See Vehicle:SetHasBrakePedal.",
		"prefix": "HasBrakePedal"
	},
	"Vehicle:IsBoosting": {
		"body": [
			"IsBoosting()$0"
		],
		"description": "Returns whether this vehicle is currently boosting or not.",
		"prefix": "IsBoosting"
	},
	"Vehicle:IsEngineEnabled": {
		"body": [
			"IsEngineEnabled()$0"
		],
		"description": "Returns whether the engine is enabled or not, i.e. whether it can be started.",
		"prefix": "IsEngineEnabled"
	},
	"Vehicle:IsEngineStarted": {
		"body": [
			"IsEngineStarted()$0"
		],
		"description": "Returns whether the engine is started or not.",
		"prefix": "IsEngineStarted"
	},
	"Vehicle:IsValidVehicle": {
		"body": [
			"IsValidVehicle()$0"
		],
		"description": "Returns true if the vehicle object is a valid or not. This will return false when Vehicle functions are not usable on the vehicle.",
		"prefix": "IsValidVehicle"
	},
	"Vehicle:IsVehicleBodyInWater": {
		"body": [
			"IsVehicleBodyInWater()$0"
		],
		"description": "Returns whether this vehicle's engine is underwater or not. ( Internally the attachment point \"engine\" or \"vehicle_engine\" is checked )",
		"prefix": "IsVehicleBodyInWater"
	},
	"Vehicle:ReleaseHandbrake": {
		"body": [
			"ReleaseHandbrake()$0"
		],
		"description": "Releases the vehicle's handbrake (Jeep) so it can roll without any passengers.\n\nThis will be overwritten if the vehicle has a driver. Same as Vehicle:SetHandbrake( false )",
		"prefix": "ReleaseHandbrake"
	},
	"Vehicle:SetBoost": {
		"body": [
			"SetBoost(${1:boost})$0"
		],
		"description": "Sets the boost. It is possible that this function does not work while the vehicle has a valid driver in it.",
		"prefix": "SetBoost"
	},
	"Vehicle:SetCameraDistance": {
		"body": [
			"SetCameraDistance(${1:distance})$0"
		],
		"description": "Sets the third person camera distance of the vehicle.",
		"prefix": "SetCameraDistance"
	},
	"Vehicle:SetHandbrake": {
		"body": [
			"SetHandbrake(${1:handbrake})$0"
		],
		"description": "Turns on or off the Jeep handbrake so it can roll without a driver inside.\n\nDoes nothing while the vehicle has a driver in it.",
		"prefix": "SetHandbrake"
	},
	"Vehicle:SetHasBrakePedal": {
		"body": [
			"SetHasBrakePedal(${1:brakePedal})$0"
		],
		"description": "Sets whether this vehicle has a brake pedal.",
		"prefix": "SetHasBrakePedal"
	},
	"Vehicle:SetMaxReverseThrottle": {
		"body": [
			"SetMaxReverseThrottle(${1:maxRevThrottle})$0"
		],
		"description": "Sets maximum reverse throttle",
		"prefix": "SetMaxReverseThrottle"
	},
	"Vehicle:SetMaxThrottle": {
		"body": [
			"SetMaxThrottle(${1:maxThrottle})$0"
		],
		"description": "Sets maximum forward throttle",
		"prefix": "SetMaxThrottle"
	},
	"Vehicle:SetSpringLength": {
		"body": [
			"SetSpringLength(${1:wheel}, ${2:length})$0"
		],
		"description": "Sets spring length of given wheel",
		"prefix": "SetSpringLength"
	},
	"Vehicle:SetSteering": {
		"body": [
			"SetSteering(${1:front}, ${2:rear})$0"
		],
		"description": "Sets the steering of the vehicle.\nThe correct range, 0 to 1 or -1 to 1",
		"prefix": "SetSteering"
	},
	"Vehicle:SetSteeringDegrees": {
		"body": [
			"SetSteeringDegrees(${1:steeringDegrees})$0"
		],
		"description": "Sets the maximum steering degrees of the vehicle",
		"prefix": "SetSteeringDegrees"
	},
	"Vehicle:SetThirdPersonMode": {
		"body": [
			"SetThirdPersonMode(${1:enable})$0"
		],
		"description": "Sets the third person mode state.",
		"prefix": "SetThirdPersonMode"
	},
	"Vehicle:SetThrottle": {
		"body": [
			"SetThrottle(${1:throttle})$0"
		],
		"description": "Sets the throttle of the vehicle. It is possible that this function does not work with a valid driver in it.",
		"prefix": "SetThrottle"
	},
	"Vehicle:SetVehicleClass": {
		"body": [
			"SetVehicleClass(${1:class})$0"
		],
		"description": "Sets the vehicle class name.",
		"prefix": "SetVehicleClass"
	},
	"Vehicle:SetVehicleEntryAnim": {
		"body": [
			"SetVehicleEntryAnim(${1:bOn})$0"
		],
		"description": "Sets whether the entry or exit camera animation should be played or not.",
		"prefix": "SetVehicleEntryAnim"
	},
	"Vehicle:SetVehicleParams": {
		"body": [
			"SetVehicleParams(${1:params})$0"
		],
		"description": "Sets the vehicle parameters for given vehicle.\n\nNot all variables from the Structures/VehicleParams can be set.\n\nBecause this method uses miles per hour but Vehicle:GetVehicleParams returns Hammer units per second, this method incorrectly modifies the vehicle engine's \"boostMaxSpeed\", \"maxRevSpeed\" and \"maxSpeed\" even when not explicitly set in a call to this method.\n\n**Workaround**: In order to retain the original values for these fields, call Vehicle:GetVehicleParams yourself, convert the mentioned fields from Hammer units per second to miles per hour (1 MPH \u00e2\u2030\u02c6 17.6 HU/s in this case) and add them to the table passed into the call to this setter. Avoid doing this repeatedly to avoid floating point inaccuracies over time (store the ready-calculated value for next time if possible).",
		"prefix": "SetVehicleParams"
	},
	"Vehicle:SetWheelFriction": {
		"body": [
			"SetWheelFriction(${1:wheel}, ${2:friction})$0"
		],
		"description": "Sets friction of given wheel.  This function may be broken.",
		"prefix": "SetWheelFriction"
	},
	"Vehicle:StartEngine": {
		"body": [
			"StartEngine(${1:start})$0"
		],
		"description": "Starts or stops the engine.",
		"prefix": "StartEngine"
	},
	"Weapon:AllowsAutoSwitchFrom": {
		"body": [
			"AllowsAutoSwitchFrom()$0"
		],
		"description": "Returns whether the weapon allows to being switched from when a better ( Weapon:GetWeight ) weapon is being picked up.",
		"prefix": "AllowsAutoSwitchFrom"
	},
	"Weapon:AllowsAutoSwitchTo": {
		"body": [
			"AllowsAutoSwitchTo()$0"
		],
		"description": "Returns whether the weapon allows to being switched to when a better ( Weapon:GetWeight ) weapon is being picked up.",
		"prefix": "AllowsAutoSwitchTo"
	},
	"Weapon:CallOnClient": {
		"body": [
			"CallOnClient(${1:functionName}, ${2:arguments})$0"
		],
		"description": "Calls a SWEP function on client.\n\nThis uses the usermessage internally, because of that, the combined length of the arguments of this function may not exceed 254 bytes/characters or the function will cease to function!",
		"prefix": "CallOnClient"
	},
	"Weapon:Clip1": {
		"body": [
			"Clip1()$0"
		],
		"description": "Returns how much primary ammo is in the magazine.\nThis is not shared between clients and will instead return the maximum primary clip size.",
		"prefix": "Clip1"
	},
	"Weapon:Clip2": {
		"body": [
			"Clip2()$0"
		],
		"description": "Returns how much secondary ammo is in the magazine.\nThis is not shared between clients and will instead return the maximum secondary clip size.",
		"prefix": "Clip2"
	},
	"Weapon:DefaultReload": {
		"body": [
			"DefaultReload(${1:act})$0"
		],
		"description": "Forces the weapon to reload while playing given animation.\n\nThis will stop the Weapon:Think function from getting called while the weapon is reloading!\n",
		"prefix": "DefaultReload"
	},
	"Weapon:GetActivity": {
		"body": [
			"GetActivity()$0"
		],
		"description": "Returns the sequence enumeration number that the weapon is playing.\n\nThis can return inconsistent results between the server and client.",
		"prefix": "GetActivity"
	},
	"Weapon:GetHoldType": {
		"body": [
			"GetHoldType()$0"
		],
		"description": "Returns the hold type of the weapon.",
		"prefix": "GetHoldType"
	},
	"Weapon:GetMaxClip1": {
		"body": [
			"GetMaxClip1()$0"
		],
		"description": "Returns maximum primary clip size",
		"prefix": "GetMaxClip1"
	},
	"Weapon:GetMaxClip2": {
		"body": [
			"GetMaxClip2()$0"
		],
		"description": "Returns maximum secondary clip size",
		"prefix": "GetMaxClip2"
	},
	"Weapon:GetNextPrimaryFire": {
		"body": [
			"GetNextPrimaryFire()$0"
		],
		"description": "Gets the next time the weapon can primary fire. ( Can call WEAPON:PrimaryAttack )",
		"prefix": "GetNextPrimaryFire"
	},
	"Weapon:GetNextSecondaryFire": {
		"body": [
			"GetNextSecondaryFire()$0"
		],
		"description": "Gets the next time the weapon can secondary fire. ( Can call WEAPON:SecondaryAttack )",
		"prefix": "GetNextSecondaryFire"
	},
	"Weapon:GetPrimaryAmmoType": {
		"body": [
			"GetPrimaryAmmoType()$0"
		],
		"description": "Gets the primary ammo type of the given weapon.",
		"prefix": "GetPrimaryAmmoType"
	},
	"Weapon:GetPrintName": {
		"body": [
			"GetPrintName()$0"
		],
		"description": "Returns the non-internal name of the weapon, that should be for displaying.\n\nIf that returns an untranslated message (#HL2_XX), use language.GetPhrase to see the \"nice\" name.\nIf SWEP.PrintName is not set in the Weapon or the Weapon Base then \"\" will be returned.",
		"prefix": "GetPrintName"
	},
	"Weapon:GetSecondaryAmmoType": {
		"body": [
			"GetSecondaryAmmoType()$0"
		],
		"description": "Gets the ammo type of the given weapons secondary fire.",
		"prefix": "GetSecondaryAmmoType"
	},
	"Weapon:GetSlot": {
		"body": [
			"GetSlot()$0"
		],
		"description": "Returns the slot of the weapon.\nThe slot numbers start from 0.",
		"prefix": "GetSlot"
	},
	"Weapon:GetSlotPos": {
		"body": [
			"GetSlotPos()$0"
		],
		"description": "Returns slot position of the weapon",
		"prefix": "GetSlotPos"
	},
	"Weapon:GetWeaponViewModel": {
		"body": [
			"GetWeaponViewModel()$0"
		],
		"description": "Returns the view model of the weapon.",
		"prefix": "GetWeaponViewModel"
	},
	"Weapon:GetWeaponWorldModel": {
		"body": [
			"GetWeaponWorldModel()$0"
		],
		"description": "Returns the world model of the weapon.",
		"prefix": "GetWeaponWorldModel"
	},
	"Weapon:GetWeight": {
		"body": [
			"GetWeight()$0"
		],
		"description": "Returns the \"weight\" of the weapon, which is used when deciding which Weapon is better by the engine.",
		"prefix": "GetWeight"
	},
	"Weapon:HasAmmo": {
		"body": [
			"HasAmmo()$0"
		],
		"description": "Returns whether the weapon has ammo left or not. It will return false when there's no ammo left in the magazine **and** when there's no reserve ammo left.\n\nThis will return true for weapons like crowbar, gravity gun, etc.",
		"prefix": "HasAmmo"
	},
	"Weapon:IsCarriedByLocalPlayer": {
		"body": [
			"IsCarriedByLocalPlayer()$0"
		],
		"description": "Returns whenever the weapon is carried by the local player.",
		"prefix": "IsCarriedByLocalPlayer"
	},
	"Weapon:IsScripted": {
		"body": [
			"IsScripted()$0"
		],
		"description": "Checks if the weapon is a SWEP or a built-in weapon.",
		"prefix": "IsScripted"
	},
	"Weapon:IsWeaponVisible": {
		"body": [
			"IsWeaponVisible()$0"
		],
		"description": "Returns whether the weapon is visible. The term visibility is not exactly what gets checked here, first it checks if the owner is a player, then checks if the active view model has EF_NODRAW flag NOT set.",
		"prefix": "IsWeaponVisible"
	},
	"Weapon:LastShootTime": {
		"body": [
			"LastShootTime()$0"
		],
		"description": "Returns the time since this weapon last fired a bullet with Entity:FireBullets in seconds. It is not networked.",
		"prefix": "LastShootTime"
	},
	"Weapon:SendWeaponAnim": {
		"body": [
			"SendWeaponAnim(${1:act})$0"
		],
		"description": "Forces weapon to play activity/animation.",
		"prefix": "SendWeaponAnim"
	},
	"Weapon:SetClip1": {
		"body": [
			"SetClip1(${1:ammo})$0"
		],
		"description": "Lets you change the number of bullets in the given weapons primary clip.",
		"prefix": "SetClip1"
	},
	"Weapon:SetClip2": {
		"body": [
			"SetClip2(${1:ammo})$0"
		],
		"description": "Lets you change the number of bullets in the given weapons secondary clip.",
		"prefix": "SetClip2"
	},
	"Weapon:SetHoldType": {
		"body": [
			"SetHoldType(${1:name})$0"
		],
		"description": "Sets the hold type of the weapon. This function also calls WEAPON:SetWeaponHoldType and properly networks it to all clients.\n\nThis only works on scripted weapons.\n\nUsing this function on weapons held by bots will not network holdtype changes to clients if the world model is set to an empty string (SWEP.WorldModel = \"\").",
		"prefix": "SetHoldType"
	},
	"Weapon:SetLastShootTime": {
		"body": [
			"SetLastShootTime(${1:time=CurTime()})$0"
		],
		"description": "Sets the time since this weapon last fired in seconds. Used in conjunction with Weapon:LastShootTime",
		"prefix": "SetLastShootTime"
	},
	"Weapon:SetNextPrimaryFire": {
		"body": [
			"SetNextPrimaryFire(${1:time})$0"
		],
		"description": "Sets when the weapon can fire again. Time should be based on Global.CurTime.\n\nThis will fire extra bullets if the time is set to less than Global.CurTime.",
		"prefix": "SetNextPrimaryFire"
	},
	"Weapon:SetNextSecondaryFire": {
		"body": [
			"SetNextSecondaryFire(${1:time})$0"
		],
		"description": "Sets when the weapon can alt-fire again. Time should be based on Global.CurTime.",
		"prefix": "SetNextSecondaryFire"
	},
	"bf_read:ReadAngle": {
		"body": [
			"ReadAngle()$0"
		],
		"description": "Reads an returns an angle object from the bitstream.",
		"prefix": "ReadAngle"
	},
	"bf_read:ReadBool": {
		"body": [
			"ReadBool()$0"
		],
		"description": "Reads 1 bit an returns a bool representing the bit.",
		"prefix": "ReadBool"
	},
	"bf_read:ReadChar": {
		"body": [
			"ReadChar()$0"
		],
		"description": "Reads a signed char and returns a number from -127 to 127 representing the ascii value of that char.",
		"prefix": "ReadChar"
	},
	"bf_read:ReadEntity": {
		"body": [
			"ReadEntity()$0"
		],
		"description": "Reads a short representing an entity index and returns the matching entity handle.",
		"prefix": "ReadEntity"
	},
	"bf_read:ReadFloat": {
		"body": [
			"ReadFloat()$0"
		],
		"description": "Reads a 4 byte float from the bitstream and returns it.",
		"prefix": "ReadFloat"
	},
	"bf_read:ReadLong": {
		"body": [
			"ReadLong()$0"
		],
		"description": "Reads a 4 byte long from the bitstream and returns it.",
		"prefix": "ReadLong"
	},
	"bf_read:ReadShort": {
		"body": [
			"ReadShort()$0"
		],
		"description": "Reads a 2 byte short from the bitstream and returns it.",
		"prefix": "ReadShort"
	},
	"bf_read:ReadString": {
		"body": [
			"ReadString()$0"
		],
		"description": "Reads a null terminated string from the bitstream.",
		"prefix": "ReadString"
	},
	"bf_read:ReadVector": {
		"body": [
			"ReadVector()$0"
		],
		"description": "Reads a special encoded vector from the bitstream and returns it, this function is not suitable to send normals.",
		"prefix": "ReadVector"
	},
	"bf_read:ReadVectorNormal": {
		"body": [
			"ReadVectorNormal()$0"
		],
		"description": "Reads a special encoded vector normal from the bitstream and returns it, this function is not suitable to send vectors that represent a position.",
		"prefix": "ReadVectorNormal"
	},
	"bf_read:Reset": {
		"body": [
			"Reset()$0"
		],
		"description": "Rewinds the bitstream so it can be read again.",
		"prefix": "Reset"
	}
}